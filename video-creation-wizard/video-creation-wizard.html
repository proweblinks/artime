<!-- ================================================================
     YOUTUBE VIDEO OPTIMIZER - VIDEO CREATION WIZARD
     ================================================================

     Structure:
     - SECTION 1: External Dependencies (CDN)
     - SECTION 2: Styles (CSS)
     - SECTION 3: HTML Container
     - SECTION 4: Configuration Data (Platforms, Niches, Styles)
     - SECTION 5: State Management
     - SECTION 6: Core Functions
     - SECTION 7: Render Functions

     Wizard Steps:
     1. Platform & Format - Select target platform and aspect ratio
     2. Niche & Style - Choose content niche and visual style
     3. Script Generation - AI generates video script with scenes
     4. Storyboard - Generate images for each scene
     5. Animation - Animate images to video (Runpod/Veo)
     6. Assembly - Combine scenes, add music, captions
     7. Export - Final render and download

     Video Generation Engines:
     - Runpod Multi-talk: 15-second clips, ~$0.03-0.05/clip
     - Google Veo 3.1: 8-second base (extendable), $0.15-0.40/second

     Access: All authenticated users (with token system)
     Last Updated: December 2025
     ================================================================ -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Video Creation Wizard - YouTubeHub</title>

    <!-- PWA Manifest & Theme -->
    <link rel="manifest" href='data:application/manifest+json,{"name":"YouTubeHub Video Creator","short_name":"Video Creator","description":"AI-powered video creation from scratch","start_url":"/video-creation-wizard","display":"standalone","background_color":"#0f172a","theme_color":"#8b5cf6","orientation":"portrait-primary","icons":[{"src":"https://ytseo.siteuo.com/icon-192.png","sizes":"192x192","type":"image/png","purpose":"any maskable"},{"src":"https://ytseo.siteuo.com/icon-512.png","sizes":"512x512","type":"image/png","purpose":"any maskable"}]}'>
    <meta name="theme-color" content="#8b5cf6">

    <!-- ============================================
         SECTION 1: EXTERNAL DEPENDENCIES
         ============================================ -->

    <!-- 1.0 Performance: Preconnect & DNS Prefetch -->
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://firestore.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://firebasestorage.googleapis.com" crossorigin>
    <link rel="dns-prefetch" href="https://www.gstatic.com">
    <link rel="dns-prefetch" href="https://firestore.googleapis.com">

    <!-- 1.1 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 1.2 Google Fonts for Caption Styling -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Bebas+Neue&family=Inter:wght@400;600;700&family=Montserrat:wght@400;600;700;800&family=Oswald:wght@400;600;700&family=Playfair+Display:wght@400;600;700&family=Poppins:wght@400;600;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- 1.3 Firebase SDKs -->
    <link rel="preload" href="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js" as="script">
    <link rel="preload" href="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js" as="script">
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-functions-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-storage-compat.js"></script>

    <!-- VideoPreviewEngine (inlined to avoid path issues with Firebase rewrites) -->
    <script>
    /**
     * VideoPreviewEngine - Client-side video preview compositor
     * Renders scenes to a canvas with synchronized audio, transitions,
     * Ken Burns effects, and caption overlays.
     */
    class VideoPreviewEngine {
        constructor(canvas, options = {}) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');

            // Dimensions
            this.width = options.width || 1280;
            this.height = options.height || 720;
            canvas.width = this.width;
            canvas.height = this.height;

            // State
            this.scenes = [];
            this.currentTime = 0;
            this.isPlaying = false;
            this.isSeeking = false;
            this.totalDuration = 0;
            this.currentSceneIndex = -1;

            // Audio
            this.audioElements = new Map();
            this.musicElement = null;
            this.musicVolume = 0.3;
            this.voiceVolume = 1.0;

            // Media cache
            this.imageCache = new Map();
            this.videoCache = new Map();

            // Animation
            this.animationFrameId = null;
            this.lastFrameTime = 0;

            // Callbacks
            this.onTimeUpdate = options.onTimeUpdate || (() => {});
            this.onSceneChange = options.onSceneChange || (() => {});
            this.onEnded = options.onEnded || (() => {});
            this.onLoadProgress = options.onLoadProgress || (() => {});
            this.onReady = options.onReady || (() => {});

            // Captions - unified system matching export styles
            this.captionsEnabled = true;
            this.captionStyle = 'karaoke';  // Default style
            this.captionPosition = 'bottom';
            this.captionSize = 1.0;  // Size multiplier (0.7 - 1.5)

            // Enhanced caption properties (Phase 2)
            this.captionMode = 'word';           // 'word' or 'sentence'
            this.captionFontFamily = 'Montserrat';
            this.captionFontWeight = 600;
            this.captionFillColor = '#FFFFFF';
            this.captionStrokeColor = '#000000';
            this.captionStrokeWidth = 2;
            this.captionEffect = 'none';         // 'none', 'pop', 'fade', 'zoom', 'bounce'
            this.captionHighlightColor = '#FBBF24';

            this._renderLoop = this._renderLoop.bind(this);
        }

        async loadScenes(scenes) {
            this.scenes = scenes.map((scene, index) => ({
                ...scene,
                index,
                startTime: 0,
                endTime: 0
            }));

            this._calculateTiming();
            await this._preloadMedia();
            this._renderFrame();
            this.onReady();
        }

        _calculateTiming() {
            let currentTime = 0;
            for (const scene of this.scenes) {
                scene.startTime = currentTime;
                scene.endTime = currentTime + (scene.visualDuration || scene.duration || 5);
                currentTime = scene.endTime;
            }
            this.totalDuration = currentTime;
        }

        async _preloadMedia() {
            const loadPromises = [];
            let loaded = 0;
            let total = 0;

            // Count total media items to load
            for (const scene of this.scenes) {
                if (scene.imageUrl && !scene.videoUrl) total++;
                if (scene.videoUrl) total++;
                if (scene.voiceoverUrl) total++;
            }

            // If no media to load, still report progress
            if (total === 0) {
                this.onLoadProgress(1);
                return;
            }

            const updateProgress = () => {
                loaded++;
                this.onLoadProgress(Math.min(loaded / total, 1));
            };

            for (const scene of this.scenes) {
                if (scene.imageUrl && !scene.videoUrl) {
                    loadPromises.push(
                        this._loadImage(scene.imageUrl)
                            .then(updateProgress)
                            .catch(updateProgress) // Still update progress on error
                    );
                }

                if (scene.videoUrl) {
                    loadPromises.push(
                        this._loadVideo(scene.videoUrl)
                            .then(updateProgress)
                            .catch(updateProgress)
                    );
                }

                if (scene.voiceoverUrl) {
                    loadPromises.push(
                        this._loadAudio(scene.id, scene.voiceoverUrl)
                            .then(updateProgress)
                            .catch(updateProgress)
                    );
                }
            }

            // Use allSettled to ensure we complete even if some fail
            await Promise.allSettled(loadPromises);
        }

        _loadImage(url) {
            return new Promise((resolve) => {
                if (this.imageCache.has(url)) {
                    resolve(this.imageCache.get(url));
                    return;
                }

                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    this.imageCache.set(url, img);
                    resolve(img);
                };
                img.onerror = () => {
                    console.warn('Failed to load image:', url);
                    resolve(null);
                };
                img.src = url;
            });
        }

        _loadVideo(url) {
            return new Promise((resolve) => {
                if (this.videoCache.has(url)) {
                    resolve(this.videoCache.get(url));
                    return;
                }

                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                video.muted = true;
                video.playsInline = true;
                video.preload = 'auto';

                video.onloadeddata = () => {
                    this.videoCache.set(url, video);
                    resolve(video);
                };
                video.onerror = () => {
                    console.warn('Failed to load video:', url);
                    resolve(null);
                };
                video.src = url;
                video.load();
            });
        }

        _loadAudio(sceneId, url) {
            return new Promise((resolve) => {
                if (this.audioElements.has(sceneId)) {
                    resolve(this.audioElements.get(sceneId));
                    return;
                }

                const audio = new Audio();
                audio.crossOrigin = 'anonymous';
                audio.preload = 'auto';

                audio.oncanplaythrough = () => {
                    this.audioElements.set(sceneId, audio);
                    resolve(audio);
                };
                audio.onerror = () => {
                    console.warn('Failed to load audio:', url);
                    resolve(null);
                };
                audio.src = url;
                audio.load();
            });
        }

        async setBackgroundMusic(url, volume = 0.3) {
            // Stop any existing music
            if (this.musicElement) {
                this.musicElement.pause();
                this.musicElement = null;
            }

            if (url) {
                return new Promise((resolve, reject) => {
                    this.musicElement = new Audio(url);
                    this.musicElement.loop = true;
                    this.musicElement.volume = volume;
                    this.musicVolume = volume;

                    // Wait for audio to be ready to play
                    this.musicElement.addEventListener('canplaythrough', () => {
                        console.log('[PreviewEngine] Music loaded and ready:', url.substring(0, 50));
                        if (this.isPlaying) {
                            this.musicElement.currentTime = this.currentTime;
                            this.musicElement.play().catch(e => {
                                console.warn('[PreviewEngine] Music autoplay blocked:', e.message);
                            });
                        }
                        resolve();
                    }, { once: true });

                    this.musicElement.addEventListener('error', (e) => {
                        console.error('[PreviewEngine] Music load error:', e);
                        reject(new Error('Failed to load music'));
                    }, { once: true });

                    // Start loading the audio
                    this.musicElement.load();
                });
            }
        }

        stopBackgroundMusic() {
            if (this.musicElement) {
                this.musicElement.pause();
                this.musicElement = null;
            }
        }

        play() {
            if (this.isPlaying) return;

            this.isPlaying = true;
            this.lastFrameTime = performance.now();

            if (this.musicElement) {
                this.musicElement.currentTime = this.currentTime;
                this.musicElement.play().catch(() => {});
            }

            this._syncAudio();
            this.animationFrameId = requestAnimationFrame(this._renderLoop);
        }

        pause() {
            this.isPlaying = false;

            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }

            this.audioElements.forEach(audio => audio.pause());
            if (this.musicElement) this.musicElement.pause();
        }

        stop() {
            this.pause();
            this.seek(0);
        }

        seek(time) {
            this.isSeeking = true;
            this.currentTime = Math.max(0, Math.min(time, this.totalDuration));

            this._syncAudio();

            if (this.musicElement) {
                this.musicElement.currentTime = this.currentTime;
            }

            this._renderFrame();
            this.onTimeUpdate(this.currentTime);
            this.isSeeking = false;
        }

        jumpToScene(sceneIndex) {
            const scene = this.scenes[sceneIndex];
            if (scene) {
                this.seek(scene.startTime);
            }
        }

        _syncAudio() {
            const currentScene = this._getSceneAtTime(this.currentTime);

            // Pause audio from other scenes
            this.audioElements.forEach((audio, sceneId) => {
                if (!currentScene || sceneId !== currentScene.id) {
                    if (!audio.paused) {
                        audio.pause();
                    }
                }
            });

            if (currentScene) {
                const audio = this.audioElements.get(currentScene.id);
                if (audio) {
                    const sceneLocalTime = this.currentTime - currentScene.startTime;
                    const voiceoverOffset = currentScene.voiceoverOffset || 0;
                    const audioTime = sceneLocalTime - voiceoverOffset;

                    if (audioTime >= 0 && audioTime < audio.duration) {
                        // Only sync if audio has drifted more than 0.3s to avoid stuttering
                        const drift = Math.abs(audio.currentTime - audioTime);
                        if (drift > 0.3) {
                            audio.currentTime = audioTime;
                        }

                        audio.volume = this.voiceVolume;

                        // Only call play if not already playing
                        if (this.isPlaying && audio.paused) {
                            audio.play().catch(() => {});
                        }
                    } else {
                        if (!audio.paused) {
                            audio.pause();
                        }
                    }
                }
            }
        }

        _renderLoop(timestamp) {
            if (!this.isPlaying) return;

            const deltaTime = (timestamp - this.lastFrameTime) / 1000;
            this.lastFrameTime = timestamp;

            this.currentTime += deltaTime;

            if (this.currentTime >= this.totalDuration) {
                this.currentTime = this.totalDuration;
                this.pause();
                this.onEnded();
                return;
            }

            this._renderFrame();

            if (Math.floor(this.currentTime * 2) !== Math.floor((this.currentTime - deltaTime) * 2)) {
                this._syncAudio();
            }

            this.onTimeUpdate(this.currentTime);
            this.animationFrameId = requestAnimationFrame(this._renderLoop);
        }

        _renderFrame() {
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0, 0, this.width, this.height);

            const currentScene = this._getSceneAtTime(this.currentTime);
            const prevScene = this._getPreviousScene(currentScene);

            if (!currentScene) return;

            const transitionProgress = this._getTransitionProgress(currentScene);

            if (transitionProgress !== null && prevScene) {
                this._renderTransition(prevScene, currentScene, transitionProgress);
            } else {
                this._renderScene(currentScene);
            }

            // Only render captions during the voiceover timing window
            if (this.captionsEnabled && currentScene.caption) {
                const sceneLocalTime = this.currentTime - currentScene.startTime;
                const voiceoverOffset = currentScene.voiceoverOffset || 0;
                const voiceoverDuration = currentScene.voiceoverDuration || (currentScene.duration * 0.85);

                // Check if we're within the voiceover window
                const captionStart = voiceoverOffset;
                const captionEnd = voiceoverOffset + voiceoverDuration;

                if (sceneLocalTime >= captionStart && sceneLocalTime < captionEnd) {
                    this._renderCaption(currentScene);
                }
            }

            if (currentScene.index !== this.currentSceneIndex) {
                this.currentSceneIndex = currentScene.index;
                this.onSceneChange(this.currentSceneIndex);
            }
        }

        _getSceneAtTime(time) {
            return this.scenes.find(scene =>
                time >= scene.startTime && time < scene.endTime
            ) || this.scenes[this.scenes.length - 1];
        }

        _getPreviousScene(currentScene) {
            if (!currentScene || currentScene.index === 0) return null;
            return this.scenes[currentScene.index - 1];
        }

        _getTransitionProgress(scene) {
            if (!scene || scene.index === 0) return null;

            const transitionDuration = scene.transitionDuration || 0.5;
            const timeIntoScene = this.currentTime - scene.startTime;

            if (timeIntoScene < transitionDuration) {
                return timeIntoScene / transitionDuration;
            }

            return null;
        }

        _renderScene(scene, opacity = 1) {
            this.ctx.save();
            this.ctx.globalAlpha = opacity;

            if (scene.videoUrl && this.videoCache.has(scene.videoUrl)) {
                this._renderVideoScene(scene);
            } else if (scene.imageUrl) {
                this._renderImageScene(scene);
            } else {
                this._renderPlaceholder(scene);
            }

            this.ctx.restore();
        }

        _renderVideoScene(scene) {
            const video = this.videoCache.get(scene.videoUrl);
            if (!video) return;

            const sceneLocalTime = this.currentTime - scene.startTime;

            if (Math.abs(video.currentTime - sceneLocalTime) > 0.2) {
                video.currentTime = sceneLocalTime;
            }

            if (this.isPlaying && video.paused) {
                video.play().catch(() => {});
            } else if (!this.isPlaying && !video.paused) {
                video.pause();
            }

            this._drawMediaCover(video, video.videoWidth, video.videoHeight);
        }

        _renderImageScene(scene) {
            const img = this.imageCache.get(scene.imageUrl);
            if (!img) {
                this._renderPlaceholder(scene);
                return;
            }

            const progress = (this.currentTime - scene.startTime) / (scene.endTime - scene.startTime);
            const kenBurns = scene.kenBurns || {
                startZoom: 1.0,
                endZoom: 1.15,
                startX: 0.5,
                startY: 0.5,
                endX: 0.5,
                endY: 0.5
            };

            const zoom = kenBurns.startZoom + (kenBurns.endZoom - kenBurns.startZoom) * progress;
            const panX = (kenBurns.startX || 0.5) + ((kenBurns.endX || 0.5) - (kenBurns.startX || 0.5)) * progress;
            const panY = (kenBurns.startY || 0.5) + ((kenBurns.endY || 0.5) - (kenBurns.startY || 0.5)) * progress;

            this.ctx.save();
            this.ctx.translate(this.width / 2, this.height / 2);
            this.ctx.scale(zoom, zoom);
            this.ctx.translate(
                -this.width / 2 + (panX - 0.5) * this.width * 0.1,
                -this.height / 2 + (panY - 0.5) * this.height * 0.1
            );

            this._drawMediaCover(img, img.width, img.height);
            this.ctx.restore();
        }

        _drawMediaCover(media, mediaWidth, mediaHeight) {
            const canvasRatio = this.width / this.height;
            const mediaRatio = mediaWidth / mediaHeight;

            let drawWidth, drawHeight, offsetX, offsetY;

            if (mediaRatio > canvasRatio) {
                drawHeight = this.height;
                drawWidth = this.height * mediaRatio;
                offsetX = (this.width - drawWidth) / 2;
                offsetY = 0;
            } else {
                drawWidth = this.width;
                drawHeight = this.width / mediaRatio;
                offsetX = 0;
                offsetY = (this.height - drawHeight) / 2;
            }

            this.ctx.drawImage(media, offsetX, offsetY, drawWidth, drawHeight);
        }

        _renderPlaceholder(scene) {
            // Gradient background
            const gradient = this.ctx.createLinearGradient(0, 0, this.width, this.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#2d1b4e');
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, this.width, this.height);

            // Scene number badge
            this.ctx.fillStyle = 'rgba(139, 92, 246, 0.3)';
            this.ctx.beginPath();
            this.ctx.arc(this.width / 2, this.height / 2 - 40, 60, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            this.ctx.font = 'bold 42px system-ui';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(`${scene.index + 1}`, this.width / 2, this.height / 2 - 40);

            // "Scene X" label
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            this.ctx.font = '24px system-ui';
            this.ctx.fillText(`Scene ${scene.index + 1}`, this.width / 2, this.height / 2 + 30);

            // Show first part of narration if available
            const narration = scene.caption || scene.narration || '';
            if (narration) {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.font = '18px system-ui';
                const truncated = narration.length > 80 ? narration.substring(0, 80) + '...' : narration;
                this.ctx.fillText(truncated, this.width / 2, this.height / 2 + 70);
            }

            // Duration indicator
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.font = '16px system-ui';
            this.ctx.fillText(`${scene.duration || 8}s`, this.width / 2, this.height - 30);
        }

        _renderTransition(fromScene, toScene, progress) {
            const transition = toScene.transition || 'cut';

            switch (transition) {
                case 'fade':
                    this._renderFadeTransition(fromScene, toScene, progress);
                    break;
                case 'slide':
                    this._renderSlideTransition(fromScene, toScene, progress);
                    break;
                case 'zoom':
                    this._renderZoomTransition(fromScene, toScene, progress);
                    break;
                case 'cut':
                default:
                    this._renderScene(toScene);
                    break;
            }
        }

        _renderFadeTransition(fromScene, toScene, progress) {
            this._renderScene(fromScene, 1 - progress);
            this._renderScene(toScene, progress);
        }

        _renderSlideTransition(fromScene, toScene, progress) {
            const easeProgress = this._easeInOutCubic(progress);
            const offset = this.width * (1 - easeProgress);

            this.ctx.save();
            this.ctx.translate(-offset, 0);
            this._renderScene(fromScene);
            this.ctx.restore();

            this.ctx.save();
            this.ctx.translate(this.width - offset, 0);
            this._renderScene(toScene);
            this.ctx.restore();
        }

        _renderZoomTransition(fromScene, toScene, progress) {
            const easeProgress = this._easeInOutCubic(progress);

            this.ctx.save();
            this.ctx.globalAlpha = 1 - easeProgress;
            this.ctx.translate(this.width / 2, this.height / 2);
            this.ctx.scale(1 + easeProgress * 0.3, 1 + easeProgress * 0.3);
            this.ctx.translate(-this.width / 2, -this.height / 2);
            this._renderScene(fromScene, 1);
            this.ctx.restore();

            this._renderScene(toScene, easeProgress);
        }

        _easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        /**
         * Style-aware caption rendering - matches export ASS styles
         * Supports: karaoke, beasty, hormozi, ali, podcast, minimal, none
         */
        _renderCaption(scene) {
            // Skip if style is 'none'
            if (this.captionStyle === 'none') return;

            const caption = scene.caption || scene.narration || '';
            if (!caption) return;

            // Use voiceover timing for accurate synchronization
            const voiceoverOffset = scene.voiceoverOffset || 0;
            const voiceoverDuration = scene.voiceoverDuration || (scene.duration * 0.85);
            const sceneLocalTime = this.currentTime - scene.startTime;

            // Calculate time relative to voiceover start (not scene start)
            // This ensures captions sync with audio, not visual scene boundaries
            const captionLocalTime = sceneLocalTime - voiceoverOffset;

            // Generate word timings based on actual voiceover duration
            const wordTimings = this._generateWordTimings(caption, voiceoverDuration);

            // Handle word vs sentence mode
            let displayWords, currentWordIndex;
            if (this.captionMode === 'sentence') {
                // Sentence mode: show all words, no word-by-word highlighting
                displayWords = wordTimings;
                currentWordIndex = -1; // No current word highlighting
            } else {
                // Word mode: show window of words with highlighting
                const wordsPerLine = this._getWordsPerLine();
                currentWordIndex = this._getCurrentWordIndex(wordTimings, captionLocalTime);
                displayWords = this._getDisplayWords(wordTimings, currentWordIndex, wordsPerLine);
            }

            if (displayWords.length === 0) return;

            this.ctx.save();

            // Calculate position
            let y;
            switch (this.captionPosition) {
                case 'top': y = this.height * 0.12; break;
                case 'middle': case 'center': y = this.height * 0.5; break;
                case 'bottom': default: y = this.height * 0.88; break;
            }

            // Render based on style (using captionLocalTime for word highlighting)
            switch (this.captionStyle) {
                case 'karaoke':
                    this._renderKaraokeStyle(displayWords, y, captionLocalTime, currentWordIndex);
                    break;
                case 'beasty':
                    this._renderBeastyStyle(displayWords, y, captionLocalTime, currentWordIndex);
                    break;
                case 'hormozi':
                    this._renderHormoziStyle(displayWords, y, captionLocalTime, currentWordIndex);
                    break;
                case 'ali':
                    this._renderAliStyle(displayWords, y, captionLocalTime);
                    break;
                case 'podp':
                case 'podcast':
                    this._renderPodcastStyle(displayWords, y, captionLocalTime, currentWordIndex);
                    break;
                case 'deepdiver':
                case 'minimal':
                    this._renderMinimalStyle(displayWords, y);
                    break;
                default:
                    this._renderDefaultStyle(displayWords, y, captionLocalTime, currentWordIndex);
            }

            this.ctx.restore();
        }

        _generateWordTimings(text, duration) {
            const words = text.split(/\s+/).filter(w => w.length > 0);
            if (words.length === 0) return [];

            const avgWordDuration = duration / words.length;
            return words.map((word, i) => ({
                text: word,
                start: i * avgWordDuration,
                end: (i + 1) * avgWordDuration,
                index: i
            }));
        }

        _getWordsPerLine() {
            const styleWordCounts = {
                karaoke: 4, beasty: 3, hormozi: 4, ali: 5,
                podp: 5, podcast: 5, deepdiver: 6, minimal: 6
            };
            return styleWordCounts[this.captionStyle] || 4;
        }

        _getCurrentWordIndex(wordTimings, localTime) {
            for (let i = 0; i < wordTimings.length; i++) {
                if (localTime >= wordTimings[i].start && localTime < wordTimings[i].end) {
                    return i;
                }
            }
            // Return last word if past all timings
            return wordTimings.length > 0 ? wordTimings.length - 1 : 0;
        }

        _getDisplayWords(wordTimings, currentIndex, wordsPerLine) {
            // Get a window of words centered around current word
            const halfWindow = Math.floor(wordsPerLine / 2);
            let startIndex = Math.max(0, currentIndex - halfWindow);
            let endIndex = Math.min(wordTimings.length, startIndex + wordsPerLine);

            // Adjust start if we're near the end
            if (endIndex - startIndex < wordsPerLine) {
                startIndex = Math.max(0, endIndex - wordsPerLine);
            }

            return wordTimings.slice(startIndex, endIndex);
        }

        _renderKaraokeStyle(words, y, localTime, currentWordIndex) {
            const fontSize = Math.round(this.height * 0.045 * this.captionSize);
            // Use custom font family with fallbacks
            const fontFamily = `${this.captionFontFamily}, Arial, sans-serif`;
            this.ctx.font = `${this.captionFontWeight || 'bold'} ${fontSize}px ${fontFamily}`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const text = words.map(w => w.text).join(' ');
            const x = this.width / 2;

            // Draw text stroke/outline using custom stroke settings
            if (this.captionStrokeWidth > 0) {
                this.ctx.strokeStyle = this.captionStrokeColor;
                this.ctx.lineWidth = this.captionStrokeWidth * 2;
                this.ctx.strokeText(text, x, y);
            }

            // Draw each word with appropriate color
            let xOffset = x - this.ctx.measureText(text).width / 2;
            words.forEach((word, i) => {
                const isCurrentWord = word.index === currentWordIndex;
                const isPastWord = word.index < currentWordIndex;
                const wordX = xOffset + this.ctx.measureText(word.text).width / 2;
                let wordY = y;

                // Apply text effects for current word
                if (isCurrentWord) {
                    this.ctx.save();
                    const wordWidth = this.ctx.measureText(word.text + ' ').width;
                    const wordCenterX = xOffset + wordWidth / 2;

                    // Apply effect based on setting
                    switch (this.captionEffect) {
                        case 'pop':
                            this.ctx.translate(wordCenterX, y);
                            this.ctx.scale(1.15, 1.15);
                            this.ctx.translate(-wordCenterX, -y);
                            break;
                        case 'zoom':
                            const zoomPhase = (localTime * 2) % 1;
                            const zoomScale = 1 + Math.sin(zoomPhase * Math.PI) * 0.1;
                            this.ctx.translate(wordCenterX, y);
                            this.ctx.scale(zoomScale, zoomScale);
                            this.ctx.translate(-wordCenterX, -y);
                            break;
                        case 'bounce':
                            const bouncePhase = (localTime * 4) % 1;
                            wordY = y - Math.sin(bouncePhase * Math.PI) * 5;
                            break;
                        case 'fade':
                            // Fade effect handled via alpha
                            break;
                        default:
                            // Default subtle scale
                            this.ctx.translate(wordCenterX, y);
                            this.ctx.scale(1.1, 1.1);
                            this.ctx.translate(-wordCenterX, -y);
                    }

                    // Use highlight color for current word
                    this.ctx.fillStyle = this.captionHighlightColor;
                } else if (isPastWord) {
                    this.ctx.fillStyle = this.captionFillColor;  // Custom fill for spoken words
                } else {
                    // Dimmed for future words (50% opacity of fill color)
                    const fillColor = this.captionFillColor;
                    this.ctx.fillStyle = this._hexToRgba(fillColor, 0.5);
                }

                this.ctx.fillText(word.text, wordX, wordY);

                if (isCurrentWord) this.ctx.restore();
                xOffset += this.ctx.measureText(word.text + ' ').width;
            });
        }

        // Helper to convert hex to rgba
        _hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        _renderBeastyStyle(words, y, localTime, currentWordIndex) {
            const fontSize = Math.round(this.height * 0.055 * this.captionSize);
            this.ctx.font = `900 ${fontSize}px Impact, Arial Black, sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const text = words.map(w => w.text.toUpperCase()).join(' ');
            const x = this.width / 2;

            // Black stroke for MrBeast style
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 6;
            this.ctx.strokeText(text, x, y);

            // Yellow/gold fill
            this.ctx.fillStyle = '#FBBF24';
            this.ctx.fillText(text, x, y);

            // Bounce effect on current word
            const currentWord = words.find(w => w.index === currentWordIndex);
            if (currentWord) {
                const bouncePhase = (localTime * 4) % 1;
                const bounceOffset = Math.sin(bouncePhase * Math.PI) * 3;

                // Redraw current word slightly higher for bounce effect
                let xOffset = x - this.ctx.measureText(text).width / 2;
                words.forEach((word) => {
                    const wordText = word.text.toUpperCase();
                    const wordWidth = this.ctx.measureText(wordText + ' ').width;
                    if (word.index === currentWordIndex) {
                        this.ctx.strokeText(wordText, xOffset + this.ctx.measureText(wordText).width / 2, y - bounceOffset);
                        this.ctx.fillText(wordText, xOffset + this.ctx.measureText(wordText).width / 2, y - bounceOffset);
                    }
                    xOffset += wordWidth;
                });
            }
        }

        _renderHormoziStyle(words, y, localTime, currentWordIndex) {
            const fontSize = Math.round(this.height * 0.042 * this.captionSize);
            this.ctx.font = `bold ${fontSize}px Arial, sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const x = this.width / 2;
            const padding = 8;

            // Calculate total width
            let totalWidth = 0;
            words.forEach((word, i) => {
                totalWidth += this.ctx.measureText(word.text).width;
                if (i < words.length - 1) totalWidth += this.ctx.measureText(' ').width;
            });

            // Draw each word
            let xOffset = x - totalWidth / 2;
            words.forEach((word, i) => {
                const wordWidth = this.ctx.measureText(word.text).width;
                const isHighlighted = word.index === currentWordIndex ||
                                     (word.index === currentWordIndex + 1 && words.length > 2);

                if (isHighlighted) {
                    // Green box background for highlighted words
                    const boxX = xOffset - padding / 2;
                    const boxY = y - fontSize / 2 - padding / 2;
                    const boxW = wordWidth + padding;
                    const boxH = fontSize + padding;

                    // Draw green box with rounded corners
                    this.ctx.fillStyle = '#22C55E';
                    this.ctx.beginPath();
                    this.ctx.roundRect(boxX, boxY, boxW, boxH, 4);
                    this.ctx.fill();

                    // White text on green
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText(word.text, xOffset + wordWidth / 2, y);
                } else {
                    // Regular white text with shadow
                    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeText(word.text, xOffset + wordWidth / 2, y);
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText(word.text, xOffset + wordWidth / 2, y);
                }

                xOffset += wordWidth + this.ctx.measureText(' ').width;
            });
        }

        _renderAliStyle(words, y, localTime) {
            const fontSize = Math.round(this.height * 0.04 * this.captionSize);
            this.ctx.font = `bold ${fontSize}px Arial, sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const text = words.map(w => w.text).join(' ');
            const x = this.width / 2;

            // Animated glow effect
            const glowIntensity = 0.5 + 0.5 * Math.sin(localTime * 3);
            const glowRadius = 10 + 10 * glowIntensity;

            // Draw glow layers
            this.ctx.shadowColor = 'rgba(236, 72, 153, 0.8)';  // Pink glow
            this.ctx.shadowBlur = glowRadius;
            this.ctx.fillStyle = '#EC4899';  // Pink text

            // Multiple passes for stronger glow
            for (let i = 0; i < 3; i++) {
                this.ctx.fillText(text, x, y);
            }

            // Clear shadow for final crisp text
            this.ctx.shadowBlur = 0;
            this.ctx.fillText(text, x, y);
        }

        _renderPodcastStyle(words, y, localTime, currentWordIndex) {
            const fontSize = Math.round(this.height * 0.038 * this.captionSize);
            this.ctx.font = `500 ${fontSize}px Arial, sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const x = this.width / 2;

            // Draw each word with fade effect
            let totalWidth = 0;
            words.forEach((word, i) => {
                totalWidth += this.ctx.measureText(word.text).width;
                if (i < words.length - 1) totalWidth += this.ctx.measureText(' ').width;
            });

            let xOffset = x - totalWidth / 2;
            words.forEach((word, i) => {
                const wordWidth = this.ctx.measureText(word.text).width;

                // Fade animation: current word is full opacity, others fade
                let opacity;
                if (word.index === currentWordIndex) {
                    opacity = 1;
                } else if (word.index < currentWordIndex) {
                    opacity = 0.7;
                } else {
                    opacity = 0.4;
                }

                // Shadow
                this.ctx.strokeStyle = `rgba(0, 0, 0, ${opacity * 0.6})`;
                this.ctx.lineWidth = 3;
                this.ctx.strokeText(word.text, xOffset + wordWidth / 2, y);

                // Text
                this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                this.ctx.fillText(word.text, xOffset + wordWidth / 2, y);

                xOffset += wordWidth + this.ctx.measureText(' ').width;
            });
        }

        _renderMinimalStyle(words, y) {
            const fontSize = Math.round(this.height * 0.032 * this.captionSize);
            this.ctx.font = `400 ${fontSize}px Arial, sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const text = words.map(w => w.text.toLowerCase()).join(' ');
            const x = this.width / 2;

            // Subtle shadow
            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            this.ctx.lineWidth = 2;
            this.ctx.strokeText(text, x, y);

            // Light text
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            this.ctx.fillText(text, x, y);
        }

        _renderDefaultStyle(words, y, localTime, currentWordIndex) {
            // Fallback to karaoke-like style
            this._renderKaraokeStyle(words, y, localTime, currentWordIndex);
        }

        _wrapText(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            for (const word of words) {
                const testLine = currentLine ? `${currentLine} ${word}` : word;
                const metrics = this.ctx.measureText(testLine);

                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }

            if (currentLine) {
                lines.push(currentLine);
            }

            return lines;
        }

        setVoiceVolume(volume) {
            this.voiceVolume = Math.max(0, Math.min(1, volume));
            this.audioElements.forEach(audio => {
                audio.volume = this.voiceVolume;
            });
        }

        setMusicVolume(volume) {
            this.musicVolume = Math.max(0, Math.min(1, volume));
            if (this.musicElement) {
                this.musicElement.volume = this.musicVolume;
            }
        }

        setCaptionsEnabled(enabled) {
            this.captionsEnabled = enabled;
            this._renderFrame();
        }

        setCaptionStyle(style) {
            this.captionStyle = style;
            this._renderFrame();
        }

        setCaptionPosition(position) {
            this.captionPosition = position;
            this._renderFrame();
        }

        setCaptionSize(size) {
            this.captionSize = Math.max(0.5, Math.min(2, parseFloat(size) || 1));
            this._renderFrame();
        }

        // Enhanced caption setters (Phase 2)
        setCaptionMode(mode) {
            this.captionMode = mode; // 'word' or 'sentence'
            this._renderFrame();
        }

        setCaptionFontFamily(font) {
            this.captionFontFamily = font;
            this._renderFrame();
        }

        setCaptionFillColor(color) {
            this.captionFillColor = color;
            this._renderFrame();
        }

        setCaptionStrokeColor(color) {
            this.captionStrokeColor = color;
            this._renderFrame();
        }

        setCaptionStrokeWidth(width) {
            this.captionStrokeWidth = Math.max(0, Math.min(8, parseFloat(width) || 2));
            this._renderFrame();
        }

        setCaptionEffect(effect) {
            this.captionEffect = effect;
            this._renderFrame();
        }

        setCaptionHighlightColor(color) {
            this.captionHighlightColor = color;
            this._renderFrame();
        }

        /**
         * Reattach to a new canvas element (used after DOM re-render)
         */
        attachToCanvas(canvas) {
            if (!canvas) return false;

            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            canvas.width = this.width;
            canvas.height = this.height;

            // Render current frame to new canvas immediately
            this._renderFrame();
            return true;
        }

        getState() {
            return {
                currentTime: this.currentTime,
                totalDuration: this.totalDuration,
                isPlaying: this.isPlaying,
                currentSceneIndex: this.currentSceneIndex,
                progress: this.totalDuration > 0 ? this.currentTime / this.totalDuration : 0
            };
        }

        updateScene(sceneId, updates) {
            const scene = this.scenes.find(s => s.id === sceneId);
            if (scene) {
                Object.assign(scene, updates);
                this._calculateTiming();
                this._renderFrame();
            }
        }

        reorderScenes(fromIndex, toIndex) {
            const [scene] = this.scenes.splice(fromIndex, 1);
            this.scenes.splice(toIndex, 0, scene);

            this.scenes.forEach((s, i) => s.index = i);

            this._calculateTiming();
            this._renderFrame();
        }

        // Export video using MediaRecorder (client-side rendering)
        async exportToVideo(onProgress = () => {}) {
            return new Promise(async (resolve, reject) => {
                try {
                    // Pause any current playback
                    this.pause();
                    this.seek(0);

                    // Wait a bit for seek to complete
                    await new Promise(r => setTimeout(r, 100));

                    // Get canvas stream
                    const canvasStream = this.canvas.captureStream(30); // 30 FPS

                    // Create audio context for mixing audio
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const destination = audioContext.createMediaStreamDestination();

                    // Load and connect all audio sources
                    const audioPromises = [];
                    for (const scene of this.scenes) {
                        if (scene.voiceoverUrl) {
                            audioPromises.push(
                                fetch(scene.voiceoverUrl)
                                    .then(r => r.arrayBuffer())
                                    .then(buffer => audioContext.decodeAudioData(buffer))
                                    .then(audioBuffer => ({
                                        buffer: audioBuffer,
                                        startTime: scene.startTime,
                                        sceneId: scene.id
                                    }))
                                    .catch(err => {
                                        console.warn('Failed to load audio for scene:', scene.id, err);
                                        return null;
                                    })
                            );
                        }
                    }

                    const audioBuffers = (await Promise.all(audioPromises)).filter(Boolean);

                    // Combine video and audio streams
                    const combinedStream = new MediaStream([
                        ...canvasStream.getVideoTracks(),
                        ...destination.stream.getAudioTracks()
                    ]);

                    // Setup MediaRecorder
                    const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')
                        ? 'video/webm;codecs=vp9,opus'
                        : MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')
                            ? 'video/webm;codecs=vp8,opus'
                            : 'video/webm';

                    const recorder = new MediaRecorder(combinedStream, {
                        mimeType,
                        videoBitsPerSecond: 5000000 // 5 Mbps
                    });

                    const chunks = [];
                    recorder.ondataavailable = (e) => {
                        if (e.data.size > 0) chunks.push(e.data);
                    };

                    recorder.onstop = () => {
                        audioContext.close();
                        const blob = new Blob(chunks, { type: mimeType });
                        resolve(blob);
                    };

                    recorder.onerror = (e) => {
                        audioContext.close();
                        reject(new Error('Recording failed: ' + e.error));
                    };

                    // Schedule all audio to play at correct times
                    const scheduledSources = [];
                    for (const audio of audioBuffers) {
                        const source = audioContext.createBufferSource();
                        source.buffer = audio.buffer;
                        source.connect(destination);
                        scheduledSources.push({ source, startTime: audio.startTime });
                    }

                    // Start recording
                    recorder.start(100); // Collect data every 100ms

                    // Start audio context time reference
                    const audioStartTime = audioContext.currentTime;

                    // Schedule audio playback
                    for (const { source, startTime } of scheduledSources) {
                        source.start(audioStartTime + startTime);
                    }

                    // Play through the video
                    this.isPlaying = true;
                    this.currentTime = 0;
                    this.lastFrameTime = performance.now();

                    const exportRenderLoop = () => {
                        if (!this.isPlaying) return;

                        const now = performance.now();
                        const delta = (now - this.lastFrameTime) / 1000;
                        this.lastFrameTime = now;

                        this.currentTime += delta;

                        // Update progress
                        const progress = Math.min(this.currentTime / this.totalDuration, 1);
                        onProgress(Math.round(progress * 100));

                        // Render current frame
                        this._renderFrame();

                        if (this.currentTime >= this.totalDuration) {
                            // Export complete
                            this.isPlaying = false;
                            this.currentTime = this.totalDuration;

                            // Stop recording after a small delay to capture final frame
                            setTimeout(() => {
                                recorder.stop();
                                // Stop all audio sources
                                for (const { source } of scheduledSources) {
                                    try { source.stop(); } catch(e) {}
                                }
                            }, 200);
                        } else {
                            requestAnimationFrame(exportRenderLoop);
                        }
                    };

                    requestAnimationFrame(exportRenderLoop);

                } catch (error) {
                    reject(error);
                }
            });
        }

        destroy() {
            this.pause();

            this.audioElements.forEach(audio => {
                audio.pause();
                audio.src = '';
            });
            this.audioElements.clear();

            if (this.musicElement) {
                this.musicElement.pause();
                this.musicElement.src = '';
                this.musicElement = null;
            }

            this.videoCache.forEach(video => {
                video.pause();
                video.src = '';
            });
            this.videoCache.clear();

            this.imageCache.clear();

            this.ctx.clearRect(0, 0, this.width, this.height);
        }
    }
    </script>

    <!-- ============================================
         SECTION 2: STYLES
         ============================================ -->
    <style>
        /* ------------------------------------------
           2.1 BASE & RESET
           ------------------------------------------ */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }

        body {
            background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            font-size: 1rem;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            color: white;
        }

        #app-root {
            width: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
        }

        /* ------------------------------------------
           2.2 ANIMATIONS
           ------------------------------------------ */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes gradientFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(139, 92, 246, 0.3); }
            50% { box-shadow: 0 0 40px rgba(139, 92, 246, 0.6); }
        }

        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes kenBurnsPreview {
            0% { transform: scale(1) translate(0%, 0%); }
            100% { transform: scale(1.15) translate(-3%, -2%); }
        }

        /* Device Preview Modal Styles */
        @keyframes devicePreviewSlideUp {
            from { opacity: 0; transform: translateY(30px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @keyframes devicePreviewMobileSlide {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .device-preview-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease-out;
        }

        .device-preview-modal {
            position: relative;
            animation: devicePreviewSlideUp 0.3s ease-out;
            max-width: 90vw;
            max-height: 90vh;
        }

        /* Device Frames */
        .device-frame-mobile {
            width: 280px;
            height: 560px;
            background: linear-gradient(145deg, #1a1a2e, #16162a);
            border-radius: 36px;
            padding: 12px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.5), inset 0 0 0 2px rgba(255,255,255,0.1);
            position: relative;
        }

        .device-frame-mobile::before {
            content: '';
            position: absolute;
            top: 18px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 24px;
            background: #0a0a14;
            border-radius: 12px;
        }

        .device-frame-laptop {
            width: 700px;
            max-width: 85vw;
            background: linear-gradient(145deg, #1a1a2e, #16162a);
            border-radius: 16px 16px 0 0;
            padding: 16px 16px 0 16px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.5), inset 0 0 0 2px rgba(255,255,255,0.1);
            position: relative;
        }

        .device-frame-laptop::after {
            content: '';
            position: absolute;
            bottom: -20px;
            left: -40px;
            right: -40px;
            height: 20px;
            background: linear-gradient(145deg, #252540, #1e1e35);
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .device-frame-tablet {
            width: 500px;
            max-width: 85vw;
            height: auto;
            aspect-ratio: 4/3;
            background: linear-gradient(145deg, #1a1a2e, #16162a);
            border-radius: 24px;
            padding: 20px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.5), inset 0 0 0 2px rgba(255,255,255,0.1);
        }

        .device-screen {
            width: 100%;
            height: 100%;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .device-frame-mobile .device-screen {
            border-radius: 28px;
            height: calc(100% - 8px);
            margin-top: 20px;
        }

        /* Mobile Responsive - Bottom Sheet */
        @media (max-width: 768px) {
            .device-preview-overlay {
                align-items: flex-end;
            }

            .device-preview-modal {
                width: 100%;
                max-width: 100%;
                max-height: 85vh;
                animation: devicePreviewMobileSlide 0.3s ease-out;
                background: linear-gradient(180deg, #1a1a2e, #0f0f1a);
                border-radius: 24px 24px 0 0;
                padding: 1rem;
                padding-bottom: env(safe-area-inset-bottom, 1rem);
            }

            .device-preview-modal::before {
                content: '';
                position: absolute;
                top: 8px;
                left: 50%;
                transform: translateX(-50%);
                width: 40px;
                height: 4px;
                background: rgba(255,255,255,0.3);
                border-radius: 2px;
            }

            .device-frame-mobile,
            .device-frame-laptop,
            .device-frame-tablet {
                width: 100%;
                max-width: 100%;
                height: auto;
                padding: 8px;
                border-radius: 12px;
            }

            .device-frame-laptop::after {
                display: none;
            }
        }

        .device-selector-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 2px solid transparent;
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            transition: all 0.2s ease;
        }

        .device-selector-btn:hover {
            background: rgba(139,92,246,0.2);
            color: white;
        }

        .device-selector-btn.active {
            border-color: #8b5cf6;
            background: rgba(139,92,246,0.2);
            color: #a78bfa;
        }

        /* Floating Preview (Picture-in-Picture) Styles */
        @keyframes floatPreviewSlideIn {
            from { opacity: 0; transform: scale(0.8) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .floating-preview-container {
            position: fixed;
            z-index: 1000;
            width: 320px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 0 1px rgba(139,92,246,0.3);
            animation: floatPreviewSlideIn 0.25s ease-out;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .floating-preview-container.minimized {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
        }

        .floating-preview-container.top-left { top: 1rem; left: 1rem; }
        .floating-preview-container.top-right { top: 1rem; right: 1rem; }
        .floating-preview-container.bottom-left { bottom: 1rem; left: 1rem; }
        .floating-preview-container.bottom-right { bottom: 1rem; right: 1rem; }

        .floating-preview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            cursor: grab;
        }

        .floating-preview-header:active {
            cursor: grabbing;
        }

        .floating-preview-content {
            aspect-ratio: 16/9;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        .floating-preview-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: rgba(0,0,0,0.2);
        }

        .floating-preview-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            transition: all 0.15s;
        }

        .floating-preview-btn:hover {
            background: rgba(139,92,246,0.3);
            color: white;
        }

        .floating-preview-position-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            padding: 0.5rem;
            background: rgba(0,0,0,0.3);
        }

        .floating-preview-position-btn {
            padding: 0.25rem;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.5);
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .floating-preview-position-btn:hover {
            background: rgba(139,92,246,0.2);
            border-color: rgba(139,92,246,0.3);
            color: white;
        }

        .floating-preview-position-btn.active {
            background: rgba(139,92,246,0.3);
            border-color: #8b5cf6;
            color: #a78bfa;
        }

        .fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }

        .animate-spin {
            animation: spin 1s linear infinite;
        }

        .animate-pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        /* Animation Studio Pro 2.0 - Hover Effects */
        .scene-card-hover:hover {
            background: rgba(139,92,246,0.15) !important;
            border-color: rgba(139,92,246,0.4) !important;
        }

        .scene-card-hover:hover .hover-actions {
            display: flex !important;
        }

        .scene-card-hover:active {
            cursor: grabbing;
        }

        .animate-float {
            animation: float 3s ease-in-out infinite;
        }

        .animate-glow {
            animation: glow 2s ease-in-out infinite;
        }

        .scale-in {
            animation: scaleIn 0.3s ease-out forwards;
        }

        /* ------------------------------------------
           2.3 WIZARD LAYOUT
           ------------------------------------------ */
        .wizard-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            min-height: 100vh;
        }

        .wizard-header {
            text-align: center;
            padding: 1.5rem 1rem;
            margin-bottom: 1rem;
        }

        .wizard-title {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 50%, #10b981 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .wizard-subtitle {
            color: rgba(255, 255, 255, 0.6);
            font-size: 1rem;
        }

        /* ------------------------------------------
           2.4 STEPPER
           ------------------------------------------ */
        .wizard-stepper {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.25rem;
            padding: 1rem 0.5rem;
            margin-bottom: 2rem;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .wizard-stepper::-webkit-scrollbar {
            display: none;
        }

        .wizard-step {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.6rem 1rem;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .wizard-step:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .wizard-step.active {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(6, 182, 212, 0.2) 100%);
            border-color: rgba(139, 92, 246, 0.5);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.2);
        }

        .wizard-step.completed {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .wizard-step.completed .step-number {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .step-number {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            flex-shrink: 0;
        }

        .wizard-step.active .step-number {
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
        }

        .step-label {
            font-size: 0.8rem;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.7);
        }

        .wizard-step.active .step-label {
            color: white;
        }

        /* Step connector line */
        .step-connector {
            width: 20px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .step-connector.completed {
            background: rgba(16, 185, 129, 0.5);
        }

        /* ------------------------------------------
           2.5 CONTENT CARDS
           ------------------------------------------ */
        .content-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 1.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .content-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .content-card-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(6, 182, 212, 0.2) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .content-card-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: white;
        }

        .content-card-subtitle {
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ------------------------------------------
           2.6 PLATFORM CARDS
           ------------------------------------------ */
        .platform-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 1rem;
        }

        .platform-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            padding: 1.25rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .platform-card:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .platform-card.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(6, 182, 212, 0.15) 100%);
            border-color: rgba(139, 92, 246, 0.6);
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.2);
        }

        .platform-card-icon {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
        }

        .platform-card-name {
            font-size: 1rem;
            font-weight: 600;
            color: white;
            margin-bottom: 0.25rem;
        }

        .platform-card-info {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ------------------------------------------
           2.7 FORMAT SELECTOR
           ------------------------------------------ */
        .format-selector {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .format-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 1.5rem;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .format-option:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .format-option.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(6, 182, 212, 0.15) 100%);
            border-color: rgba(139, 92, 246, 0.6);
        }

        .format-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .format-preview {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .format-preview-box {
            background: rgba(139, 92, 246, 0.3);
            border: 2px solid rgba(139, 92, 246, 0.6);
            border-radius: 4px;
        }

        .format-preview-box.ratio-16-9 {
            width: 64px;
            height: 36px;
        }

        .format-preview-box.ratio-9-16 {
            width: 36px;
            height: 64px;
        }

        .format-preview-box.ratio-1-1 {
            width: 48px;
            height: 48px;
        }

        .format-preview-box.ratio-4-5 {
            width: 40px;
            height: 50px;
        }

        .format-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: white;
        }

        .format-desc {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ------------------------------------------
           2.8 DURATION SLIDER
           ------------------------------------------ */
        .duration-container {
            margin-top: 1.5rem;
        }

        .duration-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .duration-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        .duration-value {
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .duration-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .duration-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
            transition: transform 0.2s ease;
        }

        .duration-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .duration-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
        }

        .duration-presets {
            display: flex;
            justify-content: space-between;
            margin-top: 0.75rem;
        }

        .duration-preset {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .duration-preset:hover {
            color: rgba(255, 255, 255, 0.8);
        }

        /* ------------------------------------------
           2.9 NICHE GRID
           ------------------------------------------ */
        .niche-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 0.75rem;
        }

        .niche-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .niche-card:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .niche-card.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(6, 182, 212, 0.15) 100%);
            border-color: rgba(139, 92, 246, 0.6);
        }

        .niche-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .niche-name {
            font-size: 0.875rem;
            font-weight: 600;
            color: white;
        }

        /* Sub-niche chips */
        .subniche-container {
            margin-top: 1.5rem;
        }

        .subniche-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .subniche-chip {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .subniche-chip:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .subniche-chip.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3) 0%, rgba(6, 182, 212, 0.3) 100%);
            border-color: rgba(139, 92, 246, 0.5);
            color: white;
        }

        /* ------------------------------------------
           2.10 STYLE GRID
           ------------------------------------------ */
        .style-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }

        .style-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            padding: 1.25rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .style-card:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .style-card.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(6, 182, 212, 0.15) 100%);
            border-color: rgba(139, 92, 246, 0.6);
        }

        .style-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .style-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
            margin-bottom: 0.25rem;
        }

        .style-desc {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.3;
        }

        /* ------------------------------------------
           2.11 TOPIC INPUT
           ------------------------------------------ */
        .topic-input-container {
            margin-top: 1.5rem;
        }

        .topic-input {
            width: 100%;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            color: white;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .topic-input:focus {
            border-color: rgba(139, 92, 246, 0.5);
            background: rgba(255, 255, 255, 0.08);
        }

        .topic-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .topic-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .topic-suggestion {
            padding: 0.4rem 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .topic-suggestion:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.4);
            color: white;
        }

        /* ------------------------------------------
           2.12 CONFIG TAGS
           ------------------------------------------ */
        .config-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.35rem 0.65rem;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 0.5rem;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        /* ------------------------------------------
           2.13 NAVIGATION BUTTONS
           ------------------------------------------ */
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }

        .nav-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.875rem 1.5rem;
            border-radius: 1rem;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .nav-button-back {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }

        .nav-button-back:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .nav-button-next {
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
        }

        .nav-button-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
        }

        .nav-button-next:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* ------------------------------------------
           2.13 TOKEN DISPLAY
           ------------------------------------------ */
        .token-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2rem;
            font-size: 0.85rem;
        }

        .token-icon {
            font-size: 1rem;
        }

        .token-count {
            font-weight: 700;
            background: linear-gradient(135deg, #f59e0b 0%, #eab308 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* ------------------------------------------
           2.14 HEADER BAR
           ------------------------------------------ */
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .back-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: rgba(255, 255, 255, 0.6);
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: white;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* ------------------------------------------
           2.15 LOADING STATE
           ------------------------------------------ */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 15, 26, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(139, 92, 246, 0.2);
            border-top-color: #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            margin-top: 1.5rem;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
        }

        /* ------------------------------------------
           2.16 COST ESTIMATE PANEL
           ------------------------------------------ */
        .cost-estimate {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 1rem;
            padding: 1rem 1.25rem;
            margin-top: 1.5rem;
        }

        .cost-estimate-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .cost-estimate-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        .cost-estimate-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: #8b5cf6;
        }

        .cost-estimate-breakdown {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ------------------------------------------
           2.17 RESPONSIVE ADJUSTMENTS
           ------------------------------------------ */
        @media (max-width: 768px) {
            .wizard-container {
                padding: 0.5rem;
            }

            .wizard-title {
                font-size: 1.5rem;
            }

            .wizard-stepper {
                justify-content: flex-start;
                padding: 0.75rem;
            }

            .wizard-step {
                padding: 0.5rem 0.75rem;
            }

            .step-label {
                display: none;
            }

            .content-card {
                padding: 1.25rem;
            }

            .platform-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .niche-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .style-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .format-selector {
                flex-direction: column;
                align-items: center;
            }

            .nav-buttons {
                flex-direction: column;
                gap: 1rem;
            }

            .nav-button {
                width: 100%;
                justify-content: center;
            }
        }

        /* NOTE: Caption styles are now rendered directly on canvas by VideoPreviewEngine
           See _renderKaraokeStyle, _renderBeastyStyle, _renderHormoziStyle, etc.
           This provides synchronized word-by-word captions matching the export ASS styles */
    </style>
</head>
<body>
    <!-- ============================================
         SECTION 3: HTML CONTAINER
         ============================================ -->
    <div id="app-root">
        <!-- Content rendered by JavaScript -->
        <div class="loading-overlay" id="initial-loading">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Authenticating...</div>
        </div>
    </div>

    <!-- ============================================
         SECTION 4: CONFIGURATION DATA
         ============================================ -->
    <script>
        // ==========================================
        // 4.1 PLATFORM PRESETS
        // ==========================================
        const PLATFORM_PRESETS = {
            'youtube-long': {
                id: 'youtube-long',
                name: 'YouTube Long-form',
                icon: '',
                formats: ['16:9'],
                defaultFormat: '16:9',
                resolution: { width: 1920, height: 1080 },
                maxDuration: 300,
                minDuration: 60,
                fps: 30,
                bitrate: '8M',
                description: 'Standard videos up to 5 min'
            },
            'youtube-shorts': {
                id: 'youtube-shorts',
                name: 'YouTube Shorts',
                icon: '',
                formats: ['9:16'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 60,
                minDuration: 15,
                fps: 30,
                bitrate: '4M',
                description: 'Vertical shorts up to 60s'
            },
            'tiktok': {
                id: 'tiktok',
                name: 'TikTok',
                icon: '',
                formats: ['9:16', '16:9', '1:1'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 180,
                minDuration: 15,
                fps: 30,
                bitrate: '4M',
                description: 'Viral content up to 3 min'
            },
            'instagram-reels': {
                id: 'instagram-reels',
                name: 'Instagram Reels',
                icon: '',
                formats: ['9:16'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 180,
                minDuration: 15,
                fps: 30,
                bitrate: '4M',
                description: 'Reels up to 3 min'
            },
            'instagram-feed': {
                id: 'instagram-feed',
                name: 'Instagram Feed',
                icon: '',
                formats: ['1:1', '4:5', '16:9'],
                defaultFormat: '1:1',
                resolution: { width: 1080, height: 1080 },
                maxDuration: 60,
                minDuration: 3,
                fps: 30,
                bitrate: '4M',
                description: 'Feed videos up to 60s'
            },
            'facebook-reels': {
                id: 'facebook-reels',
                name: 'Facebook Reels',
                icon: '',
                formats: ['9:16'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 90,
                minDuration: 3,
                fps: 30,
                bitrate: '4M',
                description: 'Reels up to 90s'
            },
            'facebook-feed': {
                id: 'facebook-feed',
                name: 'Facebook Feed',
                icon: '',
                formats: ['16:9', '1:1', '9:16'],
                defaultFormat: '16:9',
                resolution: { width: 1920, height: 1080 },
                maxDuration: 300,
                minDuration: 3,
                fps: 30,
                bitrate: '6M',
                description: 'Feed videos up to 5 min'
            },
            'linkedin': {
                id: 'linkedin',
                name: 'LinkedIn',
                icon: '',
                formats: ['16:9', '1:1', '4:5'],
                defaultFormat: '4:5',
                resolution: { width: 1080, height: 1350 },
                maxDuration: 300,
                minDuration: 3,
                fps: 30,
                bitrate: '5M',
                description: 'Professional videos up to 5 min'
            },
            'multi-platform': {
                id: 'multi-platform',
                name: 'Multi-Platform',
                icon: '',
                formats: ['9:16', '16:9', '1:1'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 60,
                minDuration: 15,
                fps: 30,
                bitrate: '4M',
                description: 'Optimized for all platforms'
            }
        };

        // ==========================================
        // 4.1B PRODUCTION TYPES (New Wizard Architecture)
        // Hollywood-Grade Production Type System
        // ==========================================
        const PRODUCTION_TYPES = {
            'social': {
                id: 'social',
                name: 'Social Content',
                icon: '',
                description: 'Short-form content for social platforms',
                subTypes: {
                    'viral': {
                        id: 'viral',
                        name: 'Viral/Trending',
                        icon: '',
                        description: 'Quick hook, shareable content',
                        characteristics: ['quick-hook', 'shareable', 'trend-based'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 15, max: 60 }
                    },
                    'educational-short': {
                        id: 'educational-short',
                        name: 'Quick Explainer',
                        icon: '',
                        description: 'Informative, concise explanations',
                        characteristics: ['informative', 'concise', 'visual'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 30, max: 180 }
                    },
                    'story-short': {
                        id: 'story-short',
                        name: 'Story Snippet',
                        icon: '',
                        description: 'Narrative hooks, cliffhangers',
                        characteristics: ['narrative', 'cliffhanger', 'emotional'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 30, max: 120 }
                    },
                    'product': {
                        id: 'product',
                        name: 'Product Showcase',
                        icon: '',
                        description: 'Product features, promotions',
                        characteristics: ['promotional', 'visual', 'persuasive'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 15, max: 60 }
                    },
                    'lifestyle': {
                        id: 'lifestyle',
                        name: 'Lifestyle/Vlog',
                        icon: '',
                        description: 'Personal, relatable content',
                        characteristics: ['personal', 'relatable', 'authentic'],
                        defaultNarration: 'first-person',
                        suggestedDuration: { min: 60, max: 180 }
                    },
                    'meme-comedy': {
                        id: 'meme-comedy',
                        name: 'Meme/Comedy',
                        icon: '',
                        description: 'Humorous, reference-heavy content',
                        characteristics: ['humorous', 'reference-heavy', 'quick'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 15, max: 60 }
                    }
                },
                defaultNarration: 'voiceover',
                defaultDuration: { min: 15, max: 180 },
                characterNeeds: { min: 0, max: 2, suggested: 0 }
            },

            'movie': {
                id: 'movie',
                name: 'Movie/Film',
                icon: '',
                description: 'Cinematic narrative storytelling',
                subTypes: {
                    'action': {
                        id: 'action',
                        name: 'Action',
                        icon: '',
                        description: 'High-octane, physical, thrilling',
                        visualStyle: 'high-contrast, dynamic angles, kinetic energy',
                        references: ['John Wick', 'Mad Max', 'Mission Impossible'],
                        characteristics: ['fast-paced', 'physical', 'high-stakes'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 120, max: 600 }
                    },
                    'drama': {
                        id: 'drama',
                        name: 'Drama',
                        icon: '',
                        description: 'Character-driven, emotional storytelling',
                        visualStyle: 'intimate framing, natural lighting, emotive',
                        references: ['Manchester by the Sea', 'Marriage Story', 'Moonlight'],
                        characteristics: ['emotional', 'character-driven', 'dialogue-heavy'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 120, max: 600 }
                    },
                    'thriller': {
                        id: 'thriller',
                        name: 'Thriller/Suspense',
                        icon: '',
                        description: 'Tension, mystery, psychological depth',
                        visualStyle: 'shadows, tension-building, paranoia, tight framing',
                        references: ['Gone Girl', 'Prisoners', 'Se7en', 'Zodiac'],
                        characteristics: ['tense', 'mystery', 'psychological', 'twists'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 120, max: 600 }
                    },
                    'horror': {
                        id: 'horror',
                        name: 'Horror',
                        icon: '',
                        description: 'Fear, dread, supernatural or psychological terror',
                        visualStyle: 'darkness, negative space, unsettling angles, shadows',
                        references: ['Hereditary', 'The Conjuring', 'Get Out', 'A Quiet Place'],
                        characteristics: ['scary', 'atmospheric', 'dread', 'suspense'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 90, max: 600 }
                    },
                    'scifi': {
                        id: 'scifi',
                        name: 'Sci-Fi',
                        icon: '',
                        description: 'Futuristic, speculative, technological',
                        visualStyle: 'futuristic, high-tech, otherworldly, sleek',
                        references: ['Blade Runner 2049', 'Arrival', 'Interstellar', 'Ex Machina'],
                        characteristics: ['speculative', 'technology', 'wonder', 'philosophical'],
                        defaultNarration: 'dialogue',
                        allowedCharacterTypes: ['human', 'robot', 'alien', 'ai', 'cyborg'],
                        suggestedDuration: { min: 120, max: 600 }
                    },
                    'fantasy': {
                        id: 'fantasy',
                        name: 'Fantasy',
                        icon: '',
                        description: 'Magical worlds, epic quests, mythical beings',
                        visualStyle: 'magical, epic scale, mythical, rich colors',
                        references: ['Lord of the Rings', 'Pan\'s Labyrinth', 'The Princess Bride'],
                        characteristics: ['magical', 'world-building', 'epic', 'adventure'],
                        defaultNarration: 'dialogue',
                        allowedCharacterTypes: ['human', 'creature', 'magical-being', 'elf', 'dwarf', 'wizard'],
                        suggestedDuration: { min: 120, max: 600 }
                    },
                    'comedy': {
                        id: 'comedy',
                        name: 'Comedy',
                        icon: '',
                        description: 'Humor, wit, comedic timing',
                        visualStyle: 'bright, expressive, comedic timing, dynamic',
                        references: ['The Grand Budapest Hotel', 'Superbad', 'Bridesmaids'],
                        characteristics: ['funny', 'timing', 'absurd', 'character-comedy'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 90, max: 600 }
                    },
                    'romance': {
                        id: 'romance',
                        name: 'Romance',
                        icon: '',
                        description: 'Love stories, emotional connections',
                        visualStyle: 'soft lighting, intimate, warm tones, dreamy',
                        references: ['La La Land', 'The Notebook', 'Before Sunrise'],
                        characteristics: ['love', 'emotional', 'relationships', 'intimate'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 120, max: 600 }
                    },
                    'animation': {
                        id: 'animation',
                        name: 'Animation',
                        icon: '',
                        description: 'Animated storytelling in various styles',
                        visualStyle: 'varies by animation style',
                        references: ['Pixar', 'Studio Ghibli', 'Spider-Verse'],
                        characteristics: ['animated', 'stylized', 'creative', 'unlimited'],
                        subStyles: ['3D Pixar-style', '2D Anime', 'Stop Motion', 'Stylized 2D', 'Abstract'],
                        defaultNarration: 'dialogue',
                        allowedCharacterTypes: ['human', 'animal', 'object', 'abstract', 'creature', 'anything'],
                        suggestedDuration: { min: 60, max: 600 }
                    },
                    'documentary': {
                        id: 'documentary',
                        name: 'Documentary',
                        icon: '',
                        description: 'Real stories, informative, observational',
                        visualStyle: 'authentic, observational, informative, natural',
                        references: ['Planet Earth', 'The Social Dilemma', 'Free Solo'],
                        characteristics: ['real', 'informative', 'journalistic', 'authentic'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 180, max: 600 }
                    },
                    'western': {
                        id: 'western',
                        name: 'Western',
                        icon: '',
                        description: 'Frontier stories, moral complexity',
                        visualStyle: 'wide landscapes, dust, golden hour, desaturated',
                        references: ['No Country for Old Men', 'True Grit', 'The Good The Bad The Ugly'],
                        characteristics: ['frontier', 'moral', 'landscapes', 'showdowns'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 120, max: 600 }
                    },
                    'noir': {
                        id: 'noir',
                        name: 'Film Noir',
                        icon: '',
                        description: 'Dark, cynical, mystery-driven',
                        visualStyle: 'high contrast, deep shadows, rain, smoke, neon',
                        references: ['Sin City', 'Chinatown', 'Blade Runner', 'L.A. Confidential'],
                        characteristics: ['dark', 'cynical', 'mystery', 'femme-fatale'],
                        defaultNarration: 'voiceover-protagonist',
                        suggestedDuration: { min: 120, max: 600 }
                    }
                },
                defaultNarration: 'dialogue',
                defaultDuration: { min: 120, max: 3600 },
                characterNeeds: { min: 2, max: 10, suggested: 4 }
            },

            'series': {
                id: 'series',
                name: 'Series/Episodes',
                icon: '',
                description: 'Episodic storytelling with story arcs',
                episodeConfig: true,
                subTypes: {
                    'crime-drama': {
                        id: 'crime-drama',
                        name: 'Crime/Drama',
                        icon: '',
                        description: 'Gritty crime stories, complex characters',
                        visualStyle: 'gritty, realistic, moody, desaturated with accent colors',
                        references: ['Breaking Bad', 'The Wire', 'True Detective', 'Ozark'],
                        characteristics: ['serialized', 'complex-characters', 'moral-gray', 'tension'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 300, max: 3600 }
                    },
                    'fantasy-epic': {
                        id: 'fantasy-epic',
                        name: 'Fantasy Epic',
                        icon: '',
                        description: 'Epic fantasy with rich world-building',
                        visualStyle: 'epic scale, detailed worlds, magical, cinematic',
                        references: ['Game of Thrones', 'The Witcher', 'House of the Dragon'],
                        characteristics: ['world-building', 'political', 'epic', 'multiple-storylines'],
                        defaultNarration: 'dialogue',
                        allowedCharacterTypes: ['human', 'creature', 'dragon', 'wizard', 'undead'],
                        suggestedDuration: { min: 300, max: 3600 }
                    },
                    'scifi-series': {
                        id: 'scifi-series',
                        name: 'Sci-Fi Series',
                        icon: '',
                        description: 'Futuristic stories, often philosophical',
                        visualStyle: 'futuristic, sleek, mysterious, high-tech',
                        references: ['Black Mirror', 'Westworld', 'The Expanse', 'Severance'],
                        characteristics: ['speculative', 'technological', 'philosophical', 'dystopian'],
                        defaultNarration: 'dialogue',
                        allowedCharacterTypes: ['human', 'robot', 'ai', 'alien', 'clone'],
                        suggestedDuration: { min: 300, max: 3600 }
                    },
                    'thriller-series': {
                        id: 'thriller-series',
                        name: 'Thriller Series',
                        icon: '',
                        description: 'Suspenseful serialized stories',
                        visualStyle: 'moody, tense, shadowy, paranoid',
                        references: ['Mindhunter', 'You', 'The Sinner', 'Sharp Objects'],
                        characteristics: ['suspense', 'cliffhangers', 'psychological', 'twists'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 300, max: 3600 }
                    },
                    'comedy-series': {
                        id: 'comedy-series',
                        name: 'Comedy Series',
                        icon: '',
                        description: 'Sitcom or single-camera comedy',
                        visualStyle: 'bright, warm, comedic timing, expressive',
                        references: ['The Office', 'Brooklyn Nine-Nine', 'Ted Lasso', 'Schitt\'s Creek'],
                        characteristics: ['episodic', 'character-comedy', 'recurring-jokes', 'ensemble'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 180, max: 1800 }
                    },
                    'anthology': {
                        id: 'anthology',
                        name: 'Anthology',
                        icon: '',
                        description: 'Standalone episodes with thematic connection',
                        visualStyle: 'varies per episode, thematically linked',
                        references: ['Black Mirror', 'American Horror Story', 'Love Death Robots'],
                        characteristics: ['standalone', 'thematic', 'varied', 'experimental'],
                        defaultNarration: 'mixed',
                        allowedCharacterTypes: ['any'],
                        suggestedDuration: { min: 180, max: 3600 }
                    },
                    'limited-series': {
                        id: 'limited-series',
                        name: 'Limited Series',
                        icon: '',
                        description: 'Complete story in limited episodes',
                        visualStyle: 'cinematic, film-like, premium',
                        references: ['Chernobyl', 'Band of Brothers', 'The Queen\'s Gambit'],
                        characteristics: ['finite', 'focused', 'complete-arc', 'prestige'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 300, max: 3600 }
                    },
                    'anime': {
                        id: 'anime',
                        name: 'Anime',
                        icon: '',
                        description: 'Japanese-style animated series',
                        visualStyle: 'anime aesthetics, expressive, stylized',
                        references: ['Attack on Titan', 'Death Note', 'Demon Slayer', 'Cowboy Bebop'],
                        characteristics: ['animated', 'japanese-style', 'expressive', 'action'],
                        subStyles: ['Shonen', 'Seinen', 'Slice of Life', 'Mecha', 'Isekai'],
                        defaultNarration: 'dialogue',
                        allowedCharacterTypes: ['human', 'demon', 'mecha', 'spirit', 'monster'],
                        suggestedDuration: { min: 180, max: 1800 }
                    },
                    'docuseries': {
                        id: 'docuseries',
                        name: 'Docuseries',
                        icon: '',
                        description: 'Documentary with serialized narrative',
                        visualStyle: 'documentary with narrative arc, real footage style',
                        references: ['Making a Murderer', 'Tiger King', 'The Last Dance'],
                        characteristics: ['real-events', 'investigative', 'serialized', 'interviews'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 300, max: 3600 }
                    }
                },
                defaultNarration: 'dialogue',
                defaultDuration: { min: 300, max: 3600 },
                characterNeeds: { min: 3, max: 15, suggested: 6 }
            },

            'educational': {
                id: 'educational',
                name: 'Educational',
                icon: '',
                description: 'Learning and informative content',
                subTypes: {
                    'explainer': {
                        id: 'explainer',
                        name: 'Explainer',
                        icon: '',
                        description: 'Complex topics made simple',
                        visualStyle: 'clean, clear, illustrative, motion graphics',
                        references: ['Kurzgesagt', 'Vox', 'TED-Ed', 'Veritasium'],
                        characteristics: ['informative', 'visual-aids', 'accessible', 'engaging'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 60, max: 900 }
                    },
                    'tutorial': {
                        id: 'tutorial',
                        name: 'Tutorial/How-To',
                        icon: '',
                        description: 'Step-by-step instructional content',
                        visualStyle: 'step-by-step, clear visuals, demonstrations',
                        characteristics: ['instructional', 'practical', 'step-by-step', 'hands-on'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 120, max: 1200 }
                    },
                    'documentary-edu': {
                        id: 'documentary-edu',
                        name: 'Documentary',
                        icon: '',
                        description: 'In-depth exploration of topics',
                        visualStyle: 'cinematic documentary, immersive',
                        references: ['Planet Earth', 'Cosmos', 'Our Planet'],
                        characteristics: ['informative', 'immersive', 'narrative', 'beautiful'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 300, max: 3600 }
                    },
                    'history': {
                        id: 'history',
                        name: 'History/Timeline',
                        icon: '',
                        description: 'Historical events and timelines',
                        visualStyle: 'archival, recreations, maps, period-accurate',
                        characteristics: ['historical', 'chronological', 'contextual', 'narrative'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 180, max: 1800 }
                    },
                    'science': {
                        id: 'science',
                        name: 'Science',
                        icon: '',
                        description: 'Scientific concepts and discoveries',
                        visualStyle: 'diagrams, animations, demonstrations, data visualization',
                        references: ['Veritasium', 'SmarterEveryDay', 'MinutePhysics'],
                        characteristics: ['scientific', 'visual-explanation', 'data', 'experiments'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 120, max: 1200 }
                    },
                    'course': {
                        id: 'course',
                        name: 'Course/Lesson',
                        icon: '',
                        description: 'Structured educational content',
                        visualStyle: 'structured, academic, professional',
                        characteristics: ['structured', 'progressive', 'comprehensive', 'modular'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 300, max: 3600 }
                    }
                },
                defaultNarration: 'voiceover',
                defaultDuration: { min: 60, max: 1800 },
                characterNeeds: { min: 0, max: 3, suggested: 0 }
            },

            'music-video': {
                id: 'music-video',
                name: 'Music Video',
                icon: '',
                description: 'Visual accompaniment to music',
                syncToMusic: true,
                subTypes: {
                    'performance': {
                        id: 'performance',
                        name: 'Performance',
                        icon: '',
                        description: 'Artist/band performing',
                        visualStyle: 'concert-like, energetic, artist-focused',
                        characteristics: ['live-feel', 'energetic', 'artist-focused', 'dynamic'],
                        defaultNarration: 'none',
                        suggestedDuration: { min: 120, max: 420 }
                    },
                    'narrative-mv': {
                        id: 'narrative-mv',
                        name: 'Narrative',
                        icon: '',
                        description: 'Story-driven music video',
                        visualStyle: 'story-driven, cinematic, emotional',
                        references: ['Thriller (Michael Jackson)', 'This Is America', 'Bad Guy'],
                        characteristics: ['story', 'cinematic', 'conceptual', 'emotional'],
                        defaultNarration: 'none',
                        suggestedDuration: { min: 180, max: 420 }
                    },
                    'visual-art': {
                        id: 'visual-art',
                        name: 'Visual Art',
                        icon: '',
                        description: 'Abstract, artistic, experimental',
                        visualStyle: 'abstract, artistic, experimental, mood-driven',
                        characteristics: ['artistic', 'abstract', 'mood-driven', 'experimental'],
                        defaultNarration: 'none',
                        suggestedDuration: { min: 120, max: 420 }
                    },
                    'lyric-video': {
                        id: 'lyric-video',
                        name: 'Lyric Video',
                        icon: '',
                        description: 'Typography and motion graphics',
                        visualStyle: 'typography, motion graphics, kinetic text',
                        characteristics: ['text-focused', 'animated', 'simple', 'readable'],
                        defaultNarration: 'none',
                        suggestedDuration: { min: 120, max: 420 }
                    },
                    'animation-mv': {
                        id: 'animation-mv',
                        name: 'Animated',
                        icon: '',
                        description: 'Fully animated music video',
                        visualStyle: 'animated, any style, creative freedom',
                        characteristics: ['animated', 'creative', 'unlimited', 'stylized'],
                        defaultNarration: 'none',
                        allowedCharacterTypes: ['anything'],
                        suggestedDuration: { min: 120, max: 420 }
                    }
                },
                defaultNarration: 'none',
                defaultDuration: { min: 120, max: 420 },
                characterNeeds: { min: 0, max: 5, suggested: 1 }
            },

            'commercial': {
                id: 'commercial',
                name: 'Commercial/Promo',
                icon: '',
                description: 'Promotional and advertising content',
                subTypes: {
                    'brand-story': {
                        id: 'brand-story',
                        name: 'Brand Story',
                        icon: '',
                        description: 'Company/brand narrative',
                        visualStyle: 'polished, aspirational, branded',
                        characteristics: ['emotional', 'brand-focused', 'inspiring', 'values'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 30, max: 180 }
                    },
                    'product-launch': {
                        id: 'product-launch',
                        name: 'Product Launch',
                        icon: '',
                        description: 'New product introduction',
                        visualStyle: 'sleek, product-focused, modern',
                        characteristics: ['product-focused', 'features', 'exciting', 'aspirational'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 15, max: 120 }
                    },
                    'testimonial': {
                        id: 'testimonial',
                        name: 'Testimonial',
                        icon: '',
                        description: 'Customer stories and reviews',
                        visualStyle: 'authentic, personal, trustworthy',
                        characteristics: ['authentic', 'personal', 'trustworthy', 'relatable'],
                        defaultNarration: 'dialogue',
                        suggestedDuration: { min: 30, max: 120 }
                    },
                    'announcement': {
                        id: 'announcement',
                        name: 'Announcement',
                        icon: '',
                        description: 'News, updates, reveals',
                        visualStyle: 'exciting, news-like, urgent',
                        characteristics: ['urgent', 'exciting', 'news', 'impactful'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 15, max: 60 }
                    },
                    'event-promo': {
                        id: 'event-promo',
                        name: 'Event Promo',
                        icon: '',
                        description: 'Event promotion and hype',
                        visualStyle: 'energetic, exciting, countdown feel',
                        characteristics: ['exciting', 'countdown', 'hype', 'call-to-action'],
                        defaultNarration: 'voiceover',
                        suggestedDuration: { min: 15, max: 90 }
                    }
                },
                defaultNarration: 'voiceover',
                defaultDuration: { min: 15, max: 180 },
                characterNeeds: { min: 0, max: 3, suggested: 0 }
            }
        };

        // ==========================================
        // 4.1C FORMAT PRESETS (Simplified from Platform)
        // ==========================================
        const FORMAT_PRESETS = {
            'widescreen': {
                id: 'widescreen',
                name: 'Widescreen',
                icon: '',
                aspectRatio: '16:9',
                description: 'YouTube, TV, Movies',
                resolution: { width: 1920, height: 1080 },
                resolution4k: { width: 3840, height: 2160 }
            },
            'vertical': {
                id: 'vertical',
                name: 'Vertical',
                icon: '',
                aspectRatio: '9:16',
                description: 'TikTok, Reels, Shorts',
                resolution: { width: 1080, height: 1920 },
                resolution4k: { width: 2160, height: 3840 }
            },
            'square': {
                id: 'square',
                name: 'Square',
                icon: '',
                aspectRatio: '1:1',
                description: 'Instagram Feed',
                resolution: { width: 1080, height: 1080 },
                resolution4k: { width: 2160, height: 2160 }
            },
            'tall': {
                id: 'tall',
                name: 'Tall',
                icon: '',
                aspectRatio: '4:5',
                description: 'Instagram Portrait',
                resolution: { width: 1080, height: 1350 },
                resolution4k: { width: 2160, height: 2700 }
            }
        };

        // ==========================================
        // 4.2 VIDEO NICHES (Legacy - keeping for backwards compatibility)
        const VIDEO_NICHES = {
            entertainment: {
                id: 'entertainment',
                name: 'Entertainment',
                icon: '',
                subniches: [
                    { id: 'comedy', name: 'Comedy & Humor' },
                    { id: 'stories', name: 'Story Time' },
                    { id: 'reactions', name: 'Reactions' },
                    { id: 'celebrity', name: 'Pop Culture' },
                    { id: 'true-crime', name: 'True Crime' }
                ]
            },
            education: {
                id: 'education',
                name: 'Education',
                icon: '',
                subniches: [
                    { id: 'explainer', name: 'Explainer Videos' },
                    { id: 'tutorials', name: 'Tutorials' },
                    { id: 'science', name: 'Science & Tech' },
                    { id: 'history', name: 'History' },
                    { id: 'language', name: 'Language Learning' }
                ]
            },
            business: {
                id: 'business',
                name: 'Business',
                icon: '',
                subniches: [
                    { id: 'investing', name: 'Investing' },
                    { id: 'entrepreneurship', name: 'Entrepreneurship' },
                    { id: 'productivity', name: 'Productivity' },
                    { id: 'career', name: 'Career Tips' },
                    { id: 'money-tips', name: 'Money Tips' }
                ]
            },
            health: {
                id: 'health',
                name: 'Health',
                icon: '',
                subniches: [
                    { id: 'fitness', name: 'Fitness' },
                    { id: 'nutrition', name: 'Nutrition' },
                    { id: 'mental-health', name: 'Mental Health' },
                    { id: 'meditation', name: 'Meditation' },
                    { id: 'self-improvement', name: 'Self Improvement' }
                ]
            },
            technology: {
                id: 'technology',
                name: 'Technology',
                icon: '',
                subniches: [
                    { id: 'tech-reviews', name: 'Tech Reviews' },
                    { id: 'ai-tech', name: 'AI & Future Tech' },
                    { id: 'coding', name: 'Coding' },
                    { id: 'gadgets', name: 'Gadgets' },
                    { id: 'gaming-tech', name: 'Gaming' }
                ]
            },
            creative: {
                id: 'creative',
                name: 'Creative',
                icon: '',
                subniches: [
                    { id: 'art-tutorials', name: 'Art Tutorials' },
                    { id: 'music', name: 'Music' },
                    { id: 'photography', name: 'Photography' },
                    { id: 'diy-crafts', name: 'DIY & Crafts' },
                    { id: 'animation', name: 'Animation' }
                ]
            },
            travel: {
                id: 'travel',
                name: 'Travel',
                icon: '',
                subniches: [
                    { id: 'travel-guides', name: 'Travel Guides' },
                    { id: 'food-travel', name: 'Food & Cuisine' },
                    { id: 'luxury', name: 'Luxury' },
                    { id: 'minimalism', name: 'Minimalism' },
                    { id: 'adventure', name: 'Adventure' }
                ]
            },
            motivation: {
                id: 'motivation',
                name: 'Motivation',
                icon: '',
                subniches: [
                    { id: 'motivational', name: 'Speeches' },
                    { id: 'quotes', name: 'Quotes' },
                    { id: 'success-stories', name: 'Success Stories' },
                    { id: 'life-lessons', name: 'Life Lessons' },
                    { id: 'spirituality', name: 'Spirituality' }
                ]
            },
            news: {
                id: 'news',
                name: 'News',
                icon: '',
                subniches: [
                    { id: 'world-news', name: 'World News' },
                    { id: 'politics', name: 'Politics' },
                    { id: 'sports', name: 'Sports' },
                    { id: 'social-commentary', name: 'Commentary' }
                ]
            }
        };

        // ==========================================
        // 4.3 VIDEO STYLES
        // ==========================================
        const VIDEO_STYLES = {
            modern: {
                id: 'modern',
                name: 'Modern Minimalist',
                icon: '',
                description: 'Clean, sleek aesthetics',
                imagePromptModifiers: 'minimalist, clean design, modern aesthetic, solid colors, geometric shapes',
                transitionStyle: 'smooth-fade',
                pacing: 'medium'
            },
            cinematic: {
                id: 'cinematic',
                name: 'Cinematic',
                icon: '',
                description: 'Movie-quality visuals',
                imagePromptModifiers: 'cinematic lighting, dramatic, film quality, depth of field, professional photography',
                transitionStyle: 'cinematic-fade',
                pacing: 'slow'
            },
            energetic: {
                id: 'energetic',
                name: 'Energetic',
                icon: '',
                description: 'Fast-paced, bold colors',
                imagePromptModifiers: 'vibrant colors, dynamic composition, energetic, bold, eye-catching',
                transitionStyle: 'quick-cuts',
                pacing: 'fast'
            },
            documentary: {
                id: 'documentary',
                name: 'Documentary',
                icon: '',
                description: 'Authentic, raw style',
                imagePromptModifiers: 'documentary style, realistic, photojournalistic, authentic, raw',
                transitionStyle: 'simple-cut',
                pacing: 'medium'
            },
            retro: {
                id: 'retro',
                name: 'Retro/Vintage',
                icon: '',
                description: 'Nostalgic film grain',
                imagePromptModifiers: 'vintage aesthetic, retro style, film grain, warm tones, nostalgic',
                transitionStyle: 'vhs-glitch',
                pacing: 'medium'
            },
            futuristic: {
                id: 'futuristic',
                name: 'Futuristic',
                icon: '',
                description: 'High-tech, neon aesthetic',
                imagePromptModifiers: 'futuristic, sci-fi, neon lights, cyber, holographic, high-tech',
                transitionStyle: 'digital-glitch',
                pacing: 'medium-fast'
            },
            cartoon: {
                id: 'cartoon',
                name: 'Animated',
                icon: '',
                description: 'Illustrated, playful',
                imagePromptModifiers: 'cartoon style, illustrated, colorful, playful, digital art, animation style',
                transitionStyle: 'bounce',
                pacing: 'medium'
            },
            elegant: {
                id: 'elegant',
                name: 'Elegant & Luxury',
                icon: '',
                description: 'Sophisticated, premium',
                imagePromptModifiers: 'luxury, elegant, sophisticated, premium quality, gold accents, refined',
                transitionStyle: 'smooth-elegant',
                pacing: 'slow'
            },
            nature: {
                id: 'nature',
                name: 'Nature & Organic',
                icon: '',
                description: 'Natural, calming',
                imagePromptModifiers: 'natural, organic, earthy tones, peaceful, nature photography, serene',
                transitionStyle: 'soft-dissolve',
                pacing: 'slow'
            },
            dark: {
                id: 'dark',
                name: 'Dark & Moody',
                icon: '',
                description: 'Dramatic, mysterious',
                imagePromptModifiers: 'dark mood, dramatic shadows, mysterious, noir style, moody lighting',
                transitionStyle: 'fade-dark',
                pacing: 'medium'
            }
        };

        // ==========================================
        // 4.4 FORMAT DISPLAY INFO
        // ==========================================
        const FORMAT_INFO = {
            '16:9': { name: 'Landscape', ratio: '16:9', className: 'ratio-16-9', desc: 'Wide screen' },
            '9:16': { name: 'Portrait', ratio: '9:16', className: 'ratio-9-16', desc: 'Vertical' },
            '1:1': { name: 'Square', ratio: '1:1', className: 'ratio-1-1', desc: 'Square' },
            '4:5': { name: 'Portrait', ratio: '4:5', className: 'ratio-4-5', desc: 'Tall' }
        };

        // ==========================================
        // 4.5 WIZARD STEPS
        // ==========================================
        const WIZARD_STEPS = [
            { num: 1, label: 'Platform', icon: '' },
            { num: 2, label: 'Niche & Style', icon: '' },
            { num: 3, label: 'Script', icon: '' },
            { num: 4, label: 'Storyboard', icon: '' },
            { num: 5, label: 'Animation', icon: '' },
            { num: 6, label: 'Edit and Export', icon: '' }
        ];

        // ==========================================
        // 4.6 TOPIC SUGGESTIONS BY NICHE
        // ==========================================
        const TOPIC_SUGGESTIONS = {
            entertainment: ['Top 10 plot twists', 'Hidden movie details', 'Celebrity facts you didn\'t know'],
            education: ['How X really works', '5 things school didn\'t teach you', 'The science behind Y'],
            business: ['Money habits of millionaires', 'Side hustle ideas', 'Investing mistakes to avoid'],
            health: ['Morning routine hacks', 'Foods that boost energy', 'Quick workout tips'],
            technology: ['AI tools you need', 'Tech predictions for 2025', 'Hidden phone features'],
            creative: ['Art techniques explained', 'Music production tips', 'Design trends'],
            travel: ['Hidden gem destinations', 'Travel hacks', 'Best street food cities'],
            motivation: ['Success mindset', 'Overcoming failure', 'Daily habits of winners'],
            news: ['Breaking down the headlines', 'What this means for you', 'Expert analysis']
        };
    </script>

    <!-- ============================================
         SECTION 5: STATE MANAGEMENT
         ============================================ -->
    <script>
        // ==========================================
        // 5.1 APPLICATION STATE
        // ==========================================
        const state = {
            // User & Auth
            user: null,
            isLoading: true,

            // Token system
            tokens: {
                balance: 0,
                plan: 'free'
            },

            // Current wizard step
            currentStep: 1,
            maxReachedStep: 1,

            // Project metadata
            project: {
                id: null,
                name: 'Untitled Video',
                createdAt: null,
                updatedAt: null
            },

            // Step 1: Platform & Format (Legacy - keeping for backwards compatibility)
            platform: {
                selected: null,           // Platform ID
                preset: null,             // Full preset object
                aspectRatio: null,        // Selected aspect ratio
                targetDuration: 60        // Target duration in seconds
            },

            // ==========================================
            // NEW WIZARD FLOW: Production Type System
            // ==========================================
            // Step 1 (New): Format Selection
            production: {
                format: null,               // FORMAT_PRESET id (widescreen, vertical, square, tall)
                formatConfig: null,         // Full FORMAT_PRESET object
                type: null,                 // PRODUCTION_TYPE id (social, movie, series, educational, music-video, commercial)
                typeConfig: null,           // Full PRODUCTION_TYPE object
                subType: null,              // Sub-type id (e.g., thriller, comedy, explainer)
                subTypeConfig: null,        // Full sub-type configuration object
                targetDuration: 180,        // Target duration in seconds
                episodeConfig: null         // For series: { season, episode, totalEpisodes }
            },

            // Step 2 (New): Concept Development
            concept: {
                status: 'idle',             // 'idle', 'generating', 'ready', 'error'
                keywords: [],               // User's input keywords
                rawInput: '',               // Original user input
                ideas: [],                  // AI-generated unique ideas
                selectedIdea: null,         // User's selected idea (index or object)
                refinedConcept: null,       // Final refined concept with all details
                styleReference: '',         // Style inspiration (NOT subject matter - critical distinction)
                uniqueElements: [],         // What makes this unique
                avoidElements: [],          // What to explicitly avoid (like direct copies)
                logline: '',                // One-line summary
                worldBuilding: null,        // For fantasy/scifi: world rules and elements
                // AI Improvement Feature
                isImproving: false,         // True when AI is enhancing the idea
                improvedData: null,         // Full AI enhancement result
                suggestedMood: null,        // AI-detected mood
                suggestedTone: null,        // AI-detected tone
                keyElements: [],            // Core creative elements
                characters: []              // Suggested character archetypes
            },

            // Step 3 (New): Character Intelligence
            characterIntelligence: {
                status: 'idle',             // 'idle', 'analyzing', 'ready'
                characterType: 'auto',      // 'auto' | 'human' | 'non-human' | 'abstract' | 'mixed' | 'none'
                narrationMode: 'auto',      // 'auto' | 'dialogue' | 'voiceover' | 'narrator' | 'mixed' | 'none'
                suggestedCount: 0,          // AI-suggested character count
                characters: [],             // Array of { id, name, role, type, description, visualDescription, personality, voice }
                narratorConfig: null,       // If using narrator: { style, voice, personality }
                recommendations: null       // AI recommendations based on production type
            },

            // Step 2: Niche & Style (Legacy)
            content: {
                niche: null,              // Niche ID
                subniche: null,           // Sub-niche ID
                style: null,              // Style ID
                topic: '',                // User's topic/theme
                tone: 'engaging',         // casual, professional, humorous, serious
                pacing: 'balanced',       // 'fast' | 'balanced' | 'contemplative' - controls scene timing
                contentDepth: 'detailed', // 'minimal' | 'standard' | 'detailed' | 'comprehensive' - content richness
                // Hollywood Production Mode (Phase 2)
                productionMode: 'standard', // 'standard' | 'documentary' | 'thriller' | 'inspirational' | 'story' | 'cinematic'
                // Phase 3A: Genre Reference System
                genre: null,              // Genre key (e.g., 'documentary-nature', 'educational-explainer')
                contentFormat: 'medium-form', // 'short-form' | 'medium-form' | 'long-form' | 'episodic'
                // Phase 3F: Narrative Structure Intelligence
                narrativePreset: null,    // 'youtube-standard' | 'tiktok-viral' | 'cinematic-short' | etc.
                storyArc: null,           // 'three-act' | 'heros-journey' | 'dan-harmon-circle' | etc.
                emotionalJourney: null,   // 'triumph' | 'redemption' | 'thriller' | etc.
                tensionCurve: null,       // 'steady-build' | 'waves' | 'slow-burn' | etc.
                narrativeAnalysis: null,  // Cached analysis from AI
                // Video Generation Model Configuration
                videoModel: {
                    provider: 'minimax',                    // 'minimax' | 'runpod' (future providers)
                    model: 'hailuo-2.3',                    // 'hailuo-2.3' | 'hailuo-2.3-fast' | 'hailuo-02'
                    duration: '10s',                        // '5s' | '6s' | '10s' - 5s for quick non-dialogue, 10s for dialogue/action
                    resolution: '768p',                     // '768p' | '1080p' (1080p only for 6s)
                    mode: 'quality'                         // 'quality' | 'fast' | 'continuity'
                }
            },

            // Step 3: Script
            script: {
                status: 'idle', // 'idle', 'generating', 'generated', 'error'
                error: null,    // Error message if status is 'error'
                title: '',
                hook: '',
                scenes: [],
                cta: '',
                totalDuration: 0,
                expandedScene: null,  // Track which scene is expanded in editor
                metadata: null,       // AI-generated metadata
                generatedAt: null,
                generationConfig: null
            },

            // Step 4: Storyboard
            storyboard: {
                status: 'idle', // idle, generating, ready, error
                scenes: [],     // Array of { sceneId, status, imageUrl, prompt, jobId, source, shots: [] }
                characterReference: null,
                // Phase 12: Multi-Shot Scene Architecture
                multiShotMode: {
                    enabled: false,             // Toggle multi-shot mode
                    defaultShotCount: 3,        // Default shots per scene (2-6)
                    autoDecompose: false,       // Auto-decompose scenes when enabled
                    decomposedScenes: {}        // { sceneId: { shots: [], consistencyAnchors: {}, status: 'pending'|'ready' } }
                },
                // Shot Decomposition Modal State
                decompositionModal: {
                    open: false,
                    sceneId: null,
                    shotCount: 3,               // Selected shot count
                    status: 'idle',             // idle, decomposing, ready, error
                    error: null
                },
                // Video Model Selector Popup State
                videoModelSelector: {
                    open: false,
                    sceneId: null,
                    shotIndex: null,
                    selectedModel: 'minimax',   // 'minimax' | 'multitalk'
                    selectedDuration: null,     // null = auto from shot, or '5s' | '10s' for override
                    // Multitalk-specific settings
                    multitalk: {
                        audioFile: null,        // Uploaded audio File object
                        audioUrl: null,         // Uploaded audio URL (Firebase Storage)
                        audioFileName: null,    // Display name
                        audioUploadStatus: 'idle', // idle, uploading, ready, error
                        audioDuration: null     // Duration in seconds
                    }
                },
                // Active polling intervals for cleanup on navigation
                activePollingIntervals: [],
                styleReference: null,
                modifyingScene: null,  // Scene ID being modified in modal
                modifyPrompt: null,    // Current prompt in modify modal
                modifyStyle: null,     // Current style in modify modal
                // Image generation settings
                imageModel: 'hidream',  // 'hidream' | 'nanobanana-pro' | 'nanobanana'
                // Phase 3B: Visual Style settings
                visualStyle: {
                    composition: null,      // null = auto from genre
                    lighting: null,         // null = auto from genre
                    colorPalette: null,     // null = auto from genre
                    mood: null              // optional mood override
                },
                // Phase 4: Scene Memory System - Layered Prompt Architecture
                // Ensures visual consistency across all scenes by using the same
                // Style Bible + Character Bible + Scene Content + Technical Specs
                styleBible: {
                    enabled: false,         // Toggle to enable/disable style bible
                    style: '',              // Overall visual style (e.g., "ultra-cinematic photoreal, noir thriller")
                    colorGrade: '',         // Color grading approach (e.g., "desaturated teal shadows, amber highlights")
                    lighting: '',           // Lighting philosophy (e.g., "harsh single-source, dramatic rim lights")
                    atmosphere: '',         // Environmental elements (e.g., "smoke, rain reflections, wet surfaces")
                    camera: ''              // Camera language (e.g., "slow dolly, low angles, stabilized gimbal")
                },
                characterBible: {
                    enabled: false,         // Toggle to enable/disable character bible
                    characters: []          // Array of { id, name, description, referenceImageUrl, referenceImageStatus, appliedToScenes[] }
                },
                // Location Bible - Ensures location consistency across scenes
                // Locations maintain their visual identity with reference images for consistent backgrounds
                locationBible: {
                    enabled: false,         // Toggle to enable/disable location bible
                    locations: [],          // Array of location objects (see below for structure)
                    // Location object: {
                    //   id: 'loc-{timestamp}',
                    //   name: 'Location name',
                    //   description: 'Full visual description',
                    //   type: 'exterior' | 'interior' | 'abstract',
                    //   timeOfDay: 'day' | 'night' | 'dawn' | 'dusk' | 'golden-hour',
                    //   weather: 'clear' | 'cloudy' | 'rainy' | 'foggy' | 'stormy',
                    //   mood: 'tense' | 'peaceful' | 'mysterious' | 'energetic',
                    //   referenceImageUrl: null,
                    //   referenceImageBase64: null,
                    //   referenceImageStatus: 'none' | 'generating' | 'ready' | 'error',
                    //   referenceImageMimeType: 'image/png',
                    //   lightingStyle: 'description of lighting',
                    //   keyElements: ['element1', 'element2'],
                    //   appliedToScenes: [] // Empty = all scenes
                    // }
                    autoDetected: false     // Whether locations were auto-extracted from script
                },
                technicalSpecs: {
                    enabled: true,          // Usually enabled by default
                    positive: '4K, ultra detailed, shallow DOF, cinematic, professional lighting',
                    negative: 'blurry, low quality, watermark, text, logo, deformed, extra fingers, bad anatomy'
                },
                // Scene Memory UI state
                showStyleBibleModal: false,
                showCharacterBibleModal: false,
                showLocationBibleModal: false,
                editingCharacterId: null,   // Currently editing character ID
                editingLocationId: null,    // Currently editing location ID
                generatingLocationRefId: null, // Location ID currently generating reference
                generatingPortraitCharId: null, // Character ID currently generating portrait
                // Edit with AI state
                editingScene: null,     // Scene ID being edited
                editMaskCanvas: null,   // Canvas element for mask
                editMaskCtx: null,      // Canvas 2D context
                editBrushSize: 30,      // Brush size in pixels
                editPrompt: '',         // Edit instruction prompt
                editLoading: false,     // Is edit in progress
                editHistory: [],        // Mask history for undo
                editOriginalData: null, // Original image data for canvas
                // Phase 8-11: Prompt Chain Architecture
                // The Golden Chain of Quality - Script  Image Prompt  Video Prompt  Final
                promptChain: {
                    enabled: true,              // Toggle prompt chain processing
                    status: 'idle',             // 'idle', 'processing', 'ready', 'error'
                    processedAt: null,          // When scenes were processed
                    scenes: [],                 // Array of processed scene data with blueprints
                    config: null                // Cached configuration from backend
                }
            },

            // Step 5: Animation (to be implemented)
            animation: {
                status: 'idle',
                scenes: [],
                voiceover: {
                    voice: 'default',
                    speed: 1.0,
                    status: 'idle'
                },
                // Animation Studio Pro 2.0 state
                selectedSceneId: null,
                selectedSceneIds: [],           // Multi-select support
                batchQueue: [],
                batchStatus: 'idle',            // 'idle', 'processing', 'complete'
                isPreviewPlaying: false,
                previewMode: 'animation',       // 'animation', 'voiceover', 'combined'
                // New Pro 2.0 features
                showKeyboardShortcuts: false,   // Keyboard shortcuts overlay
                showQueueManager: false,        // Queue manager panel
                cinemaMode: false,              // Full-screen cinema preview
                cinemaModeSceneIndex: 0,        // Current scene in cinema mode
                abCompareMode: false,           // A/B voice comparison
                abCompareVoices: ['nova', 'alloy'], // Voices to compare
                abCompareAudioUrls: [null, null],   // Generated audio URLs
                draggedSceneId: null,           // Scene being dragged
                dropTargetIndex: null,          // Drop target position
                waveformData: {},               // Cached waveform data per scene
                currentPlaybackTime: 0,         // Playback position for waveform
                emotionPresets: {
                    emotion: 'neutral',         // 'happy', 'sad', 'excited', 'serious', 'neutral'
                    energy: 0.5,                // 0-1 scale
                    tone: 0.5                   // 0=casual, 1=professional
                },
                // Voice roles configuration (narrator vs character voices)
                voiceRoles: {},                 // sceneId -> 'narrator' | 'character'
                narratorVoice: 'nova',          // Global narrator voice (consistent across all narrator scenes)
                characterVoices: {},            // characterName -> voiceId (for future multi-character support)
                // Device Preview Modal
                devicePreview: {
                    isOpen: false,                  // Modal open state
                    device: 'laptop',               // 'mobile' | 'laptop' | 'tablet' (default laptop for 16:9)
                    currentClipIndex: 0             // Current clip being previewed
                },
                // Floating Preview (PiP mode)
                floatingPreview: {
                    enabled: false,                 // Whether PiP mode is active
                    position: 'bottom-right',       // 'top-left', 'top-right', 'bottom-left', 'bottom-right'
                    minimized: false                // Whether preview is minimized to icon
                }
            },

            // Step 6: Assembly
            assembly: {
                status: 'idle',
                sceneOrder: [],
                transitions: {},
                defaultTransition: 'fade',     // Default transition type
                music: { enabled: false, trackId: null, volume: 30, fadeIn: 2, fadeOut: 3 },
                // Enhanced caption settings
                captions: {
                    enabled: true,
                    style: 'karaoke',
                    position: 'bottom',
                    size: 1,
                    // New professional options
                    mode: 'word',              // 'word' or 'sentence'
                    fontFamily: 'Montserrat',
                    fontWeight: 600,
                    fillColor: '#FFFFFF',
                    strokeColor: '#000000',
                    strokeWidth: 2,
                    shadowEnabled: true,
                    effect: 'none',            // 'none', 'pop', 'fade', 'zoom', 'bounce'
                    highlightStyle: 'color',   // 'color', 'background', 'glow'
                    highlightColor: '#FBBF24'
                },
                audioMix: { voiceVolume: 100, musicVolume: 30 },
                musicLibrary: [],
                transitionTypes: [],
                captionStyles: [],
                // UI state for tabbed interface
                activeTab: 'text',             // 'text', 'audio', 'media', 'transitions'
                // Phase 3D: Audio Intelligence
                audioMood: null,               // 'epic' | 'intimate' | 'mysterious' | etc.
                voiceProfile: null,            // 'narrator-warm' | 'documentary' | etc.
                transitionSound: null,         // 'whoosh-soft' | 'glitch' | etc.
                ambienceLayer: null,           // 'nature-forest' | 'urban-city' | etc.
                // Phase 3E: Smart Assembly Engine
                assemblyPreset: null,          // 'youtube-engaging' | 'cinematic-film' | etc.
                pacingProfile: null,           // 'rapid-fire' | 'balanced' | 'cinematic' | etc.
                beatSyncMode: 'off',           // 'off' | 'subtle' | 'moderate' | 'aggressive' | 'music-video'
                patternInterrupt: null,        // 'youtube' | 'tiktok' | 'cinema' | etc.
                bRollStrategy: null,           // 'aggressive' | 'moderate' | 'minimal' | etc.
                // Smart Audio AI (Phase 2)
                audioProfile: null,            // AI-generated audio recommendations
                audioAnalyzing: false,         // Loading state for audio analysis
                // Music Browser (Phase 3)
                musicBrowser: {
                    isOpen: false,
                    searchQuery: '',
                    selectedCategory: null,
                    results: [],
                    categories: [],
                    loading: false,
                    page: 1,
                    total: 0
                },
                // Phase 5: Beat Synchronization
                beatSync: {
                    syncMode: 'balanced',
                    analyzing: false,
                    beatMap: null,
                    suggestions: null,
                    summary: null,
                    applied: false
                }
            },

            // Preview Engine State
            preview: {
                isReady: false,
                isPlaying: false,
                currentTime: 0,
                totalDuration: 0,
                currentSceneIndex: 0,
                loadProgress: 0,
                volume: 100
            },

            // Export (modal in Step 6)
            export: {
                showModal: false,
                status: 'idle',
                jobId: null,
                progress: 0,
                currentStage: null,
                outputUrl: null,
                error: null,
                selectedQuality: '1080p',
                selectedRenderQuality: 'balanced',  // fast, balanced, or best
                // Phase 3C: Export Intelligence
                selectedPlatform: null,        // null = use wizard platform
                additionalPlatforms: [],       // for multi-platform export
                seriesInfo: null,              // { template: 'youtube-series', episodeNumber: 1, seasonNumber: 1 }
                showAdvancedOptions: false,
                recommendations: null          // cached recommendations from backend
            },

            // Timeline Editor State
            timeline: {
                zoom: 50, // pixels per second
                scrollLeft: 0,
                selectedClipId: null,
                selectedTrack: null,
                snapToGrid: true,
                showWaveforms: true,
                waveformCache: {}, // sceneId -> waveform data
                isInitialized: false
            }
        };

        // ==========================================
        // 5.2 STATE HELPERS
        // ==========================================
        function updateState(path, value) {
            const keys = path.split('.');
            let current = state;
            for (let i = 0; i < keys.length - 1; i++) {
                current = current[keys[i]];
            }
            current[keys[keys.length - 1]] = value;
        }

        function getState(path) {
            const keys = path.split('.');
            let current = state;
            for (const key of keys) {
                current = current[key];
            }
            return current;
        }
    </script>

    <!-- ============================================
         SECTION 6: CORE FUNCTIONS
         ============================================ -->
    <script>
        // ==========================================
        // 6.1 FIREBASE INITIALIZATION
        // ==========================================
        const firebaseConfig = {
            apiKey: "AIzaSyAGczY5ZEIJdTq25BpQdia3lv2I556wOZo",
            authDomain: "ytseo-6d1b0.firebaseapp.com",
            projectId: "ytseo-6d1b0",
            storageBucket: "ytseo-6d1b0.firebasestorage.app",
            messagingSenderId: "363779069774",
            appId: "1:363779069774:web:1c9eb0be0abf8d5c2a7f66"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const functions = firebase.functions();
        const storage = firebase.storage();

        // ==========================================
        // 6.2 AUTHENTICATION
        // ==========================================
        let authResolved = false;
        let authTimeoutId = null;

        async function initAuth() {
            return new Promise((resolve, reject) => {
                // Set up a maximum wait time for auth (5 seconds - increased for reliability)
                // This handles the race condition where Firebase takes time to restore auth state
                authTimeoutId = setTimeout(() => {
                    if (authResolved) return; // Already resolved

                    // Final check before redirecting
                    const currentUser = auth.currentUser;
                    console.log('Auth timeout check - currentUser:', currentUser ? 'exists' : 'null');
                    if (currentUser) {
                        authResolved = true;
                        state.user = currentUser;
                        loadUserTokens().then(() => resolve(currentUser));
                    } else {
                        // Don't auto-redirect - resolve with null and let the page handle it
                        // This prevents redirect loops and improves UX
                        console.log('Auth timeout: No user found. Proceeding without redirect.');
                        authResolved = true;
                        state.user = null;
                        resolve(null);
                    }
                }, 5000);

                // Listen for auth state changes
                const unsubscribe = auth.onAuthStateChanged(async (user) => {
                    // If already resolved, ignore subsequent calls
                    if (authResolved) return;

                    console.log('Auth state changed:', user ? user.email : 'no user');

                    if (user) {
                        // User is authenticated - clear timeout and proceed
                        authResolved = true;
                        if (authTimeoutId) {
                            clearTimeout(authTimeoutId);
                            authTimeoutId = null;
                        }
                        state.user = user;
                        await loadUserTokens();
                        resolve(user);
                        return;
                    }

                    // User is null - this could be:
                    // 1. Initial call before Firebase loads auth from storage (wait for real state)
                    // 2. User is truly not authenticated
                    // The timeout above will handle the final decision
                    console.log('Auth state: waiting for Firebase to restore session...');
                });
            });
        }

        async function loadUserTokens() {
            try {
                const userDoc = await db.collection('users').doc(state.user.uid).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    state.tokens.balance = userData.creativeTokens || userData.tokens || 0;
                    state.tokens.plan = userData.plan || 'free';
                }
            } catch (error) {
                console.error('Error loading tokens:', error);
            }
        }

        // ==========================================
        // 6.3 PROJECT SAVE/LOAD
        // ==========================================
        let saveDebounceTimer = null;
        let isSaving = false;

        function scheduleAutoSave() {
            // Don't auto-save if no project ID yet (new project needs explicit save)
            if (!state.project.id) return;

            // Debounce to avoid too many saves
            if (saveDebounceTimer) {
                clearTimeout(saveDebounceTimer);
            }
            saveDebounceTimer = setTimeout(() => {
                saveProject(true); // true = silent save
            }, 2000);
        }

        /**
         * Prepare data for saving by stripping large base64 images
         * This prevents 503 errors from payload size limits (Cloud Functions: 10MB, Firestore: 1MB)
         * Reference images are stored in Firebase Storage and accessed via URLs
         */
        function prepareDataForSave(data) {
            if (!data) return data;
            if (typeof data !== 'object') return data;
            if (Array.isArray(data)) {
                return data.map(item => prepareDataForSave(item));
            }

            const cleaned = {};
            for (const [key, value] of Object.entries(data)) {
                // Skip base64 image data - these are stored in Firebase Storage
                if (key.includes('Base64') || key.includes('base64')) {
                    // Keep a flag that indicates there WAS data, but don't save the actual base64
                    if (value) {
                        cleaned[key.replace('Base64', 'HasData').replace('base64', 'HasData')] = true;
                    }
                    continue;
                }
                // Skip UI-only state that shouldn't be persisted
                if (key === 'activePollingIntervals' || key === 'decompositionModal' ||
                    key === 'modifyingScene' || key === 'modifyPrompt' || key === 'modifyStyle' ||
                    key === 'showStyleBibleModal' || key === 'showCharacterBibleModal' ||
                    key === 'showLocationBibleModal' || key === 'showTechnicalSpecsModal') {
                    continue;
                }
                // Recursively clean nested objects
                cleaned[key] = prepareDataForSave(value);
            }
            return cleaned;
        }

        async function saveProject(silent = false) {
            if (isSaving) return;
            isSaving = true;

            try {
                const saveProjectFn = functions.httpsCallable('creationWizardSaveProject');

                // Prepare cleaned data - strips base64 images to prevent payload size issues
                const projectData = prepareDataForSave({
                    name: state.project.name || generateProjectName(),
                    status: state.project.status,
                    // CRITICAL: Save current step and max reached step for proper restoration
                    currentStep: state.currentStep,
                    maxReachedStep: state.maxReachedStep,
                    platform: state.platform,
                    content: state.content,
                    // NEW WIZARD FLOW: Production + Concept + Character Intelligence
                    production: state.production,
                    concept: state.concept,
                    characterIntelligence: state.characterIntelligence,
                    // End new wizard flow
                    script: state.script,
                    storyboard: state.storyboard,
                    animation: state.animation,
                    assembly: state.assembly,
                    export: state.export
                });

                console.log('[saveProject] Saving project data (base64 stripped)');

                const result = await saveProjectFn({
                    projectId: state.project.id || null,
                    projectData
                });

                if (result.data.success) {
                    state.project.id = result.data.projectId;
                    state.project.updatedAt = new Date().toISOString();

                    // Update URL with project ID
                    if (window.history.replaceState) {
                        const url = new URL(window.location);
                        url.searchParams.set('project', state.project.id);
                        window.history.replaceState({}, '', url);
                    }

                    if (!silent) {
                        showToast('Project saved', 'success');
                    }
                }
            } catch (error) {
                console.error('Save project error:', error);
                if (!silent) {
                    showToast('Failed to save project', 'error');
                }
            } finally {
                isSaving = false;
            }
        }

        async function loadProject(projectId) {
            state.isLoading = true;
            render();

            try {
                const loadProjectFn = functions.httpsCallable('creationWizardLoadProject');
                const result = await loadProjectFn({ projectId });

                if (result.data.success) {
                    const project = result.data.project;

                    // Restore state from project
                    state.project.id = project.id;
                    state.project.name = project.name;
                    state.project.status = project.status;
                    state.project.createdAt = project.createdAt;
                    state.project.updatedAt = project.updatedAt;

                    // Restore platform config
                    if (project.platform) {
                        state.platform = { ...state.platform, ...project.platform };
                        // Restore preset if platform was selected
                        if (project.platform.selected && PLATFORM_PRESETS[project.platform.selected]) {
                            state.platform.preset = PLATFORM_PRESETS[project.platform.selected];
                        }
                    }

                    // Restore content config
                    if (project.content) {
                        state.content = { ...state.content, ...project.content };
                    }

                    // NEW WIZARD FLOW: Restore production config
                    if (project.production) {
                        state.production = { ...state.production, ...project.production };
                        // Restore full config objects from constants
                        if (project.production.format && FORMAT_PRESETS[project.production.format]) {
                            state.production.formatConfig = FORMAT_PRESETS[project.production.format];
                            // CRITICAL: Sync aspect ratio to legacy platform state for image generation
                            // This ensures image generators receive the correct aspect ratio
                            state.platform.aspectRatio = FORMAT_PRESETS[project.production.format].aspectRatio;
                        }
                        if (project.production.type && PRODUCTION_TYPES[project.production.type]) {
                            state.production.typeConfig = PRODUCTION_TYPES[project.production.type];
                            if (project.production.subType) {
                                state.production.subTypeConfig = PRODUCTION_TYPES[project.production.type].subTypes[project.production.subType];
                            }
                        }
                        // Sync target duration to legacy state
                        if (project.production.targetDuration) {
                            state.platform.targetDuration = project.production.targetDuration;
                        }
                    }

                    // NEW WIZARD FLOW: Restore concept development
                    if (project.concept) {
                        state.concept = { ...state.concept, ...project.concept };
                    }

                    // NEW WIZARD FLOW: Restore character intelligence
                    if (project.characterIntelligence) {
                        state.characterIntelligence = { ...state.characterIntelligence, ...project.characterIntelligence };
                    }

                    // Restore script data
                    if (project.script) {
                        state.script = { ...state.script, ...project.script };
                    }

                    // Restore storyboard data
                    if (project.storyboard) {
                        state.storyboard = { ...state.storyboard, ...project.storyboard };
                        // Phase 4: Initialize Scene Memory defaults for older projects
                        initSceneMemory();
                        // Refresh reference image base64 from URLs (don't await, run in background)
                        // Base64 data is stripped during save to prevent payload size issues
                        refreshCharacterPortraitBase64();
                        refreshLocationReferenceBase64();
                    }

                    // Restore animation data
                    if (project.animation) {
                        state.animation = { ...state.animation, ...project.animation };
                    }

                    // Restore assembly data
                    if (project.assembly) {
                        state.assembly = { ...state.assembly, ...project.assembly };
                    }

                    // Restore export data
                    if (project.export) {
                        state.export = { ...state.export, ...project.export };
                    }

                    // CRITICAL: Restore step progress from saved data, or calculate from completed data
                    if (project.currentStep && project.maxReachedStep) {
                        // Use saved step values (preferred - preserves exact user position)
                        state.currentStep = project.currentStep;
                        state.maxReachedStep = project.maxReachedStep;
                    } else {
                        // Fallback: Calculate from completed data (for older projects)
                        state.maxReachedStep = calculateMaxReachedStep();
                        state.currentStep = state.maxReachedStep;
                    }

                    showToast('Project loaded', 'success');
                }
            } catch (error) {
                console.error('Load project error:', error);
                showToast('Failed to load project', 'error');
            } finally {
                state.isLoading = false;
                render();
            }
        }

        async function loadProjectsList() {
            try {
                const getProjectsFn = functions.httpsCallable('creationWizardGetProjects');
                const result = await getProjectsFn({ limit: 20 });

                if (result.data.success) {
                    return result.data.projects;
                }
                return [];
            } catch (error) {
                console.error('Load projects list error:', error);
                return [];
            }
        }

        async function deleteProject(projectId) {
            if (!confirm('Are you sure you want to delete this project?')) return;

            try {
                const deleteProjectFn = functions.httpsCallable('creationWizardDeleteProject');
                await deleteProjectFn({ projectId });
                showToast('Project deleted', 'success');

                // If we deleted the current project, start fresh
                if (state.project.id === projectId) {
                    window.location.href = '/video-creation';
                }
            } catch (error) {
                console.error('Delete project error:', error);
                showToast('Failed to delete project', 'error');
            }
        }

        function generateProjectName() {
            const niche = state.content.niche ? VIDEO_NICHES[state.content.niche]?.name : '';
            const topic = state.content.topic ? ` - ${state.content.topic.slice(0, 30)}` : '';
            const date = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            return `${niche || 'Video'} Project${topic} (${date})`;
        }

        function calculateMaxReachedStep() {
            // Step 6 is the final step (Edit and Export)
            // This function calculates the furthest step reached based on completed data

            // Check from highest step down to lowest
            if (state.export.status === 'complete') return 6;
            if (state.assembly.status === 'ready') return 6;
            if (state.animation.scenes.length > 0) return 6;
            if (state.storyboard.scenes.length > 0) return 5;
            if (state.script.scenes.length > 0) return 4;

            // NEW WIZARD FLOW: Check concept and character intelligence (Step 3)
            if (state.concept?.refinedConcept || state.concept?.selectedIdea !== undefined) return 3;
            if (state.characterIntelligence?.characters?.length > 0) return 3;
            if (state.content.niche && state.content.style) return 3;

            // Check production setup (Step 2)
            if (state.production?.format && state.production?.type) return 2;
            if (state.platform.selected) return 2;

            // Default to step 1
            return 1;
        }

        function checkUrlForProject() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectId = urlParams.get('project');
            if (projectId) {
                return projectId;
            }
            return null;
        }

        // ==========================================
        // 6.4 NAVIGATION
        // ==========================================
        function goToStep(step) {
            // Validate step transition
            if (step < 1 || step > WIZARD_STEPS.length) return;
            if (step > state.maxReachedStep + 1) return;

            // Validate current step is complete before moving forward
            if (step > state.currentStep && !isStepComplete(state.currentStep)) {
                showToast('Please complete the current step first', 'warning');
                return;
            }

            // Cleanup preview engine when leaving Assembly step
            if (state.currentStep === 6 && step !== 6) {
                cleanupPreviewEngine();
            }

            // Cleanup polling intervals when leaving Storyboard step (where video generation happens)
            if (state.currentStep === 4 && step !== 4) {
                cleanupAllPollingIntervals();
            }

            state.currentStep = step;
            if (step > state.maxReachedStep) {
                state.maxReachedStep = step;
            }

            render();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function isStepComplete(step) {
            // Check if using new production flow or legacy flow
            const usingNewFlow = state.production.type && state.production.format;

            switch (step) {
                case 1:
                    // New flow: Format + Production Type + SubType selected
                    // Legacy flow: Platform + Aspect ratio selected
                    if (usingNewFlow) {
                        return state.production.format && state.production.type && state.production.subType;
                    }
                    return state.platform.selected && state.platform.aspectRatio;
                case 2:
                    // New flow: Concept developed (either has selected idea OR has topic)
                    // Legacy flow: Niche + Style selected
                    if (usingNewFlow) {
                        return state.concept.selectedIdea !== null || (state.concept.rawInput && state.concept.rawInput.length > 10);
                    }
                    return state.content.niche && state.content.style;
                case 3:
                    return state.script.scenes.length > 0;
                case 4:
                    return state.storyboard.scenes.length > 0;
                case 5:
                    return state.animation.scenes.length > 0;
                case 6:
                    return state.assembly.status === 'ready';
                default:
                    return true;
            }
        }

        // ==========================================
        // 6.4 PLATFORM SELECTION
        // ==========================================
        function selectPlatform(platformId) {
            const preset = PLATFORM_PRESETS[platformId];
            if (!preset) return;

            state.platform.selected = platformId;
            state.platform.preset = preset;
            state.platform.aspectRatio = preset.defaultFormat;
            state.platform.targetDuration = Math.min(
                preset.maxDuration,
                Math.max(preset.minDuration, state.platform.targetDuration)
            );

            render();
            scheduleAutoSave();
        }

        function selectFormat(format) {
            if (!state.platform.preset) return;
            if (!state.platform.preset.formats.includes(format)) return;

            state.platform.aspectRatio = format;

            // Update resolution based on format
            const resolutions = {
                '16:9': { width: 1920, height: 1080 },
                '9:16': { width: 1080, height: 1920 },
                '1:1': { width: 1080, height: 1080 },
                '4:5': { width: 1080, height: 1350 }
            };
            state.platform.preset.resolution = resolutions[format];

            render();
            scheduleAutoSave();
        }

        function setDuration(duration) {
            if (!state.platform.preset) return;
            const preset = state.platform.preset;
            state.platform.targetDuration = Math.min(
                preset.maxDuration,
                Math.max(preset.minDuration, parseInt(duration))
            );
            render();
            scheduleAutoSave();
        }

        // ==========================================
        // 6.5B CONCEPT DEVELOPMENT FUNCTIONS (New Wizard Flow)
        // ==========================================
        function updateConceptInput(value) {
            state.concept.rawInput = value;
            // Parse keywords from input
            state.concept.keywords = value.split(/[,\n]/).map(k => k.trim()).filter(k => k.length > 0);
            scheduleAutoSave();
        }

        function updateStyleReference(value) {
            state.concept.styleReference = value;
            scheduleAutoSave();
        }

        function updateAvoidElements(value) {
            state.concept.avoidElements = value.split(',').map(e => e.trim()).filter(e => e.length > 0);
            scheduleAutoSave();
        }

        function updateConceptLogline(value) {
            state.concept.logline = value;
            scheduleAutoSave();
        }

        function selectConceptIdea(index) {
            // Validate index is within bounds
            if (!state.concept.ideas || !Array.isArray(state.concept.ideas)) {
                console.error('[Step 2] No ideas array available for selection');
                showToast('No ideas available to select', 'error');
                return;
            }
            if (index < 0 || index >= state.concept.ideas.length) {
                console.error(`[Step 2] Invalid idea index: ${index}, ideas length: ${state.concept.ideas.length}`);
                showToast('Invalid idea selection', 'error');
                return;
            }

            state.concept.selectedIdea = index;
            const idea = state.concept.ideas[index];
            if (idea) {
                state.concept.logline = idea.logline || idea.description || '';
                state.concept.uniqueElements = idea.uniqueElements || [];
                state.concept.refinedConcept = idea;
                // Also update legacy content.topic for compatibility
                const title = idea.title || 'Untitled';
                const description = idea.logline || idea.description || '';
                state.content.topic = title + (description ? ': ' + description : '');
            } else {
                console.error(`[Step 2] Idea at index ${index} is null/undefined`);
            }
            render();
            scheduleAutoSave();
        }

        /**
         * AI-Powered Idea Improvement
         * Takes rough user input and transforms it into a genius, detailed concept
         * Auto-fills all fields with extracted and enhanced information
         */
        async function improveConceptIdea() {
            const rawInput = state.concept.rawInput;

            if (!rawInput || rawInput.trim().length < 10) {
                showToast('Please enter at least a brief concept idea to enhance', 'warning');
                return;
            }

            state.concept.isImproving = true;
            render();

            try {
                const improveIdea = firebase.functions().httpsCallable('creationWizardImproveIdea');

                // Get existing characters from selected concept to preserve their names
                const selectedConceptCharacters = state.concept.refinedConcept?.characters || [];

                console.log('[improveConceptIdea] Passing existing characters:', {
                    count: selectedConceptCharacters.length,
                    names: selectedConceptCharacters.map(c => c.name).join(', ') || 'none'
                });

                const result = await improveIdea({
                    rawInput: rawInput,
                    productionType: state.production.typeConfig?.name || state.production.type,
                    productionSubType: state.production.subTypeConfig?.name || state.production.subType,
                    currentStyleReference: state.concept.styleReference,
                    existingCharacters: selectedConceptCharacters  // Preserve character names from selected concept
                });

                if (result.data.success) {
                    const data = result.data;

                    // Update the concept description with the improved version
                    if (data.improvedConcept) {
                        state.concept.rawInput = data.improvedConcept;
                        // Update the textarea directly for immediate feedback
                        const textarea = document.getElementById('concept-input');
                        if (textarea) textarea.value = data.improvedConcept;
                    }

                    // Auto-fill style reference from extracted styles
                    if (data.extractedStyles && data.extractedStyles.length > 0) {
                        state.concept.styleReference = data.extractedStyles.join(', ');
                        const styleInput = document.getElementById('style-reference-input');
                        if (styleInput) styleInput.value = state.concept.styleReference;
                    }

                    // Auto-fill things to avoid
                    if (data.thingsToAvoid && data.thingsToAvoid.length > 0) {
                        state.concept.avoidElements = data.thingsToAvoid;
                        const avoidInput = document.getElementById('avoid-input');
                        if (avoidInput) avoidInput.value = data.thingsToAvoid.join(', ');
                    }

                    // Store additional enhancement data
                    state.concept.improvedData = data;
                    state.concept.suggestedMood = data.suggestedMood;
                    state.concept.suggestedTone = data.suggestedTone;
                    state.concept.keyElements = data.keyElements || [];
                    state.concept.worldBuilding = data.worldBuilding;
                    state.concept.characters = data.characters || [];

                    // Update content state for compatibility
                    if (data.suggestedMood && typeof data.suggestedMood === 'string') {
                        state.content.mood = data.suggestedMood;
                    }
                    if (data.suggestedTone && typeof data.suggestedTone === 'string') {
                        state.content.tone = data.suggestedTone.toLowerCase();
                    }

                    showToast(' Idea enhanced! All fields have been auto-filled with genius content.', 'success');
                    console.log('[improveConceptIdea] Enhancement result:', data);
                } else {
                    showToast('Enhancement completed with limited results', 'info');
                }

            } catch (error) {
                console.error('[improveConceptIdea] Error:', error);
                showToast('Failed to enhance idea. Please try again.', 'error');
            }

            state.concept.isImproving = false;
            render();
            scheduleAutoSave();
        }

        async function generateConceptIdeas() {
            const rawInput = state.concept.rawInput;
            const styleReference = state.concept.styleReference;
            const avoidElements = state.concept.avoidElements;
            const production = state.production;
            const improvedData = state.concept.improvedData; // AI Enhancement data

            if (!rawInput && !production.type) {
                showToast('Please enter a concept idea or select a production type', 'warning');
                return;
            }

            state.concept.status = 'generating';
            render();

            try {
                // Build the concept generation prompt with ALL enrichment data
                const productionContext = production.type ? {
                    type: production.typeConfig?.name || production.type,
                    subType: production.subTypeConfig?.name || production.subType,
                    visualStyle: production.subTypeConfig?.visualStyle || '',
                    references: production.subTypeConfig?.references || [],
                    characteristics: production.subTypeConfig?.characteristics || [],
                    duration: production.targetDuration
                } : null;

                // Include AI enhancement data if available
                const enrichmentData = improvedData ? {
                    improvedConcept: improvedData.improvedConcept,
                    hookLine: improvedData.hookLine,
                    genreFusion: improvedData.genreFusion,
                    visualSignature: improvedData.visualSignature,
                    keyElements: improvedData.keyElements || [],
                    characters: improvedData.characters || [],
                    worldBuilding: improvedData.worldBuilding,
                    suggestedMood: improvedData.suggestedMood,
                    suggestedTone: improvedData.suggestedTone
                } : null;

                const generateConcepts = firebase.functions().httpsCallable('creationWizardGenerateConcepts');
                const result = await generateConcepts({
                    rawInput: improvedData?.improvedConcept || rawInput, // Use improved concept if available
                    styleReference: styleReference,
                    avoidElements: avoidElements,
                    production: productionContext,
                    enrichment: enrichmentData // Pass AI enhancement data
                });

                if (result.data.success && result.data.ideas) {
                    state.concept.ideas = result.data.ideas;
                    state.concept.status = 'ready';
                } else {
                    // Generate fallback ideas locally if backend fails
                    state.concept.ideas = generateFallbackIdeas(rawInput, productionContext);
                    state.concept.status = 'ready';
                }
            } catch (error) {
                console.error('Concept generation error:', error);
                // Generate fallback ideas locally
                state.concept.ideas = generateFallbackIdeas(rawInput, state.production);
                state.concept.status = 'ready';
            }

            render();
            scheduleAutoSave();
        }

        // Fallback idea generation when backend is unavailable
        function generateFallbackIdeas(rawInput, productionContext) {
            const baseIdea = rawInput || 'An untold story waiting to be discovered';
            const productionType = productionContext?.type || 'content';
            const visualStyle = productionContext?.visualStyle || 'cinematic';

            return [
                {
                    title: `${productionType} Concept 1`,
                    logline: `A unique exploration of ${baseIdea} with ${visualStyle} visuals`,
                    description: `Original interpretation inspired by your concept: ${baseIdea}`,
                    uniqueElements: ['Original characters', 'Unique setting', 'Fresh perspective'],
                    mood: 'Engaging',
                    tone: 'Professional'
                },
                {
                    title: `${productionType} Concept 2`,
                    logline: `A dramatic take on ${baseIdea} that captivates audiences`,
                    description: `Reimagined with a completely original cast and scenario`,
                    uniqueElements: ['Distinctive protagonist', 'Unexpected twist', 'Visual innovation'],
                    mood: 'Dramatic',
                    tone: 'Intense'
                },
                {
                    title: `${productionType} Concept 3`,
                    logline: `An emotional journey through ${baseIdea}`,
                    description: `A deeply personal story with universal themes`,
                    uniqueElements: ['Character depth', 'Emotional resonance', 'Memorable moments'],
                    mood: 'Emotional',
                    tone: 'Thoughtful'
                }
            ];
        }

        function setNarrationMode(mode) {
            state.characterIntelligence.narrationMode = mode;
            render();
            scheduleAutoSave();
        }

        function setCharacterCount(count) {
            state.characterIntelligence.suggestedCount = parseInt(count);
            render();
            scheduleAutoSave();
        }

        // ==========================================
        // 6.6 NICHE & STYLE SELECTION
        // ==========================================
        function selectNiche(nicheId) {
            state.content.niche = nicheId;
            state.content.subniche = null; // Reset subniche
            render();
            scheduleAutoSave();
        }

        function selectSubniche(subnicheId) {
            state.content.subniche = subnicheId;
            render();
            scheduleAutoSave();
        }

        function selectStyle(styleId) {
            state.content.style = styleId;
            render();
            scheduleAutoSave();
        }

        function setTopic(topic) {
            state.content.topic = topic;
            scheduleAutoSave();
        }

        function setPacing(pacing) {
            state.content.pacing = pacing;

            // Auto-configure video model duration based on pacing
            // MiniMax-Hailuo-2.3 supports both 6s and 10s durations
            if (!state.content.videoModel) {
                state.content.videoModel = { provider: 'minimax', model: 'hailuo-2.3', duration: '10s', resolution: '768p', mode: 'quality' };
            }

            // Fast pacing = 6s clips (1080p available), others = 10s clips (768p only)
            if (pacing === 'fast') {
                state.content.videoModel.duration = '6s';
                // 6s allows 1080p
            } else {
                // Default to 10s for balanced/contemplative for richer action
                state.content.videoModel.duration = '10s';
                // 10s clips only support 768p
                if (state.content.videoModel.resolution === '1080p') {
                    state.content.videoModel.resolution = '768p';
                }
            }

            render();
            scheduleAutoSave();
        }

        // Video Model Configuration Functions
        function setVideoModelMode(mode) {
            if (!state.content.videoModel) {
                state.content.videoModel = { provider: 'minimax', model: 'hailuo-2.3', duration: '10s', resolution: '768p', mode: 'quality' };
            }

            state.content.videoModel.mode = mode;

            // Map mode to model
            // hailuo-2.3 and hailuo-02 support both 6s and 10s
            // hailuo-2.3-fast only supports 6s
            const is10sVideo = state.content.videoModel.duration === '10s';
            const modeToModel = {
                'quality': 'hailuo-2.3',
                'fast': is10sVideo ? 'hailuo-2.3' : 'hailuo-2.3-fast',  // Fast only supports 6s
                'continuity': 'hailuo-02'
            };
            state.content.videoModel.model = modeToModel[mode] || 'hailuo-2.3';

            render();
            scheduleAutoSave();
        }

        function setVideoModelDuration(duration) {
            if (!state.content.videoModel) {
                state.content.videoModel = { provider: 'minimax', model: 'hailuo-2.3', duration: '10s', resolution: '768p', mode: 'quality' };
            }

            state.content.videoModel.duration = duration;

            // Auto-switch from fast mode if selecting 10s (fast mode doesn't support 10s)
            if (duration === '10s' && state.content.videoModel.model === 'hailuo-2.3-fast') {
                state.content.videoModel.model = 'hailuo-2.3';
            }

            // 10s clips only support 768p, 5s can use either
            if (duration === '10s' && state.content.videoModel.resolution === '1080p') {
                state.content.videoModel.resolution = '768p';
            }

            // Auto-adjust pacing to match duration
            if (duration === '5s' && state.content.pacing === 'contemplative') {
                // 5s is ideal for quick cuts, suggest fast pacing
            } else if (duration === '6s' && state.content.pacing === 'contemplative') {
                // Keep contemplative but note it's using 6s clips
            } else if (duration === '10s' && state.content.pacing === 'fast') {
                state.content.pacing = 'balanced'; // Fast pacing doesn't match 10s clips well
            }

            render();
            scheduleAutoSave();
        }

        function setVideoModelResolution(resolution) {
            if (!state.content.videoModel) {
                state.content.videoModel = { provider: 'minimax', model: 'hailuo-2.3', duration: '10s', resolution: '768p', mode: 'quality' };
            }

            // 1080p only available for 6s clips
            if (resolution === '1080p' && state.content.videoModel.duration === '10s') {
                showToast('1080p resolution is only available for 6s clips', 'warning');
                return;
            }

            state.content.videoModel.resolution = resolution;
            render();
            scheduleAutoSave();
        }

        function setProductionMode(mode) {
            state.content.productionMode = mode;

            // Auto-adjust pacing based on production mode
            if (mode === 'cinematic') {
                // Cinematic = slower, more visual breathing room
                state.content.pacing = 'contemplative';
            } else if (mode === 'thriller') {
                // Thriller = medium pacing with strategic pauses
                state.content.pacing = 'balanced';
            } else if (mode === 'documentary') {
                // Documentary = balanced pacing
                state.content.pacing = 'balanced';
            }

            render();
            scheduleAutoSave();
        }

        function setGenre(genreId) {
            state.content.genre = genreId;

            // CASCADE: Auto-apply production profile when genre changes
            if (genreId) {
                applyGenreProductionProfile(genreId, false); // Don't override manual settings
            }

            render();
            scheduleAutoSave();
        }

        // VISUAL_STYLE_DNA: Set Visual Rendering Style
        // This controls whether images are photorealistic, cinematic, 3D animated, etc.
        function setVisualStyleMode(styleMode) {
            state.content.visualStyleMode = styleMode;
            console.log('[VISUAL_STYLE_DNA] Selected style mode:', styleMode);

            // Show feedback to user
            const styleNames = {
                'photorealistic': 'Photorealistic (Real Photography)',
                'cinematic': 'Cinematic (Hollywood Look)',
                'stylized_3d': 'Stylized 3D (Pixar Quality)',
                'illustrated': 'Illustrated (Concept Art)',
                'anime': 'Anime (Japanese Animation)',
                'noir': 'Film Noir (High Contrast)'
            };
            showToast(`Visual style set to: ${styleNames[styleMode] || styleMode}`, 'success');

            render();
            scheduleAutoSave();
        }

        // ==========================================
        // GENRE INTELLIGENCE SYSTEM
        // Cascades production settings from genre selection
        // ==========================================

        const GENRE_PRODUCTION_PROFILES = {
            // Documentary genres
            'documentary-nature': {
                styleBible: {
                    style: 'cinematic documentary, National Geographic quality, epic landscapes',
                    colorGrade: 'rich earth tones, golden highlights, deep greens',
                    lighting: 'natural golden hour, soft diffused daylight',
                    atmosphere: 'volumetric fog, dust particles, lens flares',
                    camera: 'smooth tracking, wide establishing shots, intimate close-ups'
                },
                narratorVoice: 'onyx',  // Deep, authoritative
                audioMood: 'epic',
                musicCategory: 'cinematic',
                musicMood: ['epic', 'dramatic', 'contemplative'],
                technicalSpecs: {
                    positive: '4K, ultra detailed, shallow DOF, cinematic, natural lighting, epic scale',
                    negative: 'blurry, low quality, watermark, text, artificial, studio lighting'
                },
                animationStyle: 'ken_burns'
            },
            'documentary-true-crime': {
                styleBible: {
                    style: 'investigative documentary, gritty realism, archive footage aesthetic',
                    colorGrade: 'desaturated, cool shadows, limited palette',
                    lighting: 'harsh interview lighting, noir shadows, fluorescent green',
                    atmosphere: 'grainy, surveillance footage feel, newspaper clippings',
                    camera: 'static interviews, dramatic zooms, handheld urgency'
                },
                narratorVoice: 'echo',  // Serious, measured
                audioMood: 'tense',
                musicCategory: 'dramatic',
                musicMood: ['dark', 'tense', 'mysterious'],
                technicalSpecs: {
                    positive: '4K, documentary style, gritty, realistic, cinematic',
                    negative: 'blurry, colorful, happy, bright, watermark'
                },
                animationStyle: 'ken_burns'
            },
            'documentary-social': {
                styleBible: {
                    style: 'modern social documentary, intimate portraits, urban landscapes',
                    colorGrade: 'natural colors, slight desaturation, authentic',
                    lighting: 'available light, natural environments',
                    atmosphere: 'candid moments, street photography, real locations',
                    camera: 'observational, intimate close-ups, environmental wide shots'
                },
                narratorVoice: 'nova',  // Warm, engaging
                audioMood: 'contemplative',
                musicCategory: 'indie',
                musicMood: ['contemplative', 'intimate', 'hopeful'],
                technicalSpecs: {
                    positive: '4K, documentary, authentic, candid, natural lighting',
                    negative: 'blurry, artificial, staged, watermark'
                },
                animationStyle: 'ken_burns'
            },
            'documentary-historical': {
                styleBible: {
                    style: 'historical documentary, archival quality, Ken Burns style',
                    colorGrade: 'sepia tints, aged film look, period-appropriate colors',
                    lighting: 'natural period lighting, candlelit interiors',
                    atmosphere: 'historical texture, parchment, vintage photography',
                    camera: 'slow zooms on photos, pan across paintings, thoughtful pacing'
                },
                narratorVoice: 'fable',  // Storytelling warmth
                audioMood: 'nostalgic',
                musicCategory: 'classical',
                musicMood: ['nostalgic', 'contemplative', 'epic'],
                technicalSpecs: {
                    positive: '4K, historical, archival quality, period accurate, cinematic',
                    negative: 'blurry, modern elements, anachronistic, watermark'
                },
                animationStyle: 'ken_burns'
            },

            // Cinematic genres
            'cinematic-thriller': {
                styleBible: {
                    style: 'ultra-cinematic photoreal, noir thriller, high contrast',
                    colorGrade: 'desaturated teal shadows, amber highlights, crushed blacks',
                    lighting: 'harsh single-source, dramatic rim lights, deep shadows',
                    atmosphere: 'smoke, rain reflections, wet surfaces, urban grit',
                    camera: 'slow dolly, low angles, stabilized gimbal, anamorphic lens feel'
                },
                narratorVoice: 'onyx',  // Intense, commanding
                audioMood: 'tense',
                musicCategory: 'dramatic',
                musicMood: ['dark', 'tense', 'mysterious'],
                technicalSpecs: {
                    positive: '4K, ultra detailed, cinematic, noir, dramatic lighting, anamorphic',
                    negative: 'blurry, bright, happy, colorful, watermark'
                },
                animationStyle: 'ken_burns'
            },
            'cinematic-action': {
                styleBible: {
                    style: 'blockbuster action, high energy, dynamic composition',
                    colorGrade: 'high contrast, orange and teal, saturated',
                    lighting: 'dramatic backlighting, lens flares, explosions',
                    atmosphere: 'dust, debris, fire, motion blur',
                    camera: 'fast dolly, dutch angles, tracking shots, crash zooms'
                },
                narratorVoice: 'echo',  // Intense, energetic
                audioMood: 'energetic',
                musicCategory: 'electronic',
                musicMood: ['energetic', 'epic', 'intense'],
                technicalSpecs: {
                    positive: '4K, ultra detailed, action, dynamic, cinematic, explosive',
                    negative: 'blurry, static, calm, watermark'
                },
                animationStyle: 'ken_burns'
            },
            'cinematic-drama': {
                styleBible: {
                    style: 'prestige drama, Oscar-worthy cinematography, emotional depth',
                    colorGrade: 'rich but restrained, natural skin tones, dramatic contrast',
                    lighting: 'motivated lighting, golden hour, intimate practicals',
                    atmosphere: 'subtle, realistic environments, emotional resonance',
                    camera: 'elegant slow movements, meaningful compositions, long takes'
                },
                narratorVoice: 'nova',  // Emotional, warm
                audioMood: 'intimate',
                musicCategory: 'cinematic',
                musicMood: ['intimate', 'contemplative', 'hopeful'],
                technicalSpecs: {
                    positive: '4K, ultra detailed, cinematic, emotional, prestigious, film grain',
                    negative: 'blurry, amateur, oversaturated, watermark'
                },
                animationStyle: 'ken_burns'
            },

            // Horror genres
            'horror-psychological': {
                styleBible: {
                    style: 'psychological horror, unsettling, dreamlike quality',
                    colorGrade: 'desaturated, sickly greens, deep blacks, red accents',
                    lighting: 'low-key, single source, harsh shadows, flickering',
                    atmosphere: 'fog, dust motes, decayed textures, uncanny valley',
                    camera: 'dutch angles, slow creeping push-ins, unstable handheld'
                },
                narratorVoice: 'shimmer',  // Ethereal, unsettling
                audioMood: 'dark',
                musicCategory: 'dramatic',
                musicMood: ['dark', 'mysterious', 'tense'],
                technicalSpecs: {
                    positive: '4K, horror, unsettling, psychological, dark, atmospheric',
                    negative: 'blurry, bright, happy, colorful, watermark'
                },
                animationStyle: 'ken_burns'
            },
            'horror-supernatural': {
                styleBible: {
                    style: 'supernatural horror, otherworldly, gothic atmosphere',
                    colorGrade: 'cold blues, deep shadows, occasional warm accents',
                    lighting: 'moonlight, candlelight, unnatural light sources',
                    atmosphere: 'mist, ancient architecture, supernatural elements',
                    camera: 'slow reveals, creeping dolly, ominous wide shots'
                },
                narratorVoice: 'fable',  // Story-like, mysterious
                audioMood: 'mysterious',
                musicCategory: 'dramatic',
                musicMood: ['dark', 'mysterious', 'epic'],
                technicalSpecs: {
                    positive: '4K, supernatural, gothic, atmospheric, dark, cinematic',
                    negative: 'blurry, modern, bright, happy, watermark'
                },
                animationStyle: 'ken_burns'
            },

            // Tech & Education
            'tech-explainer': {
                styleBible: {
                    style: 'clean modern, minimal, high-tech aesthetic',
                    colorGrade: 'cool blues, clean whites, accent neon highlights',
                    lighting: 'high-key soft lighting, no harsh shadows',
                    atmosphere: 'clean gradient backgrounds, subtle particle effects',
                    camera: 'smooth dolly, symmetrical framing, focus pulls'
                },
                narratorVoice: 'nova',  // Clear, friendly
                audioMood: 'professional',
                musicCategory: 'electronic',
                musicMood: ['professional', 'energetic', 'contemplative'],
                technicalSpecs: {
                    positive: '4K, clean, modern, minimal, high-tech, professional',
                    negative: 'blurry, cluttered, outdated, watermark, text'
                },
                animationStyle: 'ken_burns'
            },
            'educational-general': {
                styleBible: {
                    style: 'educational, clear visuals, engaging graphics',
                    colorGrade: 'vibrant but professional, clear contrast',
                    lighting: 'bright, even lighting, no distracting shadows',
                    atmosphere: 'clean, organized, professional',
                    camera: 'steady, clear framing, emphasis on content'
                },
                narratorVoice: 'alloy',  // Neutral, clear
                audioMood: 'professional',
                musicCategory: 'upbeat',
                musicMood: ['professional', 'energetic', 'hopeful'],
                technicalSpecs: {
                    positive: '4K, educational, clear, engaging, professional',
                    negative: 'blurry, confusing, cluttered, watermark'
                },
                animationStyle: 'ken_burns'
            },

            // Lifestyle & Inspirational
            'lifestyle-wellness': {
                styleBible: {
                    style: 'wellness aesthetic, natural beauty, calming visuals',
                    colorGrade: 'soft pastels, warm earth tones, gentle highlights',
                    lighting: 'soft natural light, golden hour, diffused',
                    atmosphere: 'peaceful, nature elements, organic textures',
                    camera: 'slow gentle movements, intimate framing, breathing room'
                },
                narratorVoice: 'shimmer',  // Calm, soothing
                audioMood: 'contemplative',
                musicCategory: 'calm',
                musicMood: ['contemplative', 'intimate', 'peaceful'],
                technicalSpecs: {
                    positive: '4K, peaceful, natural, calming, wellness, soft lighting',
                    negative: 'blurry, harsh, aggressive, watermark'
                },
                animationStyle: 'ken_burns'
            },
            'inspirational-motivational': {
                styleBible: {
                    style: 'uplifting cinematic, warm and hopeful, epic scale',
                    colorGrade: 'warm golden tones, soft orange highlights, lifted shadows',
                    lighting: 'golden hour, backlit subjects, natural lens flares',
                    atmosphere: 'morning mist, sunbeams, floating particles',
                    camera: 'rising crane shots, slow push-ins, sweeping wide angles'
                },
                narratorVoice: 'onyx',  // Inspiring, powerful
                audioMood: 'hopeful',
                musicCategory: 'cinematic',
                musicMood: ['epic', 'hopeful', 'energetic'],
                technicalSpecs: {
                    positive: '4K, inspirational, uplifting, epic, golden hour, cinematic',
                    negative: 'blurry, dark, depressing, watermark'
                },
                animationStyle: 'ken_burns'
            },

            // Entertainment
            'comedy-sketch': {
                styleBible: {
                    style: 'bright comedy, exaggerated expressions, visual gags',
                    colorGrade: 'saturated, warm, high energy colors',
                    lighting: 'bright even lighting, comedy show feel',
                    atmosphere: 'fun, energetic, playful environments',
                    camera: 'quick cuts, reaction shots, comedic timing'
                },
                narratorVoice: 'alloy',  // Energetic, fun
                audioMood: 'energetic',
                musicCategory: 'upbeat',
                musicMood: ['energetic', 'playful', 'fun'],
                technicalSpecs: {
                    positive: '4K, comedy, bright, fun, energetic, expressive',
                    negative: 'blurry, dark, serious, watermark'
                },
                animationStyle: 'ken_burns'
            },
            'gaming-review': {
                styleBible: {
                    style: 'gaming aesthetic, neon accents, tech-forward',
                    colorGrade: 'high contrast, neon highlights, dark backgrounds',
                    lighting: 'RGB lighting, screen glow, dramatic accents',
                    atmosphere: 'gaming setup, tech elements, digital effects',
                    camera: 'dynamic angles, quick cuts, energetic pacing'
                },
                narratorVoice: 'echo',  // Energetic, engaging
                audioMood: 'energetic',
                musicCategory: 'electronic',
                musicMood: ['energetic', 'intense', 'electronic'],
                technicalSpecs: {
                    positive: '4K, gaming, neon, tech, energetic, modern',
                    negative: 'blurry, outdated, boring, watermark'
                },
                animationStyle: 'ken_burns'
            }
        };

        // Apply production profile based on genre
        function applyGenreProductionProfile(genreId, overrideManual = false) {
            const profile = GENRE_PRODUCTION_PROFILES[genreId];
            if (!profile) {
                console.log(`[Genre Intelligence] No profile found for genre: ${genreId}`);
                return false;
            }

            console.log(`[Genre Intelligence] Applying profile for: ${genreId}`);
            initSceneMemory();

            // 1. Apply Style Bible (only if not manually set or override requested)
            if (overrideManual || !state.storyboard.styleBible?.style) {
                state.storyboard.styleBible = {
                    enabled: true,
                    ...profile.styleBible
                };
                console.log('[Genre Intelligence] Style Bible applied');
            }

            // 2. Apply Technical Specs
            if (overrideManual || !state.storyboard.technicalSpecs?.positive) {
                state.storyboard.technicalSpecs = {
                    enabled: true,
                    ...profile.technicalSpecs
                };
                console.log('[Genre Intelligence] Technical Specs applied');
            }

            // 3. Apply Narrator Voice
            if (overrideManual || !state.animation.narratorVoice || state.animation.narratorVoice === 'nova') {
                state.animation.narratorVoice = profile.narratorVoice;
                state.animation.voiceover.voice = profile.narratorVoice;
                console.log(`[Genre Intelligence] Narrator voice set to: ${profile.narratorVoice}`);
            }

            // 4. Apply Audio Mood
            if (overrideManual || !state.assembly.audioMood) {
                state.assembly.audioMood = profile.audioMood;
                console.log(`[Genre Intelligence] Audio mood set to: ${profile.audioMood}`);
            }

            // 5. Store genre profile for music recommendation
            state.assembly.genreProfile = {
                musicCategory: profile.musicCategory,
                musicMoods: profile.musicMood,
                genreId: genreId
            };

            // 6. Set default animation style
            if (!state.animation.defaultAnimationType) {
                state.animation.defaultAnimationType = profile.animationStyle;
            }

            return true;
        }

        // Get profile-based recommendations for current genre
        function getGenreRecommendations() {
            const genreId = state.content.genre;
            if (!genreId) return null;

            const profile = GENRE_PRODUCTION_PROFILES[genreId];
            if (!profile) return null;

            return {
                genre: genreId,
                styleBible: profile.styleBible,
                narratorVoice: profile.narratorVoice,
                audioMood: profile.audioMood,
                musicCategory: profile.musicCategory,
                musicMoods: profile.musicMood,
                animationStyle: profile.animationStyle
            };
        }

        // Re-apply genre profile with override (for manual re-sync)
        function resyncWithGenre() {
            const genreId = state.content.genre;
            if (!genreId) {
                showToast('No genre selected. Please select a genre first.', 'warning');
                return;
            }

            if (applyGenreProductionProfile(genreId, true)) {
                render();
                scheduleAutoSave();
                showToast(`Production settings synced with "${genreId}" genre`, 'success');
            }
        }

        function setContentFormat(formatId) {
            state.content.contentFormat = formatId;
            render();
            scheduleAutoSave();
        }

        // Phase 3B: Visual Style Control
        function setVisualStyle(property, value) {
            if (!state.storyboard.visualStyle) {
                state.storyboard.visualStyle = {
                    composition: null,
                    lighting: null,
                    colorPalette: null,
                    mood: null
                };
            }

            // Set value (empty string becomes null for "Auto")
            state.storyboard.visualStyle[property] = value || null;

            // If mood is set, it can auto-suggest other settings
            // but we don't override user choices

            render();
            scheduleAutoSave();

            // Show feedback
            const propertyNames = {
                mood: 'Mood',
                lighting: 'Lighting',
                colorPalette: 'Color Palette',
                composition: 'Composition'
            };

            if (value) {
                showToast(`${propertyNames[property]} set to ${value}`, 'success');
            } else {
                showToast(`${propertyNames[property]} set to auto (genre-based)`, 'info');
            }
        }

        // ==========================================
        // Phase 4: SCENE MEMORY SYSTEM
        // 4-Layer Prompt Architecture for Visual Consistency
        // ==========================================

        // Initialize Scene Memory defaults if needed
        function initSceneMemory() {
            if (!state.storyboard.styleBible) {
                state.storyboard.styleBible = {
                    enabled: false,
                    style: '',
                    colorGrade: '',
                    lighting: '',
                    atmosphere: '',
                    camera: ''
                };
            }
            if (!state.storyboard.characterBible) {
                state.storyboard.characterBible = {
                    enabled: false,
                    characters: []
                };
            }
            if (!state.storyboard.technicalSpecs) {
                state.storyboard.technicalSpecs = {
                    enabled: true,
                    positive: '4K, ultra detailed, shallow DOF, cinematic, professional lighting',
                    negative: 'blurry, low quality, watermark, text, logo, deformed, extra fingers, bad anatomy'
                };
            }
            // Phase 8-11: Initialize Prompt Chain Architecture defaults
            if (!state.storyboard.promptChain) {
                state.storyboard.promptChain = {
                    enabled: true,
                    status: 'idle',
                    processedAt: null,
                    scenes: [],
                    config: null
                };
            }
        }

        // Style Bible Management
        function toggleStyleBible(enabled) {
            initSceneMemory();
            state.storyboard.styleBible.enabled = enabled;
            render();
            scheduleAutoSave();
            showToast(enabled ? 'Style Bible enabled' : 'Style Bible disabled', 'info');
        }

        function setStyleBibleField(field, value) {
            initSceneMemory();
            state.storyboard.styleBible[field] = value;
            scheduleAutoSave();
        }

        function openStyleBibleModal() {
            initSceneMemory();
            state.storyboard.showStyleBibleModal = true;
            render();
        }

        function closeStyleBibleModal() {
            state.storyboard.showStyleBibleModal = false;
            render();
        }

        function applyStyleBibleTemplate(templateName) {
            initSceneMemory();
            const templates = {
                'cinematic-thriller': {
                    style: 'ultra-cinematic photoreal, noir thriller, high contrast',
                    colorGrade: 'desaturated teal shadows, amber highlights, crushed blacks',
                    lighting: 'harsh single-source, dramatic rim lights, deep shadows',
                    atmosphere: 'smoke, rain reflections, wet surfaces, urban grit',
                    camera: 'slow dolly, low angles, stabilized gimbal, anamorphic lens feel'
                },
                'documentary-nature': {
                    style: 'cinematic documentary, National Geographic quality, epic landscapes',
                    colorGrade: 'rich earth tones, golden highlights, deep greens',
                    lighting: 'natural golden hour, soft diffused daylight',
                    atmosphere: 'volumetric fog, dust particles, lens flares',
                    camera: 'smooth tracking, wide establishing shots, intimate close-ups'
                },
                'tech-explainer': {
                    style: 'clean modern, minimal, high-tech aesthetic',
                    colorGrade: 'cool blues, clean whites, accent neon highlights',
                    lighting: 'high-key soft lighting, no harsh shadows',
                    atmosphere: 'clean gradient backgrounds, subtle particle effects',
                    camera: 'smooth dolly, symmetrical framing, focus pulls'
                },
                'horror-suspense': {
                    style: 'psychological horror, unsettling, dreamlike quality',
                    colorGrade: 'desaturated, sickly greens, deep blacks, red accents',
                    lighting: 'low-key, single source, harsh shadows, flickering',
                    atmosphere: 'fog, dust motes, decayed textures, uncanny valley',
                    camera: 'dutch angles, slow creeping push-ins, unstable handheld'
                },
                'inspirational': {
                    style: 'uplifting cinematic, warm and hopeful, epic scale',
                    colorGrade: 'warm golden tones, soft orange highlights, lifted shadows',
                    lighting: 'golden hour, backlit subjects, natural lens flares',
                    atmosphere: 'morning mist, sunbeams, floating particles',
                    camera: 'rising crane shots, slow push-ins, sweeping wide angles'
                }
            };

            const template = templates[templateName];
            if (template) {
                state.storyboard.styleBible = {
                    ...state.storyboard.styleBible,
                    enabled: true,
                    ...template
                };
                render();
                scheduleAutoSave();
                showToast(`Applied "${templateName}" style template`, 'success');
            }
        }

        // Character Bible Management
        function toggleCharacterBible(enabled) {
            initSceneMemory();
            state.storyboard.characterBible.enabled = enabled;
            render();
            scheduleAutoSave();
            showToast(enabled ? 'Character Bible enabled' : 'Character Bible disabled', 'info');
        }

        function openCharacterBibleModal() {
            initSceneMemory();
            state.storyboard.showCharacterBibleModal = true;
            state.storyboard.editingCharacterId = null;
            render();
        }

        function closeCharacterBibleModal() {
            state.storyboard.showCharacterBibleModal = false;
            state.storyboard.editingCharacterId = null;
            render();
        }

        function addCharacter() {
            initSceneMemory();
            const newChar = {
                id: 'char-' + Date.now(),
                name: 'New Character',
                description: '',
                referenceImageUrl: null,        // Character portrait image URL
                referenceImageStatus: 'none',   // 'none' | 'generating' | 'ready' | 'error'
                referenceImageBase64: null,     // Base64 for API calls (cached)
                appliedToScenes: [] // Will apply to all scenes if empty
            };
            state.storyboard.characterBible.characters.push(newChar);
            state.storyboard.editingCharacterId = newChar.id;
            render();
            scheduleAutoSave();
        }

        function editCharacter(charId) {
            state.storyboard.editingCharacterId = charId;
            render();
        }

        function updateCharacter(charId, field, value) {
            const char = state.storyboard.characterBible.characters.find(c => c.id === charId);
            if (char) {
                char[field] = value;
                scheduleAutoSave();
            }
        }

        function deleteCharacter(charId) {
            state.storyboard.characterBible.characters =
                state.storyboard.characterBible.characters.filter(c => c.id !== charId);
            if (state.storyboard.editingCharacterId === charId) {
                state.storyboard.editingCharacterId = null;
            }
            render();
            scheduleAutoSave();
            showToast('Character deleted', 'info');
        }

        function toggleCharacterInScene(charId, sceneId) {
            const char = state.storyboard.characterBible.characters.find(c => c.id === charId);
            if (char) {
                if (!char.appliedToScenes) char.appliedToScenes = [];
                const idx = char.appliedToScenes.indexOf(sceneId);
                if (idx >= 0) {
                    char.appliedToScenes.splice(idx, 1);
                } else {
                    char.appliedToScenes.push(sceneId);
                }
                render();
                scheduleAutoSave();
            }
        }

        function applyCharacterToAllScenes(charId) {
            const char = state.storyboard.characterBible.characters.find(c => c.id === charId);
            if (char) {
                // Empty array means applies to all scenes
                char.appliedToScenes = [];
                render();
                scheduleAutoSave();
                showToast(`"${char.name}" will appear in all scenes`, 'success');
            }
        }

        function applyCharacterTemplate(charId, templateName) {
            const templates = {
                'action-hero': {
                    name: 'Action Hero',
                    description: 'Male protagonist, early 30s, athletic muscular build, weathered tan skin, short cropped dark brown hair with grey at temples, 3-day stubble, intense steel-grey eyes, thin scar across left cheekbone, wearing worn charcoal tactical jacket with velcro patches, fitted black cargo pants with utility pockets, brown leather belt, dusty military-style boots, carrying weathered leather satchel'
                },
                'tech-professional': {
                    name: 'Tech Professional',
                    description: 'Female lead, late 20s, slender athletic build, light olive complexion, shoulder-length straight black hair often tucked behind ear, dark brown eyes with sharp focus, minimalist silver earrings, wearing fitted navy blazer over white crew neck t-shirt, high-waisted dark grey wool trousers, clean white sneakers, silver smartwatch on left wrist, thin-frame glasses'
                },
                'mysterious-figure': {
                    name: 'Mysterious Figure',
                    description: 'Gender-ambiguous figure, age indeterminate, tall lean silhouette, face often obscured or in shadow, pale porcelain-like skin when visible, long dark hair that partially covers face, eyes that reflect light unnaturally, wearing floor-length black coat with high collar, dark formless clothing underneath, barefoot or in silent shoes, moves with fluid unnatural grace'
                },
                'narrator': {
                    name: 'Narrator',
                    description: 'Warm and authoritative presence, middle-aged, distinguished appearance, kind eyes that convey wisdom, dressed in timeless casual elegance, natural lighting on face, often shown from shoulders up, calm and trustworthy demeanor'
                }
            };

            const template = templates[templateName];
            const char = state.storyboard.characterBible.characters.find(c => c.id === charId);
            if (template && char) {
                char.name = template.name;
                char.description = template.description;
                render();
                scheduleAutoSave();
                showToast(`Applied "${templateName}" character template`, 'success');
            }
        }

        // ==========================================
        // CHARACTER PORTRAIT / REFERENCE IMAGE
        // Generates a portrait on white/transparent background
        // to use as visual reference for scene generation
        // ==========================================

        async function generateCharacterPortrait(charId) {
            const char = state.storyboard.characterBible.characters.find(c => c.id === charId);
            if (!char) return;

            if (!char.description || char.description.trim().length < 20) {
                showToast('Please add a detailed character description first (at least 20 characters)', 'error');
                return;
            }

            // Update state to show generating
            char.referenceImageStatus = 'generating';
            state.storyboard.generatingPortraitCharId = charId;
            render();

            try {
                // Build a portrait-specific prompt
                const portraitPrompt = buildPortraitPrompt(char);

                // Use Gemini (NanoBanana Pro) for best quality portraits
                // CRITICAL: 5-minute timeout to match server (Gemini can take 60-120s)
                const generateFn = functions.httpsCallable('generateCreativeImage', { timeout: 300000 });
                // Note: Gemini doesn't support negativePrompt as a parameter
                // The backend embeds negative prompts in the prompt text for Gemini
                const result = await generateFn({
                    prompt: portraitPrompt + '\n\nIMPORTANT: Avoid background elements, scenery, props, furniture, other people, crowds. Use clean white background. Avoid text, watermark, blurry, low quality, deformed, bad anatomy, extra limbs.',
                    model: 'nano-banana-pro', // Gemini - supports reference images
                    quantity: 1,
                    aspectRatio: '3:4', // Portrait orientation
                    quality: 'hd'
                });

                if (result.data.success && result.data.images && result.data.images.length > 0) {
                    const imageUrl = result.data.images[0].url;

                    // Fetch the image and convert to base64 for later use
                    const base64Data = await fetchImageAsBase64(imageUrl);

                    char.referenceImageUrl = imageUrl;
                    char.referenceImageBase64 = base64Data;
                    char.referenceImageStatus = 'ready';

                    showToast(`Portrait generated for "${char.name}"!`, 'success');
                    scheduleAutoSave();
                } else {
                    throw new Error(result.data.message || 'No image returned');
                }

            } catch (error) {
                console.error('Portrait generation error:', error);
                char.referenceImageStatus = 'error';
                showToast(`Failed to generate portrait: ${error.message}`, 'error');
            } finally {
                state.storyboard.generatingPortraitCharId = null;
                render();
            }
        }

        function buildPortraitPrompt(char) {
            // Build an optimized prompt for character portrait generation
            // Focus on clean white/neutral background, full body or upper body shot
            const parts = [
                `Professional studio portrait photograph`,
                char.description,
                `Standing pose facing camera`,
                `Clean pure white background`,
                `Professional studio lighting with soft shadows`,
                `High quality, detailed, sharp focus`,
                `Full body visible from head to feet`,
                `Neutral expression, confident pose`,
                `Fashion photography style, catalog quality`
            ];

            return parts.join('. ');
        }

        async function fetchImageAsBase64(imageUrl) {
            try {
                // For Firebase Storage URLs, we can fetch directly
                // For other URLs, we might need CORS handling
                const response = await fetch(imageUrl);
                const blob = await response.blob();

                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        // Remove the data URL prefix to get just base64
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Failed to convert image to base64:', error);
                return null;
            }
        }

        async function uploadCharacterPortrait(charId) {
            const char = state.storyboard.characterBible.characters.find(c => c.id === charId);
            if (!char) return;

            // Create a file input dynamically
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/png,image/jpeg,image/webp';

            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Validate file size (max 5MB)
                if (file.size > 5 * 1024 * 1024) {
                    showToast('Image must be under 5MB', 'error');
                    return;
                }

                char.referenceImageStatus = 'generating';
                render();

                try {
                    // Convert to base64
                    const base64 = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result.split(',')[1]);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });

                    // Upload to Firebase Storage
                    const projectId = state.project.id || 'temp-' + Date.now();
                    const fileName = `creation-projects/${projectId}/characters/${charId}_${Date.now()}.png`;
                    const storageRef = firebase.storage().ref(fileName);

                    // Convert base64 back to blob for upload
                    const byteCharacters = atob(base64);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], { type: file.type });

                    await storageRef.put(blob);
                    const downloadUrl = await storageRef.getDownloadURL();

                    char.referenceImageUrl = downloadUrl;
                    char.referenceImageBase64 = base64;
                    char.referenceImageMimeType = file.type; // Store actual MIME type
                    char.referenceImageStatus = 'ready';

                    showToast(`Portrait uploaded for "${char.name}"!`, 'success');
                    scheduleAutoSave();

                } catch (error) {
                    console.error('Upload error:', error);
                    char.referenceImageStatus = 'error';
                    showToast(`Failed to upload: ${error.message}`, 'error');
                } finally {
                    render();
                }
            };

            input.click();
        }

        function removeCharacterPortrait(charId) {
            const char = state.storyboard.characterBible.characters.find(c => c.id === charId);
            if (!char) return;

            char.referenceImageUrl = null;
            char.referenceImageBase64 = null;
            char.referenceImageStatus = 'none';

            render();
            scheduleAutoSave();
            showToast('Portrait removed', 'info');
        }

        // Get character reference data for scene generation
        function getCharacterReferenceForScene(sceneId) {
            if (!state.storyboard.characterBible?.enabled) {
                console.log('[getCharacterReferenceForScene] Character Bible disabled');
                return null;
            }

            const allChars = state.storyboard.characterBible.characters || [];
            const chars = getCharactersForScene(sceneId);

            // Debug logging
            console.log(`[getCharacterReferenceForScene] Scene "${sceneId}": ${chars.length}/${allChars.length} characters apply to this scene`);
            chars.forEach(c => {
                console.log(`  - "${c.name}": URL=${c.referenceImageUrl ? 'YES' : 'NO'}, Base64=${c.referenceImageBase64 ? 'YES (' + c.referenceImageBase64.substring(0, 20) + '...)' : 'NO'}, Status=${c.referenceImageStatus}`);
            });

            // Find the first character with a reference image
            const charWithRef = chars.find(c => c.referenceImageBase64 && c.referenceImageStatus === 'ready');

            if (charWithRef) {
                console.log(`[getCharacterReferenceForScene] Using "${charWithRef.name}" as reference (base64 length: ${charWithRef.referenceImageBase64.length})`);
                return {
                    base64: charWithRef.referenceImageBase64,
                    mimeType: charWithRef.referenceImageMimeType || 'image/png', // Use stored or default to PNG
                    characterName: charWithRef.name
                };
            }

            console.warn('[getCharacterReferenceForScene] No character with base64 portrait found!');
            return null;
        }

        // ==========================================
        // LOCATION BIBLE MANAGEMENT
        // Ensures location consistency across all scenes with reference images
        // ==========================================

        function toggleLocationBible(enabled) {
            initSceneMemory();
            state.storyboard.locationBible.enabled = enabled;
            render();
            scheduleAutoSave();
            showToast(enabled ? 'Location Bible enabled' : 'Location Bible disabled', 'info');
        }

        function openLocationBibleModal() {
            initSceneMemory();
            state.storyboard.showLocationBibleModal = true;
            state.storyboard.editingLocationId = null;
            render();
        }

        function closeLocationBibleModal() {
            state.storyboard.showLocationBibleModal = false;
            state.storyboard.editingLocationId = null;
            render();
        }

        function addLocation() {
            initSceneMemory();
            const newLocation = {
                id: 'loc-' + Date.now(),
                name: 'New Location',
                description: '',
                type: 'exterior',           // exterior | interior | abstract
                timeOfDay: 'day',           // day | night | dawn | dusk | golden-hour
                weather: 'clear',           // clear | cloudy | rainy | foggy | stormy
                mood: 'neutral',            // tense | peaceful | mysterious | energetic | neutral
                referenceImageUrl: null,
                referenceImageBase64: null,
                referenceImageStatus: 'none', // none | generating | ready | error
                referenceImageMimeType: 'image/png',
                lightingStyle: '',
                keyElements: [],
                appliedToScenes: []         // Empty = all scenes
            };
            state.storyboard.locationBible.locations.push(newLocation);
            state.storyboard.editingLocationId = newLocation.id;
            render();
            scheduleAutoSave();
        }

        function editLocation(locationId) {
            state.storyboard.editingLocationId = locationId;
            render();
        }

        function updateLocation(locationId, field, value) {
            const location = state.storyboard.locationBible.locations.find(l => l.id === locationId);
            if (location) {
                location[field] = value;
                scheduleAutoSave();
            }
        }

        function deleteLocation(locationId) {
            state.storyboard.locationBible.locations =
                state.storyboard.locationBible.locations.filter(l => l.id !== locationId);
            if (state.storyboard.editingLocationId === locationId) {
                state.storyboard.editingLocationId = null;
            }
            render();
            scheduleAutoSave();
            showToast('Location deleted', 'info');
        }

        function toggleLocationInScene(locationId, sceneId) {
            const location = state.storyboard.locationBible.locations.find(l => l.id === locationId);
            if (location) {
                if (!location.appliedToScenes) {
                    location.appliedToScenes = [];
                }
                const idx = location.appliedToScenes.indexOf(sceneId);
                if (idx >= 0) {
                    location.appliedToScenes.splice(idx, 1);
                } else {
                    location.appliedToScenes.push(sceneId);
                }
                render();
                scheduleAutoSave();
            }
        }

        function applyLocationToAllScenes(locationId) {
            const location = state.storyboard.locationBible.locations.find(l => l.id === locationId);
            if (location) {
                location.appliedToScenes = []; // Empty means all scenes
                render();
                scheduleAutoSave();
                showToast(`${location.name} applied to all scenes`, 'success');
            }
        }

        // Build optimized prompt for location reference image generation
        function buildLocationPrompt(location) {
            const parts = [];

            // Core environment
            const typeLabel = location.type === 'exterior' ? 'EXTERIOR' :
                              location.type === 'interior' ? 'INTERIOR' : 'ABSTRACT';
            parts.push(`EMPTY ${typeLabel} ENVIRONMENT:`);

            if (location.description) {
                parts.push(location.description);
            } else {
                parts.push(location.name);
            }

            // Time and conditions
            const timeMap = {
                'day': 'bright daylight, midday sun',
                'night': 'nighttime, moonlight and artificial lights',
                'dawn': 'early dawn, soft pink and orange sky',
                'dusk': 'dusk, golden sunset colors',
                'golden-hour': 'golden hour, warm directional sunlight'
            };
            parts.push(`TIME: ${timeMap[location.timeOfDay] || 'natural lighting'}`);

            const weatherMap = {
                'clear': 'clear skies',
                'cloudy': 'overcast, diffused light',
                'rainy': 'rain, wet surfaces, reflections',
                'foggy': 'fog, atmospheric haze, limited visibility',
                'stormy': 'storm, dramatic clouds, moody lighting'
            };
            if (location.weather && location.weather !== 'clear') {
                parts.push(`WEATHER: ${weatherMap[location.weather]}`);
            }

            // Mood affects lighting
            const moodMap = {
                'tense': 'high contrast, dramatic shadows',
                'peaceful': 'soft, even lighting, serene',
                'mysterious': 'shadows, pools of light, intrigue',
                'energetic': 'vibrant, dynamic lighting',
                'neutral': 'balanced, natural lighting'
            };
            parts.push(`MOOD: ${moodMap[location.mood] || 'atmospheric'}`);

            // Custom lighting if specified
            if (location.lightingStyle) {
                parts.push(`LIGHTING STYLE: ${location.lightingStyle}`);
            }

            // Key elements
            if (location.keyElements && location.keyElements.length > 0) {
                parts.push(`KEY ELEMENTS: ${location.keyElements.join(', ')}`);
            }

            // Critical - no people
            parts.push('');
            parts.push('CRITICAL: NO PEOPLE, NO CHARACTERS, NO FIGURES, NO HUMAN SILHOUETTES.');
            parts.push('Generate an EMPTY environment suitable for character compositing.');

            // Technical quality
            parts.push('');
            parts.push('TECHNICAL: Photorealistic, cinematic composition, 8K detail, professional cinematography.');
            parts.push('Shot on Arri Alexa Mini LF, anamorphic lens, subtle film grain, HDR range.');
            parts.push('16:9 aspect ratio, wide establishing shot showing full environment.');

            return parts.join('\n');
        }

        // Generate location reference image using NanoBananaPro
        async function generateLocationReference(locationId) {
            const location = state.storyboard.locationBible.locations.find(l => l.id === locationId);
            if (!location) {
                showToast('Location not found', 'error');
                return;
            }

            // Check if description is sufficient
            if (!location.description && location.name === 'New Location') {
                showToast('Please add a name or description first', 'error');
                return;
            }

            location.referenceImageStatus = 'generating';
            state.storyboard.generatingLocationRefId = locationId;
            render();

            try {
                // Build optimized location prompt
                const prompt = buildLocationPrompt(location);
                console.log('[Location Bible] Generating reference for:', location.name);
                console.log('[Location Bible] Prompt:', prompt);

                // Generate using NanoBananaPro (no character reference - pure environment)
                const generateFn = functions.httpsCallable('generateCreativeImage', { timeout: 120000 });
                const result = await generateFn({
                    prompt: prompt,
                    model: 'nanobanana-pro',
                    quantity: 1,
                    aspectRatio: '16:9',
                    quality: 'hd',
                    negativePrompt: 'people, humans, figures, silhouettes, characters, person, man, woman, child, crowd, faces, bodies, hands, feet, blurry, low quality, watermark, text'
                });

                if (result.data.success && result.data.images && result.data.images.length > 0) {
                    const imageUrl = result.data.images[0].url;
                    location.referenceImageUrl = imageUrl;

                    // Fetch and convert to base64 for API usage
                    const base64 = await fetchImageAsBase64(imageUrl);
                    location.referenceImageBase64 = base64;
                    location.referenceImageStatus = 'ready';

                    showToast(`${location.name} reference generated!`, 'success');
                    console.log('[Location Bible] Reference generated:', imageUrl);
                } else {
                    throw new Error(result.data.error || 'No image generated');
                }

            } catch (error) {
                console.error('[Location Bible] Generation error:', error);
                location.referenceImageStatus = 'error';
                showToast(`Failed to generate: ${error.message}`, 'error');
            } finally {
                state.storyboard.generatingLocationRefId = null;
                render();
                scheduleAutoSave();
            }
        }

        // Upload custom location reference image
        async function uploadLocationReference(locationId) {
            const location = state.storyboard.locationBible.locations.find(l => l.id === locationId);
            if (!location) return;

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Validate file size (max 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    showToast('Image too large (max 10MB)', 'error');
                    return;
                }

                location.referenceImageStatus = 'generating';
                render();

                try {
                    // Read as base64
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        const dataUrl = event.target.result;

                        // Extract base64 and mime type
                        const matches = dataUrl.match(/^data:([^;]+);base64,(.+)$/);
                        if (!matches) {
                            throw new Error('Invalid image format');
                        }

                        location.referenceImageMimeType = matches[1];
                        location.referenceImageBase64 = matches[2];
                        location.referenceImageUrl = dataUrl; // Use data URL for display
                        location.referenceImageStatus = 'ready';

                        render();
                        scheduleAutoSave();
                        showToast('Location image uploaded!', 'success');
                    };
                    reader.onerror = () => {
                        throw new Error('Failed to read file');
                    };
                    reader.readAsDataURL(file);

                } catch (error) {
                    console.error('[Location Bible] Upload error:', error);
                    location.referenceImageStatus = 'error';
                    showToast(`Upload failed: ${error.message}`, 'error');
                    render();
                }
            };
            input.click();
        }

        function removeLocationReference(locationId) {
            const location = state.storyboard.locationBible.locations.find(l => l.id === locationId);
            if (!location) return;

            location.referenceImageUrl = null;
            location.referenceImageBase64 = null;
            location.referenceImageStatus = 'none';

            render();
            scheduleAutoSave();
            showToast('Location reference removed', 'info');
        }

        // Get location reference data for scene generation
        // PRIORITY: 1) Specific scene assignment  2) "Apply to all" fallback
        function getLocationReferenceForScene(sceneId) {
            if (!state.storyboard.locationBible?.enabled) {
                console.log('[getLocationReferenceForScene] Location Bible disabled');
                return null;
            }

            const allLocations = state.storyboard.locationBible.locations || [];

            // Filter to only locations with ready reference images
            const readyLocations = allLocations.filter(loc =>
                loc.referenceImageBase64 && loc.referenceImageStatus === 'ready'
            );

            if (readyLocations.length === 0) {
                console.log(`[getLocationReferenceForScene] No locations with ready reference images`);
                return null;
            }

            // Helper to check if a location is assigned to a specific scene
            // Supports both appliedToScenes (new) and scenesUsed (legacy)
            const isAssignedToScene = (loc, sid) => {
                const assigned = loc.appliedToScenes || loc.scenesUsed || [];
                return assigned.length > 0 && assigned.includes(sid);
            };

            // Helper to check if location applies to all scenes (empty array)
            const appliesToAll = (loc) => {
                const assigned = loc.appliedToScenes || loc.scenesUsed;
                return !assigned || assigned.length === 0;
            };

            // PRIORITY 1: Look for location with SPECIFIC scene assignment for this scene
            const specificLocation = readyLocations.find(loc => isAssignedToScene(loc, sceneId));

            if (specificLocation) {
                console.log(`[getLocationReferenceForScene] Scene "${sceneId}" using SPECIFIC location: "${specificLocation.name}"`);
                return formatLocationRef(specificLocation);
            }

            // PRIORITY 2: Fall back to "apply to all" locations (empty appliedToScenes)
            const globalLocation = readyLocations.find(loc => appliesToAll(loc));

            if (globalLocation) {
                console.log(`[getLocationReferenceForScene] Scene "${sceneId}" using GLOBAL location: "${globalLocation.name}"`);
                return formatLocationRef(globalLocation);
            }

            console.log(`[getLocationReferenceForScene] No location reference for scene "${sceneId}"`);
            return null;
        }

        // Helper to format location reference object
        function formatLocationRef(location) {
            return {
                base64: location.referenceImageBase64,
                mimeType: location.referenceImageMimeType || 'image/png',
                locationName: location.name,
                locationDescription: location.description,
                lightingStyle: location.lightingStyle,
                timeOfDay: location.timeOfDay,
                weather: location.weather,
                mood: location.mood
            };
        }

        // Get all locations assigned to a scene
        // Returns array sorted by priority: specific assignments first, then "apply to all"
        // Supports both appliedToScenes (new) and scenesUsed (legacy)
        function getLocationsForScene(sceneId) {
            if (!state.storyboard.locationBible?.enabled) return [];
            const locations = state.storyboard.locationBible.locations || [];

            // Helper to get scene assignment array (supports both field names)
            const getAssigned = (loc) => loc.appliedToScenes || loc.scenesUsed || [];

            // Get all matching locations
            const matching = locations.filter(loc => {
                const assigned = getAssigned(loc);
                const includeInAll = assigned.length === 0;
                const includeInScene = assigned.includes(sceneId);
                return includeInAll || includeInScene;
            });

            // Sort by priority: specific assignments first, then "apply to all"
            return matching.sort((a, b) => {
                const aAssigned = getAssigned(a);
                const bAssigned = getAssigned(b);
                const aSpecific = aAssigned.length > 0 && aAssigned.includes(sceneId);
                const bSpecific = bAssigned.length > 0 && bAssigned.includes(sceneId);
                if (aSpecific && !bSpecific) return -1; // a has priority
                if (!aSpecific && bSpecific) return 1;  // b has priority
                return 0; // same priority, keep original order
            });
        }

        // ==========================================
        // AUTO-EXTRACT LOCATIONS FROM SCRIPT
        // Analyzes the script and creates location entries automatically
        // ==========================================

        async function extractLocationsFromScript() {
            const script = state.content.script || '';
            const scenes = state.storyboard.scenes || [];

            if (!script && scenes.length === 0) {
                showToast('No script or scenes to analyze', 'error');
                return;
            }

            showToast('Analyzing script for locations...', 'info');

            try {
                // Combine all text sources
                let textToAnalyze = script + '\n\n';
                scenes.forEach((scene, idx) => {
                    textToAnalyze += `Scene ${idx + 1}: ${scene.description || ''}\n`;
                    if (scene.action) textToAnalyze += `Action: ${scene.action}\n`;
                    if (scene.imagePrompt) textToAnalyze += `Visual: ${scene.imagePrompt}\n`;
                });

                // Use regex patterns to extract location hints
                const locationPatterns = [
                    // Interior locations
                    /(?:inside|within|in)\s+(?:a|the|an)?\s*([^,.]+(?:room|office|lab|kitchen|bedroom|studio|warehouse|factory|chamber|corridor|hall|apartment|house|building|facility|station|headquarters|cockpit|cabin|garage|basement|attic))/gi,
                    // Exterior locations
                    /(?:outside|on|at|near|beside|overlooking)\s+(?:a|the|an)?\s*([^,.]+(?:street|rooftop|park|plaza|forest|beach|mountain|city|alley|bridge|garden|field|desert|ocean|lake|river|highway|road|path|trail|cliff|valley|canyon))/gi,
                    // Setting patterns
                    /(?:the|a|an)\s+([^,.]+(?:metropolis|landscape|skyline|horizon|wasteland|jungle|tundra|swamp|marsh|cave|ruins|temple|castle|palace|fortress|tower|arena|stadium|market|bazaar|harbor|port|dock))/gi,
                    // Sci-fi/fantasy
                    /(?:aboard|inside)\s+(?:a|the)?\s*([^,.]+(?:spacecraft|spaceship|station|ship|vessel|starship|cruiser|freighter))/gi,
                    // Generic environment descriptors
                    /(?:dark|bright|neon|urban|rural|futuristic|ancient|modern|abandoned)\s+([^,.]+(?:environment|setting|world|realm|dimension|sector|zone|district|quarter))/gi
                ];

                const extractedLocations = new Set();
                const locationDetails = [];

                locationPatterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(textToAnalyze)) !== null) {
                        const locationName = match[1].trim();
                        // Clean up and normalize
                        const cleanName = locationName
                            .replace(/\b(the|a|an)\b/gi, '')
                            .replace(/\s+/g, ' ')
                            .trim();

                        if (cleanName.length > 2 && cleanName.length < 50 && !extractedLocations.has(cleanName.toLowerCase())) {
                            extractedLocations.add(cleanName.toLowerCase());

                            // Determine type
                            const isInterior = /room|office|lab|kitchen|bedroom|studio|warehouse|factory|chamber|corridor|hall|apartment|house|building|facility|cockpit|cabin|garage|basement|attic|aboard|inside/i.test(match[0]);

                            // Guess time of day from context
                            let timeOfDay = 'day';
                            const contextStart = Math.max(0, match.index - 100);
                            const contextEnd = Math.min(textToAnalyze.length, match.index + match[0].length + 100);
                            const context = textToAnalyze.substring(contextStart, contextEnd).toLowerCase();

                            if (context.includes('night') || context.includes('midnight') || context.includes('dark')) {
                                timeOfDay = 'night';
                            } else if (context.includes('sunset') || context.includes('dusk') || context.includes('evening')) {
                                timeOfDay = 'dusk';
                            } else if (context.includes('sunrise') || context.includes('dawn') || context.includes('morning')) {
                                timeOfDay = 'dawn';
                            } else if (context.includes('golden hour')) {
                                timeOfDay = 'golden-hour';
                            }

                            // Guess weather
                            let weather = 'clear';
                            if (context.includes('rain') || context.includes('storm') || context.includes('wet')) {
                                weather = 'rainy';
                            } else if (context.includes('fog') || context.includes('mist') || context.includes('haze')) {
                                weather = 'foggy';
                            } else if (context.includes('cloud') || context.includes('overcast')) {
                                weather = 'cloudy';
                            }

                            // Guess mood
                            let mood = 'neutral';
                            if (context.includes('tense') || context.includes('danger') || context.includes('threat')) {
                                mood = 'tense';
                            } else if (context.includes('peace') || context.includes('calm') || context.includes('serene')) {
                                mood = 'peaceful';
                            } else if (context.includes('myster') || context.includes('strange') || context.includes('eerie')) {
                                mood = 'mysterious';
                            } else if (context.includes('excit') || context.includes('action') || context.includes('energy')) {
                                mood = 'energetic';
                            }

                            locationDetails.push({
                                name: cleanName.charAt(0).toUpperCase() + cleanName.slice(1),
                                type: isInterior ? 'interior' : 'exterior',
                                timeOfDay: timeOfDay,
                                weather: weather,
                                mood: mood,
                                description: `${isInterior ? 'Interior:' : 'Exterior:'} ${cleanName}`
                            });
                        }
                    }
                });

                if (locationDetails.length === 0) {
                    showToast('No distinct locations found in script', 'info');
                    return;
                }

                // Add extracted locations to Location Bible
                initSceneMemory();
                let addedCount = 0;
                locationDetails.forEach(locData => {
                    // Check if similar location already exists
                    const exists = state.storyboard.locationBible.locations.some(
                        existing => existing.name.toLowerCase() === locData.name.toLowerCase()
                    );

                    if (!exists) {
                        const newLocation = {
                            id: 'loc-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5),
                            name: locData.name,
                            description: locData.description,
                            type: locData.type,
                            timeOfDay: locData.timeOfDay,
                            weather: locData.weather,
                            mood: locData.mood,
                            referenceImageUrl: null,
                            referenceImageBase64: null,
                            referenceImageStatus: 'none',
                            referenceImageMimeType: 'image/png',
                            lightingStyle: '',
                            keyElements: [],
                            appliedToScenes: []
                        };
                        state.storyboard.locationBible.locations.push(newLocation);
                        addedCount++;
                    }
                });

                state.storyboard.locationBible.autoDetected = true;
                render();
                scheduleAutoSave();
                showToast(`Found ${addedCount} new location(s)!`, 'success');

            } catch (error) {
                console.error('[Location Bible] Extraction error:', error);
                showToast(`Failed to extract locations: ${error.message}`, 'error');
            }
        }

        // Apply location template preset
        function applyLocationTemplate(locationId, templateName) {
            const location = state.storyboard.locationBible.locations.find(l => l.id === locationId);
            if (!location) return;

            const templates = {
                'urban-night': {
                    name: 'Urban Night Street',
                    description: 'Neon-lit city street at night, wet pavement reflecting colorful lights, tall buildings with glowing windows, steam rising from vents, cinematic urban atmosphere',
                    type: 'exterior',
                    timeOfDay: 'night',
                    weather: 'clear',
                    mood: 'mysterious',
                    lightingStyle: 'Neon signs, streetlights, wet surface reflections, deep shadows',
                    keyElements: ['neon signs', 'wet pavement', 'tall buildings', 'steam vents', 'street lights']
                },
                'forest-day': {
                    name: 'Forest Clearing',
                    description: 'Sunlit forest clearing with ancient trees, dappled light filtering through leaves, moss-covered rocks, peaceful natural atmosphere',
                    type: 'exterior',
                    timeOfDay: 'day',
                    weather: 'clear',
                    mood: 'peaceful',
                    lightingStyle: 'Dappled sunlight through tree canopy, soft ambient fill',
                    keyElements: ['ancient trees', 'moss', 'filtered sunlight', 'forest floor', 'ferns']
                },
                'tech-lab': {
                    name: 'High-Tech Laboratory',
                    description: 'Futuristic research laboratory with holographic displays, clean white surfaces, glass partitions, advanced equipment, controlled lighting',
                    type: 'interior',
                    timeOfDay: 'day',
                    weather: 'clear',
                    mood: 'neutral',
                    lightingStyle: 'Cool LED overhead lighting, screen glow, sterile white ambiance',
                    keyElements: ['holographic displays', 'glass walls', 'lab equipment', 'workstations', 'data screens']
                },
                'desert-sunset': {
                    name: 'Desert at Sunset',
                    description: 'Vast desert landscape at golden hour, dramatic rock formations, endless sand dunes, warm orange sky, epic scale',
                    type: 'exterior',
                    timeOfDay: 'golden-hour',
                    weather: 'clear',
                    mood: 'peaceful',
                    lightingStyle: 'Golden directional sunlight, long shadows, warm color temperature',
                    keyElements: ['sand dunes', 'rock formations', 'orange sky', 'desert plants', 'distant mountains']
                },
                'industrial': {
                    name: 'Industrial Complex',
                    description: 'Abandoned industrial facility, rusted metal structures, broken windows, dramatic shafts of light, gritty atmosphere',
                    type: 'interior',
                    timeOfDay: 'day',
                    weather: 'cloudy',
                    mood: 'tense',
                    lightingStyle: 'Harsh directional light through broken windows, deep shadows',
                    keyElements: ['rusted metal', 'broken windows', 'concrete floors', 'machinery', 'debris']
                },
                'space-station': {
                    name: 'Space Station Interior',
                    description: 'Futuristic space station corridor, curved walls, viewport windows showing stars, ambient blue lighting, high-tech panels',
                    type: 'interior',
                    timeOfDay: 'night',
                    weather: 'clear',
                    mood: 'mysterious',
                    lightingStyle: 'Cool blue ambient lighting, viewport starlight, panel illumination',
                    keyElements: ['curved corridors', 'viewports', 'control panels', 'airlock doors', 'stars visible']
                }
            };

            const template = templates[templateName];
            if (template) {
                Object.assign(location, template);
                // Keep the existing ID
                location.id = locationId;
                // Reset image (template changed, old image may not match)
                location.referenceImageUrl = null;
                location.referenceImageBase64 = null;
                location.referenceImageStatus = 'none';

                render();
                scheduleAutoSave();
                showToast(`Applied "${template.name}" template`, 'success');
            }
        }

        // ==========================================
        // AUTO-EXTRACT CHARACTERS FROM SCRIPT
        // Analyzes the script and creates character entries automatically
        // ==========================================

        async function extractCharactersFromScript() {
            if (!state.script.scenes || state.script.scenes.length === 0) {
                console.log('[Auto-Extract] No scenes to analyze');
                return { success: false, count: 0 };
            }

            console.log('[Auto-Extract] Starting character extraction from script...');

            try {
                const extractFn = functions.httpsCallable('creationWizardExtractCharacters');
                const result = await extractFn({
                    script: {
                        title: state.script.title,
                        scenes: state.script.scenes
                    },
                    genre: state.content.genre || null,
                    productionMode: state.content.productionMode || 'standard',
                    styleBible: state.storyboard.styleBible?.enabled ? state.storyboard.styleBible : null
                });

                if (result.data.success && result.data.characters && result.data.characters.length > 0) {
                    // Initialize Scene Memory if needed
                    initSceneMemory();

                    // Enable Character Bible
                    state.storyboard.characterBible.enabled = true;

                    // Add extracted characters (avoid duplicates by name)
                    const existingNames = state.storyboard.characterBible.characters.map(c => c.name.toLowerCase());

                    let addedCount = 0;
                    for (const char of result.data.characters) {
                        if (!existingNames.includes(char.name.toLowerCase())) {
                            state.storyboard.characterBible.characters.push(char);
                            existingNames.push(char.name.toLowerCase());
                            addedCount++;
                        }
                    }

                    console.log(`[Auto-Extract] Added ${addedCount} characters to Character Bible`);

                    if (result.data.suggestedStyleNote) {
                        console.log(`[Auto-Extract] Style note: ${result.data.suggestedStyleNote}`);
                    }

                    return {
                        success: true,
                        count: addedCount,
                        total: result.data.characters.length,
                        hasHumanCharacters: result.data.hasHumanCharacters
                    };
                } else if (!result.data.hasHumanCharacters) {
                    console.log('[Auto-Extract] No human characters detected in script');
                    return {
                        success: true,
                        count: 0,
                        hasHumanCharacters: false,
                        note: result.data.suggestedStyleNote
                    };
                }

                return { success: false, count: 0 };

            } catch (error) {
                console.error('[Auto-Extract] Error extracting characters:', error);
                return { success: false, count: 0, error: error.message };
            }
        }

        // Manual trigger to re-analyze script for characters
        async function reanalyzeScriptForCharacters() {
            if (!state.script.scenes || state.script.scenes.length === 0) {
                showToast('Generate a script first before analyzing for characters', 'warning');
                return;
            }

            showToast('Analyzing script for characters...', 'info');

            const result = await extractCharactersFromScript();

            if (result.success && result.count > 0) {
                showToast(`Found ${result.count} character(s) and added to Character Bible!`, 'success');
                render();
                scheduleAutoSave();
            } else if (result.success && !result.hasHumanCharacters) {
                showToast('No human characters detected in this script', 'info');
            } else if (result.success && result.count === 0) {
                showToast('Characters already in Bible or no new characters found', 'info');
            } else {
                showToast('Could not analyze script for characters', 'error');
            }
        }

        // Refresh character portrait base64 from URLs after project load
        // This avoids storing large base64 data in Firestore
        async function refreshCharacterPortraitBase64() {
            if (!state.storyboard.characterBible?.characters) return;

            const characters = state.storyboard.characterBible.characters;

            for (const char of characters) {
                // If character has a portrait URL but no base64, fetch and convert
                if (char.referenceImageUrl && char.referenceImageStatus === 'ready' && !char.referenceImageBase64) {
                    try {
                        console.log(`[Character Bible] Refreshing base64 for "${char.name}"`);
                        const base64 = await fetchImageAsBase64(char.referenceImageUrl);
                        if (base64) {
                            char.referenceImageBase64 = base64;
                        }
                    } catch (error) {
                        console.warn(`[Character Bible] Failed to refresh base64 for "${char.name}":`, error);
                    }
                }
            }
        }

        /**
         * Refresh location reference images from URLs after project load
         * Base64 data is stripped during save to prevent payload size issues
         * This restores the base64 data needed for image generation
         */
        async function refreshLocationReferenceBase64() {
            if (!state.storyboard.locationBible?.locations) return;

            const locations = state.storyboard.locationBible.locations;

            for (const loc of locations) {
                // If location has a reference URL but no base64, fetch and convert
                if (loc.referenceImageUrl && loc.referenceImageStatus === 'ready' && !loc.referenceImageBase64) {
                    try {
                        console.log(`[Location Bible] Refreshing base64 for "${loc.name}"`);
                        const base64 = await fetchImageAsBase64(loc.referenceImageUrl);
                        if (base64) {
                            loc.referenceImageBase64 = base64;
                        }
                    } catch (error) {
                        console.warn(`[Location Bible] Failed to refresh base64 for "${loc.name}":`, error);
                    }
                }
            }
        }

        // ==========================================
        // AUTO-POPULATE LOCATION BIBLE FROM SCRIPT
        // Extracts unique locations and builds consistency data
        // ==========================================
        function autoPopulateLocationBible(script) {
            if (!script || !script.scenes) return;

            initSceneMemory();

            // Check if script already has locations array (new format)
            if (script.locations && Array.isArray(script.locations) && script.locations.length > 0) {
                // Use locations from script directly
                // CRITICAL: Use appliedToScenes (not scenesUsed) so getLocationReferenceForScene works
                state.storyboard.locationBible.locations = script.locations.map(loc => ({
                    id: `loc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: loc.name,
                    description: loc.description || '',
                    type: loc.type || 'exterior',
                    timeOfDay: loc.timeOfDay || 'day',
                    weather: loc.weather || 'clear',
                    mood: loc.mood || loc.atmosphere || 'neutral',
                    referenceImageUrl: null,
                    referenceImageBase64: null,
                    referenceImageStatus: 'none',
                    referenceImageMimeType: 'image/png',
                    lightingStyle: loc.lightingStyle || '',
                    keyElements: loc.keyElements || [],
                    // CRITICAL: Use appliedToScenes for scene assignment (scenesUsed is legacy)
                    appliedToScenes: loc.appliedToScenes || loc.scenesUsed || []
                }));
                state.storyboard.locationBible.enabled = true;
                state.storyboard.locationBible.autoPopulated = true;
                console.log(`[Location Bible] Loaded ${state.storyboard.locationBible.locations.length} locations from script with scene assignments`);
                return;
            }

            // Fallback: Extract locations from scene data
            const locationMap = new Map();

            for (const scene of script.scenes) {
                let locationName = null;
                let locationType = 'exterior';
                let locationDescription = '';

                // Try to get location from scene.location object (new format)
                if (scene.location && typeof scene.location === 'object' && scene.location.name) {
                    locationName = scene.location.name;
                    locationType = scene.location.type || 'exterior';
                    locationDescription = scene.location.description || '';
                }
                // Fallback: infer from visual description
                else if (scene.visual || scene.visualPrompt) {
                    // Ensure we pass a string to inferLocationFromVisual
                    const visualText = scene.visual || scene.visualPrompt;
                    const visualString = typeof visualText === 'string' ? visualText : '';
                    locationName = inferLocationFromVisual(visualString);
                }

                if (locationName && locationName !== 'unknown') {
                    const normalizedName = locationName.toLowerCase().trim();

                    if (!locationMap.has(normalizedName)) {
                        locationMap.set(normalizedName, {
                            id: `loc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            name: locationName,
                            description: locationDescription,
                            type: locationType,
                            timeOfDay: 'day',
                            weather: 'clear',
                            mood: 'neutral',
                            referenceImageUrl: null,
                            referenceImageBase64: null,
                            referenceImageStatus: 'none',
                            referenceImageMimeType: 'image/png',
                            lightingStyle: '',
                            keyElements: [],
                            // CRITICAL: Use appliedToScenes for scene assignment
                            appliedToScenes: []
                        });
                    }

                    const loc = locationMap.get(normalizedName);
                    // Add this scene to the location's appliedToScenes
                    if (!loc.appliedToScenes.includes(scene.id)) {
                        loc.appliedToScenes.push(scene.id);
                    }
                }
            }

            if (locationMap.size > 0) {
                state.storyboard.locationBible.locations = Array.from(locationMap.values());
                state.storyboard.locationBible.enabled = true;
                state.storyboard.locationBible.autoPopulated = true;
                console.log(`[Location Bible] Extracted ${locationMap.size} locations from script:`);
                locationMap.forEach((loc, name) => {
                    console.log(`  - "${loc.name}"  scenes: [${loc.appliedToScenes.join(', ')}]`);
                });
            }
        }

        // Infer location name from visual description (client-side version)
        function inferLocationFromVisual(visual) {
            // Defensive check: ensure visual is a string
            if (!visual || typeof visual !== 'string') return 'unknown';
            const v = visual.toLowerCase();

            const patterns = [
                { regex: /\b(dojo|training hall|martial arts)\b/i, name: 'The Dojo' },
                { regex: /\b(office|corporate|boardroom|conference|tower)\b/i, name: 'Corporate Office' },
                { regex: /\b(warehouse|factory|industrial|abandoned)\b/i, name: 'Abandoned Warehouse' },
                { regex: /\b(forest|woods|trees|jungle|rainforest)\b/i, name: 'The Forest' },
                { regex: /\b(street|alley|urban|city)\b/i, name: 'City Streets' },
                { regex: /\b(rooftop|roof|skyline)\b/i, name: 'Rooftop' },
                { regex: /\b(beach|shore|coast|ocean|sea)\b/i, name: 'The Beach' },
                { regex: /\b(lab|laboratory|research|science)\b/i, name: 'The Laboratory' },
                { regex: /\b(home|house|apartment|living room|bedroom)\b/i, name: 'Home' },
                { regex: /\b(hospital|medical|clinic)\b/i, name: 'Hospital' },
                { regex: /\b(bar|club|restaurant|cafe)\b/i, name: 'The Bar' },
                { regex: /\b(castle|fortress|palace|throne)\b/i, name: 'The Castle' },
                { regex: /\b(cave|cavern|underground)\b/i, name: 'The Cave' },
                { regex: /\b(mountain|peak|summit|cliff)\b/i, name: 'The Mountain' }
            ];

            for (const { regex, name } of patterns) {
                if (regex.test(v)) return name;
            }

            return 'unknown';
        }

        // ==========================================
        // AUTO-POPULATE STYLE BIBLE FROM SCRIPT
        // Uses styleBible data if script provides it
        // ==========================================
        function autoPopulateStyleBible(script) {
            if (!script) return;

            initSceneMemory();

            // Check if script has styleBible data (new format)
            if (script.styleBible) {
                const sb = script.styleBible;

                // Only update if Style Bible is not already customized
                if (!state.storyboard.styleBible.style) {
                    if (sb.visualStyle) state.storyboard.styleBible.style = sb.visualStyle;
                    if (sb.colorGrade) state.storyboard.styleBible.colorGrade = sb.colorGrade;
                    if (sb.lighting) state.storyboard.styleBible.lighting = sb.lighting;
                    if (sb.atmosphere) state.storyboard.styleBible.atmosphere = sb.atmosphere;
                    if (sb.cameraLanguage) state.storyboard.styleBible.camera = sb.cameraLanguage;

                    // Enable Style Bible if we have data
                    if (sb.visualStyle || sb.colorGrade || sb.lighting) {
                        state.storyboard.styleBible.enabled = true;
                        console.log('[Style Bible] Auto-populated from script data');
                    }
                }
            }
        }

        // Technical Specs Management
        function toggleTechnicalSpecs(enabled) {
            initSceneMemory();
            state.storyboard.technicalSpecs.enabled = enabled;
            render();
            scheduleAutoSave();
        }

        function setTechnicalSpec(field, value) {
            initSceneMemory();
            state.storyboard.technicalSpecs[field] = value;
            scheduleAutoSave();
        }

        // Assemble the full prompt using SCENE-FOCUSED architecture
        // CRITICAL: Character reference images handle visual consistency - prompts describe WHAT'S HAPPENING
        function assembleScenePrompt(scene) {
            initSceneMemory();
            const parts = [];

            // Layer 1: SCENE CONTENT (PRIMARY - the action happening)
            // This is the most important layer - what's actually happening in the scene
            if (scene.visual || scene.visualPrompt) {
                const sceneContent = scene.visual || scene.visualPrompt;
                // Remove camera brackets for cleaner prompt
                const cleanedContent = sceneContent.replace(/\[.*?\]\s*/, '').trim();
                if (cleanedContent) {
                    parts.push(cleanedContent);
                }
            }

            // Layer 2: Scene Action (if available from script)
            if (scene.sceneAction && !parts[0]?.toLowerCase().includes(scene.sceneAction.toLowerCase().substring(0, 15))) {
                parts.push(`ACTION: ${scene.sceneAction}`);
            }

            // Layer 3: Location Context (from Location Bible if available)
            // CRITICAL: Include full visual description, not just key elements!
            if (scene.location && typeof scene.location === 'object') {
                const loc = scene.location;
                const locationParts = [];

                // Find location in Location Bible for FULL visual description
                const bibleLoc = state.storyboard.locationBible?.locations?.find(l =>
                    l.name?.toLowerCase() === loc.name?.toLowerCase()
                );

                if (bibleLoc) {
                    // Use full visual description from Location Bible
                    if (bibleLoc.description) {
                        locationParts.push(`LOCATION: ${loc.name} - ${bibleLoc.description}`);
                    } else if (bibleLoc.keyElements?.length > 0) {
                        locationParts.push(`SETTING: ${loc.name} - ${bibleLoc.keyElements.slice(0, 3).join(', ')}`);
                    } else {
                        locationParts.push(`SETTING: ${loc.name}`);
                    }

                    // Add lighting style from Location Bible
                    if (bibleLoc.lightingStyle) {
                        locationParts.push(`LIGHTING: ${bibleLoc.lightingStyle}`);
                    }

                    // Add mood/atmosphere from Location Bible
                    if (bibleLoc.mood && bibleLoc.mood !== 'neutral') {
                        locationParts.push(`ATMOSPHERE: ${bibleLoc.mood}`);
                    }
                } else if (loc.name) {
                    locationParts.push(`SETTING: ${loc.name}`);
                }

                // Add state modifiers (can override Location Bible defaults)
                if (loc.timeOfDay && loc.timeOfDay !== 'day') {
                    locationParts.push(`TIME: ${loc.timeOfDay}`);
                }
                if (loc.weather && loc.weather !== 'clear') {
                    locationParts.push(`WEATHER: ${loc.weather}`);
                }
                if (loc.condition && loc.condition !== 'lived_in' && loc.condition !== 'pristine') {
                    locationParts.push(`CONDITION: ${loc.condition}`);
                }

                if (locationParts.length > 0) {
                    parts.push(locationParts.join('. '));
                }
            }

            // Layer 3B: If no scene.location but Location Bible is enabled,
            // find the best matching location for this scene
            // PRIORITY: 1) Specific scene assignment  2) "Apply to all" fallback
            // Supports both appliedToScenes (new) and scenesUsed (legacy)
            if (!scene.location && state.storyboard.locationBible?.enabled) {
                const sceneId = scene.id;
                const allLocs = state.storyboard.locationBible.locations || [];

                // Helper to get scene assignment array (supports both field names)
                const getAssigned = (loc) => loc.appliedToScenes || loc.scenesUsed || [];

                // PRIORITY 1: Location with SPECIFIC scene assignment
                let matchingLoc = allLocs.find(loc => {
                    const assigned = getAssigned(loc);
                    return assigned.length > 0 && assigned.includes(sceneId);
                });

                // PRIORITY 2: Fall back to "apply to all" location
                if (!matchingLoc) {
                    matchingLoc = allLocs.find(loc => {
                        const assigned = getAssigned(loc);
                        return assigned.length === 0;
                    });
                }

                if (matchingLoc) {
                    const locParts = [`LOCATION: ${matchingLoc.name}`];
                    if (matchingLoc.description) {
                        locParts.push(matchingLoc.description);
                    }
                    if (matchingLoc.lightingStyle) {
                        locParts.push(`LIGHTING: ${matchingLoc.lightingStyle}`);
                    }
                    if (matchingLoc.mood && matchingLoc.mood !== 'neutral') {
                        locParts.push(`ATMOSPHERE: ${matchingLoc.mood}`);
                    }
                    if (matchingLoc.timeOfDay && matchingLoc.timeOfDay !== 'day') {
                        locParts.push(`TIME: ${matchingLoc.timeOfDay}`);
                    }
                    parts.push(locParts.join('. '));
                }
            }

            // Layer 4: Style Bible (visual DNA for all scenes)
            if (state.storyboard.styleBible?.enabled) {
                const bible = state.storyboard.styleBible;
                const styleParts = [];
                if (bible.style) styleParts.push(bible.style);
                if (bible.colorGrade) styleParts.push(bible.colorGrade);
                if (bible.lighting) styleParts.push(bible.lighting);
                if (bible.atmosphere) styleParts.push(bible.atmosphere);
                if (styleParts.length > 0) {
                    parts.push(`STYLE: ${styleParts.join(', ')}`);
                }
            }

            // Layer 5: Character Names ONLY (NOT descriptions!)
            // Character reference images handle visual consistency
            // We only include names for context, not physical descriptions
            if (state.storyboard.characterBible?.enabled && scene.charactersInScene?.length > 0) {
                // Just note which characters are in the scene - their portraits are reference images
                const charNames = scene.charactersInScene.join(' and ');
                if (!parts.some(p => p.toLowerCase().includes(charNames.toLowerCase().split(' ')[0]))) {
                    parts.push(`FEATURING: ${charNames}`);
                }
            }

            // Layer 6: Technical Specs (quality markers)
            if (state.storyboard.technicalSpecs?.enabled && state.storyboard.technicalSpecs?.positive) {
                parts.push(state.storyboard.technicalSpecs.positive);
            }

            // Build negative prompt
            let negativePrompt = state.storyboard.technicalSpecs?.enabled
                ? state.storyboard.technicalSpecs.negative || ''
                : '';

            return {
                assembledPrompt: parts.filter(Boolean).join('. '),
                negativePrompt: negativePrompt,
                layerInfo: {
                    hasStyleBible: state.storyboard.styleBible?.enabled,
                    hasCharacterBible: state.storyboard.characterBible?.enabled,
                    hasLocationBible: state.storyboard.locationBible?.enabled,
                    characterCount: scene.charactersInScene?.length || 0,
                    hasTechnicalSpecs: state.storyboard.technicalSpecs?.enabled
                }
            };
        }

        // Get characters assigned to a specific scene
        function getCharactersForScene(sceneId) {
            if (!state.storyboard.characterBible?.enabled) return [];
            const chars = state.storyboard.characterBible.characters || [];
            return chars.filter(char => {
                const includeInAll = !char.appliedToScenes || char.appliedToScenes.length === 0;
                const includeInScene = char.appliedToScenes && char.appliedToScenes.includes(sceneId);
                return includeInAll || includeInScene;
            });
        }

        // Preview assembled prompt for a scene
        function previewAssembledPrompt(sceneId) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (!scene) return;

            const assembled = assembleScenePrompt(scene);

            // Show in a toast or modal
            console.log('=== ASSEMBLED PROMPT PREVIEW ===');
            console.log('Prompt:', assembled.assembledPrompt);
            console.log('Negative:', assembled.negativePrompt);
            console.log('Layers:', assembled.layerInfo);

            showToast('Assembled prompt logged to console (F12)', 'info');
        }

        // ==========================================
        // PHASE 8-11: PROMPT CHAIN ARCHITECTURE
        // The Golden Chain of Quality
        // ==========================================

        /**
         * Process all scenes through the Prompt Chain Architecture
         * This generates optimized blueprints, image prompts, video prompts, and transitions
         */
        async function processPromptChain() {
            if (!state.script.scenes || state.script.scenes.length === 0) {
                showToast('No scenes to process. Generate a script first.', 'warning');
                return;
            }

            state.storyboard.promptChain.status = 'processing';
            render();

            try {
                const processAllScenesFn = functions.httpsCallable('creationWizardProcessAllScenes');

                const result = await processAllScenesFn({
                    scenes: state.script.scenes,
                    styleBible: state.storyboard.styleBible?.enabled ? state.storyboard.styleBible : null,
                    characterBible: state.storyboard.characterBible?.enabled ?
                        state.storyboard.characterBible.characters : null,
                    genre: state.content.genre || null,
                    productionMode: state.content.productionMode || 'standard',
                    videoModel: state.content.videoModel?.duration === '10s' ? 'minimax' : 'minimax',
                    projectId: state.project.id || null,
                    visualStyleMode: state.content.visualStyleMode || 'photorealistic'
                });

                if (result.data.success) {
                    state.storyboard.promptChain.status = 'ready';
                    state.storyboard.promptChain.processedAt = new Date().toISOString();
                    state.storyboard.promptChain.scenes = result.data.scenes;

                    // Auto-apply prompt chain transitions to assembly
                    applyPromptChainTransitions();

                    showToast(`Prompt chain processed: ${result.data.summary.successful}/${result.data.summary.total} scenes`, 'success');
                    console.log('[Prompt Chain] Processed scenes:', result.data);
                    scheduleAutoSave();
                } else {
                    throw new Error('Processing failed');
                }

            } catch (error) {
                console.error('[Prompt Chain] Error:', error);
                state.storyboard.promptChain.status = 'error';
                showToast('Failed to process prompt chain: ' + (error.message || 'Unknown error'), 'error');
            }

            render();
        }

        /**
         * Get prompt chain data for a specific scene
         */
        function getPromptChainForScene(sceneId) {
            if (!state.storyboard.promptChain?.scenes) return null;
            return state.storyboard.promptChain.scenes.find(s =>
                s.sceneId === sceneId || s.sceneId === String(sceneId)
            );
        }

        /**
         * Get the optimized image prompt from prompt chain (or fall back to assembled prompt)
         */
        function getOptimizedImagePrompt(scene) {
            // Check if prompt chain is enabled and has data for this scene
            if (state.storyboard.promptChain?.enabled && state.storyboard.promptChain?.status === 'ready') {
                const chainData = getPromptChainForScene(scene.id);
                if (chainData?.imagePrompt?.prompt) {
                    return {
                        prompt: chainData.imagePrompt.prompt,
                        negativePrompt: chainData.imagePrompt.negativePrompt || '',
                        source: 'prompt-chain',
                        metadata: chainData.imagePrompt.metadata
                    };
                }
            }

            // Fall back to the standard assembled prompt
            const assembled = assembleScenePrompt(scene);
            return {
                prompt: assembled.assembledPrompt,
                negativePrompt: assembled.negativePrompt,
                source: 'assembled',
                metadata: assembled.layerInfo
            };
        }

        /**
         * Get transition data between current scene and next scene
         */
        function getTransitionForScene(sceneId) {
            const chainData = getPromptChainForScene(sceneId);
            return chainData?.transition || null;
        }

        /**
         * Toggle prompt chain processing on/off
         */
        function togglePromptChain(enabled) {
            state.storyboard.promptChain.enabled = enabled;
            render();
            scheduleAutoSave();
        }

        // ==========================================
        // PHASE 12D: VIDEO EFFECTS, TRANSITIONS & AUDIO
        // ==========================================

        /**
         * Video effect presets with their filter values
         */
        const VIDEO_EFFECT_PRESETS = {
            'cinematic': { saturation: 0.9, contrast: 1.1, brightness: 0.02, gamma: 1.05, vignette: 0.3 },
            'vibrant': { saturation: 1.3, contrast: 1.15, brightness: 0.05, gamma: 1.0, vignette: 0 },
            'dramatic': { saturation: 0.8, contrast: 1.3, brightness: -0.05, gamma: 0.95, vignette: 0.5 },
            'warm': { saturation: 1.1, contrast: 1.05, brightness: 0.03, gamma: 1.0, vignette: 0.2 },
            'cool': { saturation: 0.95, contrast: 1.1, brightness: 0, gamma: 1.02, vignette: 0.15 },
            'vintage': { saturation: 0.7, contrast: 0.95, brightness: 0.05, gamma: 1.1, vignette: 0.4, grain: 0.15 },
            'documentary': { saturation: 1.0, contrast: 1.05, brightness: 0, gamma: 1.0, vignette: 0 },
            'noir': { saturation: 0, contrast: 1.4, brightness: -0.02, gamma: 0.9, vignette: 0.6 }
        };

        /**
         * Set video effect preset
         */
        async function setVideoEffectPreset(preset) {
            if (!state.storyboard.videoEffects) {
                state.storyboard.videoEffects = {};
            }

            if (preset && VIDEO_EFFECT_PRESETS[preset]) {
                state.storyboard.videoEffects.preset = preset;
                state.storyboard.videoEffects.filters = VIDEO_EFFECT_PRESETS[preset];

                // Save to backend
                try {
                    const applyEffectsFn = functions.httpsCallable('creationWizardApplyVideoEffects', { timeout: 60000 });
                    await applyEffectsFn({
                        projectId: state.projectId,
                        preset: preset,
                        customFilters: {},
                        applyToScenes: 'all'
                    });
                    showToast(`Applied ${preset} color grading`, 'success');
                } catch (error) {
                    console.error('[Video Effects] Error:', error);
                    showToast('Failed to apply effects', 'error');
                }
            } else {
                state.storyboard.videoEffects.preset = null;
                state.storyboard.videoEffects.filters = null;
            }

            render();
            scheduleAutoSave();
        }

        /**
         * Set transition mode
         */
        function setTransitionMode(mode) {
            if (!state.storyboard.transitions) {
                state.storyboard.transitions = { autoMode: true };
            }
            state.storyboard.transitions.mode = mode;
            render();
            scheduleAutoSave();
        }

        /**
         * Toggle auto transitions
         */
        async function toggleAutoTransitions(enabled) {
            if (!state.storyboard.transitions) {
                state.storyboard.transitions = {};
            }
            state.storyboard.transitions.autoMode = enabled;

            if (enabled && state.storyboard.multiShotMode?.decomposedScenes) {
                // Configure transitions for all decomposed scenes
                try {
                    const sceneIds = Object.keys(state.storyboard.multiShotMode.decomposedScenes);
                    for (const sceneId of sceneIds) {
                        const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
                        if (decomposed?.shots?.length > 1) {
                            const configureFn = functions.httpsCallable('creationWizardConfigureShotTransitions', { timeout: 60000 });
                            await configureFn({
                                projectId: state.projectId,
                                sceneId: sceneId,
                                shots: decomposed.shots,
                                autoMode: true,
                                mood: state.storyboard.visualStyle?.mood || 'neutral'
                            });
                        }
                    }
                    showToast('Auto-transitions configured', 'success');
                } catch (error) {
                    console.error('[Auto Transitions] Error:', error);
                }
            }

            render();
            scheduleAutoSave();
        }

        /**
         * Set audio ducking preset
         */
        function setAudioDuckingPreset(preset) {
            if (!state.storyboard.audioDucking) {
                state.storyboard.audioDucking = { enabled: true };
            }
            state.storyboard.audioDucking.preset = preset;
            render();
            scheduleAutoSave();
        }

        /**
         * Toggle audio ducking
         */
        async function toggleAudioDucking(enabled) {
            if (!state.storyboard.audioDucking) {
                state.storyboard.audioDucking = {};
            }
            state.storyboard.audioDucking.enabled = enabled;

            if (enabled) {
                try {
                    const configureFn = functions.httpsCallable('creationWizardConfigureAudioDucking', { timeout: 60000 });
                    await configureFn({
                        projectId: state.projectId,
                        preset: state.storyboard.audioDucking.preset || 'standard',
                        voiceSegments: [], // Will be calculated during export
                        musicDuration: 0
                    });
                    showToast('Audio ducking enabled', 'success');
                } catch (error) {
                    console.error('[Audio Ducking] Error:', error);
                }
            }

            render();
            scheduleAutoSave();
        }

        /**
         * Set title card style
         */
        function setTitleCardStyle(style) {
            if (!state.storyboard.titleCards) {
                state.storyboard.titleCards = { enabled: true };
            }
            state.storyboard.titleCards.style = style;
            render();
            scheduleAutoSave();
        }

        /**
         * Toggle title cards
         */
        async function toggleTitleCards(enabled) {
            if (!state.storyboard.titleCards) {
                state.storyboard.titleCards = {};
            }
            state.storyboard.titleCards.enabled = enabled;

            if (enabled && state.storyboard.scenes?.length > 0) {
                try {
                    const generateFn = functions.httpsCallable('creationWizardGenerateTitleCards', { timeout: 120000 });
                    const scenes = state.storyboard.scenes.map((scene, idx) => ({
                        sceneId: scene.sceneId || idx + 1,
                        title: scene.title || `Scene ${idx + 1}`,
                        subtitle: scene.description?.substring(0, 50)
                    }));

                    await generateFn({
                        projectId: state.projectId,
                        scenes: scenes,
                        style: state.storyboard.titleCards.style || 'modern',
                        options: { includeChapterCards: false }
                    });
                    showToast('Title cards generated', 'success');
                } catch (error) {
                    console.error('[Title Cards] Error:', error);
                }
            }

            render();
            scheduleAutoSave();
        }

        /**
         * Load Phase 4 configuration from backend
         */
        async function loadPhase4Config() {
            try {
                const getConfigFn = functions.httpsCallable('creationWizardGetPhase4Config', { timeout: 30000 });
                const result = await getConfigFn({});

                if (result.data.success) {
                    state.phase4Config = result.data.config;
                    return result.data.config;
                }
            } catch (error) {
                console.error('[Phase 4 Config] Error:', error);
            }
            return null;
        }

        /**
         * Load prompt chain configuration from backend
         */
        async function loadPromptChainConfig() {
            if (state.storyboard.promptChain.config) return state.storyboard.promptChain.config;

            try {
                const getConfigFn = functions.httpsCallable('creationWizardGetPromptChainConfig');
                const result = await getConfigFn({});

                if (result.data.success) {
                    state.storyboard.promptChain.config = result.data.config;
                    return result.data.config;
                }
            } catch (error) {
                console.error('[Prompt Chain Config] Error:', error);
            }

            return null;
        }

        /**
         * Generate a single scene blueprint
         */
        async function generateSceneBlueprint(sceneId) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (!scene) return null;

            try {
                const generateBlueprintFn = functions.httpsCallable('creationWizardGenerateSceneBlueprint');
                const result = await generateBlueprintFn({
                    scene: scene,
                    genre: state.content.genre || null,
                    productionMode: state.content.productionMode || 'standard',
                    styleBible: state.storyboard.styleBible?.enabled ? state.storyboard.styleBible : null,
                    characterBible: state.storyboard.characterBible?.enabled ?
                        state.storyboard.characterBible.characters : null
                });

                if (result.data.success) {
                    console.log('[Scene Blueprint] Generated:', result.data.blueprint);
                    return result.data.blueprint;
                }
            } catch (error) {
                console.error('[Scene Blueprint] Error:', error);
                showToast('Failed to generate blueprint: ' + error.message, 'error');
            }

            return null;
        }

        /**
         * Preview the prompt chain visual blueprint for a scene
         */
        function previewPromptChainBlueprint(sceneId) {
            const chainData = getPromptChainForScene(sceneId);
            if (!chainData) {
                showToast('No prompt chain data. Click "Process Chain" first.', 'info');
                return;
            }

            console.log('=== PROMPT CHAIN BLUEPRINT ===');
            console.log('Scene ID:', sceneId);
            console.log('Visual Blueprint:', chainData.visualBlueprint);
            console.log('Image Prompt:', chainData.imagePrompt);
            console.log('Video Prompt Template:', chainData.videoPromptTemplate);
            console.log('Transition:', chainData.transition);
            console.log('Audio Blueprint:', chainData.audioBlueprint);

            showToast('Prompt chain data logged to console (F12)', 'info');
        }

        /**
         * Apply prompt chain transitions to assembly state
         * Maps intelligent transition recommendations to assembly transitions
         */
        function applyPromptChainTransitions() {
            if (!state.storyboard.promptChain?.scenes || state.storyboard.promptChain.scenes.length === 0) {
                return;
            }

            // Map prompt chain transition types to assembly transition types
            const transitionMap = {
                'cut': 'cut',
                'hard-cut': 'cut',
                'dissolve': 'dissolve',
                'fade': 'dissolve',
                'match-cut': 'dissolve',  // Match cuts rendered as dissolves
                'j-cut': 'cut',           // J-cut is handled by audio, visual is cut
                'l-cut': 'cut',           // L-cut is handled by audio, visual is cut
                'fade-to-black': 'fade',
                'fade-from-black': 'fade',
                'wipe': 'wipe'
            };

            let appliedCount = 0;

            state.storyboard.promptChain.scenes.forEach(chainScene => {
                const sceneId = chainScene.sceneId;
                const transition = chainScene.transition;

                if (transition && transition.cutType && transition.cutType.type) {
                    const chainType = transition.cutType.type;
                    const assemblyType = transitionMap[chainType] || 'cut';

                    // Apply to assembly transitions
                    if (!state.assembly.transitions) {
                        state.assembly.transitions = {};
                    }
                    state.assembly.transitions[sceneId] = {
                        type: assemblyType,
                        chainType: chainType,  // Store original chain type for reference
                        chainReason: transition.cutType.instruction || null
                    };
                    appliedCount++;
                }
            });

            if (appliedCount > 0) {
                console.log(`[Prompt Chain] Applied ${appliedCount} intelligent transitions`);
            }
        }

        function applyTopicSuggestion(topic) {
            state.content.topic = topic;
            render();
            scheduleAutoSave();
        }

        // ==========================================
        // 6.7 SCRIPT GENERATION & EDITING
        // ==========================================
        function setScriptTone(tone) {
            state.content.tone = tone;
            render();
        }

        function setContentDepth(depth) {
            state.content.contentDepth = depth;
            render();
        }

        async function generateScript() {
            // Get topic from input
            const topicInput = document.getElementById('script-topic');
            const instructionsInput = document.getElementById('script-instructions');

            const topic = topicInput?.value?.trim() || state.content.topic;
            const additionalInstructions = instructionsInput?.value?.trim() || '';

            if (!topic || topic.length < 3) {
                showToast('Please enter a topic for your video', 'warning');
                return;
            }

            // Update state
            state.content.topic = topic;
            state.script.status = 'generating';
            render();

            try {
                // CRITICAL: Set 5-minute timeout to match server-side timeout
                // Default Firebase callable timeout is 70s which is too short for complex scripts
                const generateScriptFn = functions.httpsCallable('creationWizardGenerateScript', { timeout: 300000 });

                // Build enriched concept data from AI improvement AND selected concept
                // Merge data from: improvedData (AI enhancement) + refinedConcept (selected idea) + characterIntelligence
                const selectedConcept = state.concept?.refinedConcept || null;
                const improvedData = state.concept?.improvedData || null;
                const rawInput = state.concept?.rawInput || null;

                // ==========================================
                // PASS-THROUGH SUPPORT: Use rawInput as improvedConcept when no AI enhancement
                // This ensures user's direct concept flows to the backend
                // ==========================================
                const isPassThrough = selectedConcept?.isPassThrough === true;
                const effectiveImprovedConcept = improvedData?.improvedConcept ||
                    (isPassThrough && rawInput ? rawInput : null) ||
                    (selectedConcept?.logline || null);

                const conceptEnrichment = {
                    // From AI Improvement (improveConceptIdea) OR Pass-through raw input
                    improvedConcept: effectiveImprovedConcept,
                    characters: improvedData?.characters || [],
                    worldBuilding: improvedData?.worldBuilding || null,
                    keyElements: improvedData?.keyElements || [],
                    visualSignature: improvedData?.visualSignature || null,
                    genreFusion: improvedData?.genreFusion || null,
                    hookLine: improvedData?.hookLine || (isPassThrough && selectedConcept?.title ? selectedConcept.title : null),
                    extractedStyles: improvedData?.extractedStyles || [],
                    thingsToAvoid: improvedData?.thingsToAvoid || [],
                    suggestedMood: improvedData?.suggestedMood || selectedConcept?.mood || null,
                    suggestedTone: improvedData?.suggestedTone || selectedConcept?.tone || null,

                    // Flag for pass-through concepts
                    isPassThrough: isPassThrough,

                    // From Selected Concept (creationWizardGenerateConcepts) - FULL DATA!
                    // CRITICAL: Pass ALL concept fields, not just a subset
                    selectedConcept: selectedConcept ? {
                        // Basic info
                        title: selectedConcept.title,
                        logline: selectedConcept.logline || selectedConcept.description,
                        description: selectedConcept.description,
                        uniqueElements: selectedConcept.uniqueElements || [],
                        mood: selectedConcept.mood,
                        tone: selectedConcept.tone,
                        visualApproach: selectedConcept.visualApproach,
                        theme: selectedConcept.theme,
                        isPassThrough: selectedConcept.isPassThrough || false,

                        // Narrative Architecture - CRITICAL for script structure
                        narrativeStructure: selectedConcept.narrativeStructure,
                        storyEngine: selectedConcept.storyEngine,
                        protagonistCount: selectedConcept.protagonistCount,

                        // Characters - CRITICAL for character bible
                        characters: selectedConcept.characters || [],

                        // Relationships - CRITICAL for scene dynamics
                        keyRelationships: selectedConcept.keyRelationships || [],

                        // World Building - CRITICAL for location bible
                        worldSetting: selectedConcept.worldSetting || null
                    } : null,

                    // From Character Intelligence UI
                    characterIntelligence: {
                        narrationMode: state.characterIntelligence?.narrationMode || 'voiceover',
                        suggestedCount: state.characterIntelligence?.suggestedCount || 0,
                        characterTypes: state.characterIntelligence?.characterTypes || []
                    }
                };

                // Only include if we have SOME enrichment data
                // CRITICAL: Include when we have rawInput (pass-through concepts)
                const hasEnrichment = improvedData || selectedConcept || rawInput ||
                    (state.characterIntelligence?.suggestedCount > 0);

                const config = {
                    platform: state.platform.selected,
                    aspectRatio: state.platform.aspectRatio,
                    targetDuration: state.platform.targetDuration,
                    niche: state.content.niche,
                    subniche: state.content.subniche,
                    style: state.content.style,
                    topic: topic,
                    tone: state.content.tone || 'engaging',
                    pacing: state.content.pacing || 'balanced',
                    contentDepth: state.content.contentDepth || 'detailed',
                    // Phase 2: Hollywood Production Mode
                    productionMode: state.content.productionMode || 'standard',
                    // Phase 3A: Genre Reference System
                    genre: state.content.genre || null,
                    contentFormat: state.content.contentFormat || 'medium-form',
                    // Video Model Configuration (for scene timing optimization)
                    videoModel: state.content.videoModel || { duration: '10s', resolution: '768p' },
                    additionalInstructions,
                    // Phase 5: AI Concept Enhancement Data - Deep Story Architecture
                    // Includes: improvedData + selectedConcept + characterIntelligence
                    conceptEnrichment: hasEnrichment ? conceptEnrichment : null,
                    // Phase 3F: Narrative Structure Intelligence
                    // These control story arc, emotional journey, and tension curves
                    narrativePreset: state.content.narrativePreset || null,
                    storyArc: state.content.storyArc || null,
                    emotionalJourney: state.content.emotionalJourney || null,
                    tensionCurve: state.content.tensionCurve || null,
                    // Step 1: Production Type Context
                    // These provide context about what kind of production the user selected
                    productionType: state.production.type || null,
                    productionSubType: state.production.subType || null,
                    // Visual Style Mode for consistent prompt generation
                    visualStyleMode: state.content.visualStyleMode || 'photorealistic'
                };

                const result = await generateScriptFn({
                    projectId: state.project.id || null,
                    config
                });

                if (result.data.success) {
                    const script = result.data.script;

                    // Update state with generated script
                    state.script = {
                        ...state.script,
                        ...script,
                        status: 'generated',
                        expandedScene: null
                    };

                    // Update project ID if new project was created
                    if (result.data.projectId && !state.project.id) {
                        state.project.id = result.data.projectId;
                    }

                    showToast('Script generated successfully!', 'success');
                    scheduleAutoSave();

                    // ==========================================
                    // GENRE INTELLIGENCE: Apply production profile
                    // Ensures Style Bible, Narrator Voice, Audio Mood
                    // are all set based on the selected genre
                    // ==========================================
                    if (state.content.genre) {
                        const applied = applyGenreProductionProfile(state.content.genre, false);
                        if (applied) {
                            console.log('[Script] Genre production profile applied automatically');
                        }
                    }

                    render();

                    // ==========================================
                    // AUTO-EXTRACT CHARACTERS FROM SCRIPT
                    // Phase 4: Scene Memory System Integration
                    // ==========================================
                    try {
                        showToast('Analyzing script for characters...', 'info');
                        const extractResult = await extractCharactersFromScript();

                        if (extractResult.success && extractResult.count > 0) {
                            showToast(` Found ${extractResult.count} character(s) - Added to Character Bible!`, 'success');
                            render();
                            scheduleAutoSave();
                        } else if (extractResult.success && !extractResult.hasHumanCharacters) {
                            console.log('[Script] No human characters in this script');
                        }
                    } catch (extractError) {
                        console.warn('[Script] Character extraction optional step failed:', extractError);
                        // Don't show error to user - this is an optional enhancement
                    }

                    // ==========================================
                    // AUTO-POPULATE LOCATION BIBLE FROM SCRIPT
                    // Extract unique locations and their states
                    // ==========================================
                    try {
                        autoPopulateLocationBible(script);
                    } catch (locError) {
                        console.warn('[Script] Location Bible population optional step failed:', locError);
                    }

                    // ==========================================
                    // AUTO-POPULATE STYLE BIBLE FROM SCRIPT
                    // If script contains styleBible data, use it
                    // ==========================================
                    try {
                        autoPopulateStyleBible(script);
                    } catch (styleError) {
                        console.warn('[Script] Style Bible population optional step failed:', styleError);
                    }

                } else {
                    throw new Error(result.data.error || 'Script generation failed');
                }
            } catch (error) {
                console.error('Script generation error:', error);
                state.script.status = 'error';
                state.script.error = error.message || 'Unknown error';

                // Provide more helpful error messages based on error type
                let userMessage = 'Failed to generate script. Please try again.';
                if (error.code === 'deadline-exceeded' || error.message?.includes('timeout')) {
                    userMessage = 'Script generation timed out. Try a shorter duration or simpler concept.';
                } else if (error.code === 'resource-exhausted' || error.message?.includes('quota')) {
                    userMessage = 'API quota exceeded. Please try again later.';
                } else if (error.code === 'unauthenticated') {
                    userMessage = 'Session expired. Please refresh the page and try again.';
                } else if (error.message) {
                    userMessage = `Script generation failed: ${error.message}`;
                }

                showToast(userMessage, 'error');
            }

            render();
        }

        // ==========================================
        // FULL SCRIPT VIEWER MODAL
        // Shows the complete script in a readable format
        // ==========================================
        function openFullScriptModal() {
            const script = state.script;
            if (!script || !script.scenes || script.scenes.length === 0) {
                showToast('No script available to view', 'error');
                return;
            }

            // Build the full script text from all components
            let fullScriptText = '';

            // Title
            if (script.title) {
                fullScriptText += `# ${script.title}\n\n`;
            }

            // Hook
            if (script.hook) {
                fullScriptText += `## HOOK\n${script.hook}\n\n`;
            }

            // Metadata
            if (script.metadata) {
                fullScriptText += `---\n`;
                if (script.metadata.targetAudience) fullScriptText += `Target Audience: ${script.metadata.targetAudience}\n`;
                if (script.metadata.keyMessage) fullScriptText += `Key Message: ${script.metadata.keyMessage}\n`;
                if (script.metadata.suggestedMusic) fullScriptText += `Suggested Music: ${script.metadata.suggestedMusic}\n`;
                fullScriptText += `---\n\n`;
            }

            // Scenes
            script.scenes.forEach((scene, index) => {
                fullScriptText += `## SCENE ${index + 1}`;
                if (scene.duration || scene.visualDuration) {
                    fullScriptText += ` (${scene.duration || scene.visualDuration}s)`;
                }
                fullScriptText += `\n\n`;

                // Narration
                if (scene.narration && scene.narration.trim()) {
                    fullScriptText += `### Narration:\n${scene.narration}\n\n`;
                } else {
                    fullScriptText += `### Narration:\n Music only (no voiceover)\n\n`;
                }

                // Visual
                if (scene.visual) {
                    fullScriptText += `### Visual:\n${scene.visual}\n\n`;
                }

                // Action (if present)
                if (scene.action) {
                    fullScriptText += `### Action:\n${scene.action}\n\n`;
                }

                fullScriptText += `---\n\n`;
            });

            // CTA
            if (script.cta) {
                fullScriptText += `## CALL TO ACTION\n${script.cta}\n`;
            }

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'full-script-modal';
            modal.innerHTML = `
                <div style="position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 1rem;" onclick="if(event.target === this) closeFullScriptModal()">
                    <div style="background: linear-gradient(145deg, #1a1a2e, #16213e); border-radius: 1rem; max-width: 900px; width: 100%; max-height: 90vh; display: flex; flex-direction: column; border: 1px solid rgba(139, 92, 246, 0.3); box-shadow: 0 25px 50px rgba(0,0,0,0.5);">
                        <!-- Header -->
                        <div style="padding: 1.5rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: space-between;">
                            <div>
                                <h2 style="margin: 0; color: white; font-size: 1.3rem; display: flex; align-items: center; gap: 0.5rem;">
                                     Full Script
                                </h2>
                                <p style="margin: 0.3rem 0 0 0; color: rgba(255,255,255,0.5); font-size: 0.8rem;">
                                    ${script.scenes.length} scenes  ${script.scenes.reduce((sum, s) => sum + (s.visualDuration || s.duration || 0), 0)}s total duration
                                </p>
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="copyFullScript()" style="background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; padding: 0.5rem 1rem; color: white; cursor: pointer; font-size: 0.8rem;">
                                     Copy
                                </button>
                                <button onclick="closeFullScriptModal()" style="background: rgba(255,255,255,0.1); border: none; border-radius: 0.5rem; width: 36px; height: 36px; color: white; cursor: pointer; font-size: 1.2rem;">
                                    
                                </button>
                            </div>
                        </div>

                        <!-- Script Content -->
                        <div style="flex: 1; overflow-y: auto; padding: 1.5rem;">
                            <pre id="full-script-content" style="white-space: pre-wrap; word-wrap: break-word; font-family: 'Georgia', serif; font-size: 0.95rem; line-height: 1.7; color: rgba(255,255,255,0.9); margin: 0;">${escapeHtml(fullScriptText)}</pre>
                        </div>

                        <!-- Footer -->
                        <div style="padding: 1rem 1.5rem; border-top: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.2);">
                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.4); text-align: center;">
                                 Tip: Copy this script to review with your team or use as a reference while editing scenes
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeFullScriptModal() {
            const modal = document.getElementById('full-script-modal');
            if (modal) modal.remove();
        }

        function copyFullScript() {
            const content = document.getElementById('full-script-content');
            if (content) {
                navigator.clipboard.writeText(content.textContent)
                    .then(() => showToast('Script copied to clipboard!', 'success'))
                    .catch(() => showToast('Failed to copy script', 'error'));
            }
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function regenerateFullScript() {
            if (!confirm('This will replace your current script. Continue?')) return;

            state.script.status = 'idle';
            state.script.scenes = [];
            state.script.title = '';
            state.script.hook = '';
            state.script.cta = '';
            render();
        }

        function updateScriptTitle(title) {
            state.script.title = title;
            scheduleAutoSave();
        }

        function updateScriptHook(hook) {
            state.script.hook = hook;
            scheduleAutoSave();
        }

        function updateScriptCTA(cta) {
            state.script.cta = cta;
            scheduleAutoSave();
        }

        function toggleSceneExpand(sceneId) {
            if (state.script.expandedScene === sceneId) {
                state.script.expandedScene = null;
            } else {
                state.script.expandedScene = sceneId;
            }
            render();
        }

        // Toggle expand/collapse for pass-through concept display on Step 3
        function toggleConceptDisplay() {
            const content = document.getElementById('concept-display-content');
            const btn = document.getElementById('concept-toggle-btn');
            if (!content || !btn) return;

            const isExpanded = content.style.maxHeight !== '150px';
            if (isExpanded) {
                // Collapse
                content.style.maxHeight = '150px';
                content.style.overflow = 'hidden';
                btn.innerHTML = 'Show Full Concept ';
                // Re-add gradient overlay
                const existing = content.querySelector('div[style*="linear-gradient"]');
                if (!existing) {
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position: absolute; bottom: 0; left: 0; right: 0; height: 40px; background: linear-gradient(transparent, rgba(30,30,50,0.95));';
                    content.appendChild(overlay);
                }
            } else {
                // Expand
                content.style.maxHeight = 'none';
                content.style.overflow = 'visible';
                btn.innerHTML = 'Show Less ';
                // Remove gradient overlay
                const overlay = content.querySelector('div[style*="linear-gradient"]');
                if (overlay) overlay.remove();
            }
        }

        function updateSceneNarration(sceneId, value) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.narration = value && value.trim() ? value.trim() : null;
                scene.hasNarration = !!(value && value.trim());
                // Recalculate word count and narration duration
                if (scene.hasNarration) {
                    scene.wordCount = scene.narration.split(/\s+/).filter(w => w.length > 0).length;
                    scene.narrationDuration = Math.ceil(scene.wordCount / 2.5);
                } else {
                    scene.wordCount = 0;
                    scene.narrationDuration = 0;
                }
                scheduleAutoSave();
            }
        }

        function toggleSceneNarration(sceneId, hasNarration) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.hasNarration = hasNarration;
                if (!hasNarration) {
                    // Clear narration when toggling off
                    scene.narration = null;
                    scene.wordCount = 0;
                    scene.narrationDuration = 0;
                } else if (!scene.narration) {
                    // Set placeholder when toggling on
                    scene.narration = '';
                }
                scheduleAutoSave();
                render();
            }
        }

        // Enable narration on a scene that was music-only
        function enableSceneNarration(sceneId) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.hasNarration = true;
                scene.narration = scene.narration || '';
                scheduleAutoSave();
                render();
                showToast('Voiceover enabled for this scene', 'success');
            }
        }

        function toggleMusicOnlyMode(sceneId, isMusicOnly) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.hasNarration = !isMusicOnly;
                scheduleAutoSave();
                render();
                if (isMusicOnly) {
                    showToast('Scene set to Music Only mode', 'info');
                } else {
                    showToast('Voiceover enabled for this scene', 'success');
                }
            }
        }

        function updateSceneVisual(sceneId, value) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                // Update both visual and visualPrompt for compatibility
                scene.visual = value;
                scene.visualPrompt = value;
                scheduleAutoSave();
            }
        }

        function updateSceneDuration(sceneId, value) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.duration = parseInt(value) || 8;
                // Recalculate total duration
                state.script.totalDuration = state.script.scenes.reduce((sum, s) => sum + s.duration, 0);
                scheduleAutoSave();
                render();
            }
        }

        function updateSceneTransition(sceneId, value) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.transition = value;
                scheduleAutoSave();
            }
        }

        async function regenerateScene(sceneId) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (!scene) return;

            const instructions = prompt('Any specific instructions for regenerating this scene? (or leave empty)');

            try {
                showToast('Regenerating scene...', 'info');

                const regenerateSceneFn = functions.httpsCallable('creationWizardRegenerateScene');
                const result = await regenerateSceneFn({
                    projectId: state.project.id,
                    sceneId: sceneId,
                    currentScript: state.script,
                    instructions: instructions || ''
                });

                if (result.data.success) {
                    // Update the scene in state
                    const index = state.script.scenes.findIndex(s => s.id === sceneId);
                    if (index !== -1) {
                        state.script.scenes[index] = {
                            ...state.script.scenes[index],
                            ...result.data.scene
                        };
                    }

                    showToast('Scene regenerated!', 'success');
                    scheduleAutoSave();
                    render();
                }
            } catch (error) {
                console.error('Regenerate scene error:', error);
                showToast('Failed to regenerate scene', 'error');
            }
        }

        function moveSceneUp(sceneId) {
            const index = state.script.scenes.findIndex(s => s.id === sceneId);
            if (index > 0) {
                const temp = state.script.scenes[index];
                state.script.scenes[index] = state.script.scenes[index - 1];
                state.script.scenes[index - 1] = temp;
                scheduleAutoSave();
                render();
            }
        }

        function moveSceneDown(sceneId) {
            const index = state.script.scenes.findIndex(s => s.id === sceneId);
            if (index < state.script.scenes.length - 1) {
                const temp = state.script.scenes[index];
                state.script.scenes[index] = state.script.scenes[index + 1];
                state.script.scenes[index + 1] = temp;
                scheduleAutoSave();
                render();
            }
        }

        function deleteScene(sceneId) {
            if (state.script.scenes.length <= 1) {
                showToast('You need at least one scene', 'warning');
                return;
            }

            if (!confirm('Delete this scene?')) return;

            state.script.scenes = state.script.scenes.filter(s => s.id !== sceneId);
            state.script.totalDuration = state.script.scenes.reduce((sum, s) => sum + s.duration, 0);
            scheduleAutoSave();
            render();
        }

        function addNewScene() {
            const maxId = Math.max(...state.script.scenes.map(s => s.id), 0);
            const newScene = {
                id: maxId + 1,
                narration: '',
                visual: '',
                duration: 10,
                transition: 'cut',
                status: 'pending'
            };

            state.script.scenes.push(newScene);
            state.script.expandedScene = newScene.id;
            state.script.totalDuration = state.script.scenes.reduce((sum, s) => sum + s.duration, 0);
            scheduleAutoSave();
            render();

            // Scroll to new scene
            setTimeout(() => {
                const sceneCards = document.querySelectorAll('.scene-card');
                if (sceneCards.length > 0) {
                    sceneCards[sceneCards.length - 1].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        // ==========================================
        // 6.8 STORYBOARD GENERATION
        // ==========================================
        let imagePollingIntervals = {};

        // ==========================================
        // IMAGE GENERATION RATE LIMITER
        // Prevents 429 errors by throttling requests
        // Gemini API has strict rate limits - need longer delays
        // ==========================================
        const imageGenerationQueue = {
            queue: [],
            isProcessing: false,
            lastRequestTime: 0,
            minDelayMs: 4000, // Minimum 4 seconds between requests (Gemini needs this)
            backoffUntil: 0, // Global backoff timestamp when rate limited
            consecutiveErrors: 0, // Track consecutive 429 errors

            async add(fn) {
                return new Promise((resolve, reject) => {
                    this.queue.push({ fn, resolve, reject });
                    this.process();
                });
            },

            // Call this when a 429 error occurs to add global backoff
            triggerBackoff() {
                this.consecutiveErrors++;
                // Exponential backoff: 10s, 20s, 40s, 60s max
                const backoffTime = Math.min(60000, Math.pow(2, this.consecutiveErrors) * 5000);
                this.backoffUntil = Date.now() + backoffTime;
                console.log(`[Rate Limiter] Global backoff triggered: ${backoffTime/1000}s (consecutive errors: ${this.consecutiveErrors})`);
            },

            // Call this on success to reset error count
            resetBackoff() {
                this.consecutiveErrors = 0;
            },

            async process() {
                if (this.isProcessing || this.queue.length === 0) return;
                this.isProcessing = true;

                while (this.queue.length > 0) {
                    const { fn, resolve, reject } = this.queue.shift();

                    // Check global backoff first
                    const now = Date.now();
                    if (this.backoffUntil > now) {
                        const backoffWait = this.backoffUntil - now;
                        console.log(`[Rate Limiter] Global backoff active, waiting ${Math.ceil(backoffWait/1000)}s...`);
                        await new Promise(r => setTimeout(r, backoffWait));
                    }

                    // Calculate delay needed since last request
                    const timeSinceLastRequest = Date.now() - this.lastRequestTime;
                    const delayNeeded = Math.max(0, this.minDelayMs - timeSinceLastRequest);

                    if (delayNeeded > 0) {
                        console.log(`[Rate Limiter] Waiting ${Math.ceil(delayNeeded/1000)}s before next request...`);
                        await new Promise(r => setTimeout(r, delayNeeded));
                    }

                    this.lastRequestTime = Date.now();

                    try {
                        const result = await fn();
                        this.resetBackoff(); // Success - reset error count
                        resolve(result);
                    } catch (error) {
                        // Check if this is a rate limit error
                        const errorMsg = error.message || '';
                        if (errorMsg.includes('429') || errorMsg.includes('temporarily busy') ||
                            errorMsg.includes('rate') || errorMsg.includes('RESOURCE_EXHAUSTED')) {
                            this.triggerBackoff();
                        }
                        reject(error);
                    }
                }

                this.isProcessing = false;
            }
        };

        async function generateInitialStoryboard() {
            const scenes = state.script.scenes || [];
            if (scenes.length === 0) return;

            // Only generate FIRST scene automatically - others on demand
            const firstScene = scenes[0];

            state.storyboard.status = 'generating';

            // Initialize all storyboard scenes - first is generating, others pending
            state.storyboard.scenes = scenes.map((scene, index) => ({
                sceneId: scene.id,
                status: index === 0 ? 'generating' : 'pending',
                imageUrl: null,
                prompt: scene.visual || '',
                jobId: null,
                source: 'ai' // 'ai' | 'stock' | 'upload'
            }));

            render();

            // Generate only first scene
            try {
                await generateSingleSceneImage(firstScene.id);
                state.storyboard.status = 'partial';
                render();
            } catch (error) {
                console.error('Initial storyboard generation error:', error);
                showToast('Failed to generate first image. Click to retry.', 'error');
                state.storyboard.status = 'error';
                render();
            }
        }

        // Model configuration with token costs
        const IMAGE_MODELS = {
            'hidream': {
                name: 'HiDream',
                description: 'Artistic & cinematic style',
                tokenCost: 2,
                cloudFunction: 'creationWizardGenerateSceneImage'
            },
            'nanobanana-pro': {
                name: 'NanoBanana Pro',
                description: 'High quality, fast generation',
                tokenCost: 3,
                cloudFunction: 'generateCreativeImage'
            },
            'nanobanana': {
                name: 'NanoBanana',
                description: 'Quick drafts, lower cost',
                tokenCost: 1,
                cloudFunction: 'generateCreativeImage'
            }
        };

        // Get current model configuration
        function getCurrentModelConfig() {
            return IMAGE_MODELS[state.storyboard.imageModel] || IMAGE_MODELS['hidream'];
        }

        // Set image generation model
        function setImageModel(modelId) {
            if (IMAGE_MODELS[modelId]) {
                state.storyboard.imageModel = modelId;
                render();
            }
        }

        async function generateSingleSceneImage(sceneId, customModel = null) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (!scene) return;

            const modelId = customModel || state.storyboard.imageModel || 'hidream';
            const modelConfig = IMAGE_MODELS[modelId] || IMAGE_MODELS['hidream'];

            // Find or create storyboard entry
            let storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene) {
                storyboardScene = {
                    sceneId: sceneId,
                    status: 'pending',
                    imageUrl: null,
                    prompt: scene.visual || '',
                    jobId: null,
                    source: 'ai',
                    model: modelId
                };
                state.storyboard.scenes.push(storyboardScene);
            }

            storyboardScene.status = 'generating';
            storyboardScene.model = modelId;
            storyboardScene.error = null;
            render();

            // Phase 8-11: Get optimized prompt from Prompt Chain (falls back to assembled prompt)
            const optimizedPrompt = getOptimizedImagePrompt(scene);
            const prompt = optimizedPrompt.prompt || scene.visual || scene.narration || 'A cinematic scene';
            const promptSource = optimizedPrompt.source; // 'prompt-chain' or 'assembled'

            try {
                // Phase 4: Build Scene Memory data for this specific scene
                initSceneMemory(); // Ensure defaults are set
                const sceneMemoryData = {
                    styleBible: state.storyboard.styleBible,
                    // Get character descriptions that apply to this scene
                    characterDescriptions: getCharactersForScene(sceneId).map(c => c.description).filter(Boolean),
                    technicalSpecs: state.storyboard.technicalSpecs
                };

                // Log prompt source for debugging
                if (promptSource === 'prompt-chain') {
                    console.log(`[Scene ${sceneId}] Using Prompt Chain optimized prompt`);
                }

                // Get location reference for this scene (if available from Location Bible)
                const locationRef = getLocationReferenceForScene(sceneId);
                if (locationRef) {
                    console.log(`[Scene Generation] Using Location Bible: "${locationRef.locationName}"`);
                }

                // Check if using HiDream (RunPod) or NanoBanana (Gemini)
                if (modelId === 'hidream') {
                    // Use RunPod HiDream endpoint
                    // CRITICAL: 5-minute timeout to handle RunPod cold starts
                    const generateFn = functions.httpsCallable('creationWizardGenerateSceneImage', { timeout: 300000 });

                    // Build enhanced prompt with Location Bible description
                    let enhancedPrompt = prompt;
                    if (locationRef) {
                        const locationContext = [
                            `LOCATION: ${locationRef.locationName}`,
                            locationRef.locationDescription ? locationRef.locationDescription : '',
                            locationRef.lightingStyle ? `LIGHTING: ${locationRef.lightingStyle}` : '',
                            locationRef.timeOfDay && locationRef.timeOfDay !== 'day' ? `TIME: ${locationRef.timeOfDay}` : '',
                            locationRef.weather && locationRef.weather !== 'clear' ? `WEATHER: ${locationRef.weather}` : '',
                            locationRef.mood && locationRef.mood !== 'neutral' ? `ATMOSPHERE: ${locationRef.mood}` : ''
                        ].filter(Boolean).join('. ');
                        enhancedPrompt = `${locationContext}. ${prompt}`;
                        console.log('[Scene Generation] Enhanced prompt with Location Bible');
                    }

                    const result = await generateFn({
                        projectId: state.project.id,
                        sceneId: sceneId,
                        prompt: enhancedPrompt,
                        style: state.content.style,
                        aspectRatio: state.platform.aspectRatio,
                        // HiDream settings - matching working thumbnail generator
                        settings: {
                            steps: 35,
                            cfg: 5
                        },
                        // Phase 3B: Visual Intelligence parameters
                        genre: state.content.genre || null,
                        productionMode: state.content.productionMode || 'standard',
                        mood: state.storyboard.visualStyle?.mood || null,
                        visualSettings: {
                            composition: state.storyboard.visualStyle?.composition || null,
                            lighting: state.storyboard.visualStyle?.lighting || null,
                            colorPalette: state.storyboard.visualStyle?.colorPalette || null
                        },
                        // Phase 4: Scene Memory System
                        sceneMemory: sceneMemoryData,
                        // Phase 8-11: Prompt Chain metadata
                        promptChainSource: promptSource,
                        promptChainMetadata: optimizedPrompt.metadata,
                        // VISUAL_STYLE_DNA: Critical for photorealistic/cinematic/anime rendering
                        visualStyleMode: state.content.visualStyleMode || 'photorealistic',
                        // LOCATION BIBLE: Reference for consistent environments
                        locationReference: locationRef ? {
                            name: locationRef.locationName,
                            description: locationRef.locationDescription,
                            lighting: locationRef.lightingStyle,
                            timeOfDay: locationRef.timeOfDay,
                            weather: locationRef.weather,
                            mood: locationRef.mood
                        } : null
                    });

                    if (result.data.success) {
                        storyboardScene.jobId = result.data.jobId;
                        storyboardScene.imageUrl = result.data.imageUrl;
                        storyboardScene.prompt = result.data.prompt;
                        storyboardScene.source = 'ai';

                        // Start polling for completion
                        startImagePolling(sceneId, result.data.jobId);
                    } else {
                        throw new Error(result.data.message || 'Generation failed');
                    }
                } else {
                    // Use NanoBanana (Gemini) - synchronous result
                    // This model SUPPORTS character reference images!
                    // CRITICAL: 5-minute timeout to match server (Gemini can take 60-120s)
                    const generateFn = functions.httpsCallable('generateCreativeImage', { timeout: 300000 });

                    // Map aspect ratio
                    const aspectRatioMap = {
                        '16:9': '16:9',
                        '9:16': '9:16',
                        '1:1': '1:1',
                        '4:3': '4:3'
                    };

                    // Get character reference image for this scene (if available)
                    const characterRef = getCharacterReferenceForScene(sceneId);

                    // Phase 8-11: Use optimized prompt from Prompt Chain (already fetched above)
                    // Falls back to assembled prompt if prompt chain not available
                    // LOCATION BIBLE: Enhance prompt with location description if available
                    let fullPrompt = prompt;
                    if (locationRef) {
                        const locationContext = [
                            `LOCATION: ${locationRef.locationName}`,
                            locationRef.locationDescription ? locationRef.locationDescription : '',
                            locationRef.lightingStyle ? `LIGHTING: ${locationRef.lightingStyle}` : '',
                            locationRef.timeOfDay && locationRef.timeOfDay !== 'day' ? `TIME: ${locationRef.timeOfDay}` : '',
                            locationRef.weather && locationRef.weather !== 'clear' ? `WEATHER: ${locationRef.weather}` : '',
                            locationRef.mood && locationRef.mood !== 'neutral' ? `ATMOSPHERE: ${locationRef.mood}` : ''
                        ].filter(Boolean).join('. ');
                        fullPrompt = `${locationContext}. ${prompt}`;
                        console.log('[Scene Generation] Enhanced NanoBanana prompt with Location Bible');
                    }

                    const requestData = {
                        prompt: fullPrompt,
                        model: modelId,
                        quantity: 1,
                        aspectRatio: aspectRatioMap[state.platform.aspectRatio] || '16:9',
                        quality: modelId === 'nanobanana-pro' ? 'hd' : 'basic'
                    };

                    // Only add negativePrompt for models that support it (not Gemini)
                    // Gemini models handle negative prompts by embedding in the prompt text
                    const isGeminiModel = ['nanobanana-pro', 'nanobanana', 'nano-banana-pro', 'nano-banana'].includes(modelId);
                    if (!isGeminiModel && optimizedPrompt.negativePrompt) {
                        requestData.negativePrompt = optimizedPrompt.negativePrompt;
                    }

                    // Add character reference image if available
                    // This enables visual consistency across scenes!
                    if (characterRef && characterRef.base64) {
                        requestData.characterReference = {
                            base64: characterRef.base64,
                            mimeType: characterRef.mimeType || 'image/png'
                        };
                        console.log(`[Scene Generation] Using character reference for "${characterRef.characterName}"`);
                    }

                    // Add location reference image if available (Gemini supports this!)
                    // This enables consistent environment backgrounds across scenes
                    if (locationRef && locationRef.base64) {
                        requestData.locationReference = {
                            base64: locationRef.base64,
                            mimeType: locationRef.mimeType || 'image/png',
                            name: locationRef.locationName
                        };
                        console.log(`[Scene Generation] Using location reference for "${locationRef.locationName}"`);
                    }

                    // Use rate limiter queue for NanoBanana/Gemini to prevent 429 errors
                    const result = await imageGenerationQueue.add(() => generateFn(requestData));

                    if (result.data.success && result.data.images && result.data.images.length > 0) {
                        storyboardScene.status = 'ready';
                        storyboardScene.imageUrl = result.data.images[0].url;
                        storyboardScene.prompt = fullPrompt;
                        storyboardScene.source = 'ai';
                        storyboardScene.usedCharacterRef = characterRef ? characterRef.characterName : null;

                        // CRITICAL: Sync scene image to Shot 1 if decomposed
                        // When scene image is regenerated, Shot 1 should automatically get the new image
                        const decomposed = state.storyboard.multiShotMode?.decomposedScenes?.[sceneId];
                        if (decomposed?.shots?.length > 0) {
                            decomposed.shots[0].imageUrl = storyboardScene.imageUrl;
                            decomposed.shots[0].status = 'ready';
                            decomposed.shots[0].fromSceneImage = true;
                            console.log('[Scene Generation] Synced new scene image to Shot 1');
                        }

                        showToast(`Image generated! (${modelConfig.name})${characterRef ? ' with character ref' : ''}`, 'success');
                        scheduleAutoSave();
                    } else {
                        throw new Error(result.data.message || 'No images returned');
                    }
                }

                render();

            } catch (error) {
                console.error('Scene generation error:', error);

                // Check if this is a rate limit error (429) - implement auto-retry
                const errorMsg = error.message || 'Unknown error';
                const isRateLimitError = errorMsg.includes('429') ||
                                        errorMsg.includes('temporarily busy') ||
                                        errorMsg.includes('rate') ||
                                        errorMsg.includes('quota') ||
                                        errorMsg.includes('RESOURCE_EXHAUSTED');

                if (isRateLimitError) {
                    // Get current retry count
                    const retryCount = storyboardScene.retryCount || 0;
                    const maxRetries = 3;

                    if (retryCount < maxRetries) {
                        // Longer exponential backoff: 10s, 20s, 40s (Gemini needs longer waits)
                        const delay = Math.pow(2, retryCount) * 10000;
                        storyboardScene.retryCount = retryCount + 1;
                        storyboardScene.status = 'retrying';
                        storyboardScene.error = `Rate limited. Retrying in ${delay/1000}s... (${retryCount + 1}/${maxRetries})`;
                        render();

                        console.log(`[Scene ${sceneId}] Rate limited, retrying in ${delay/1000}s (attempt ${retryCount + 1})`);

                        // Wait for the delay
                        await new Promise(resolve => setTimeout(resolve, delay));

                        // Reset status before retry attempt
                        storyboardScene.status = 'generating';
                        storyboardScene.error = null;
                        render();

                        // Retry - the queue will handle additional spacing
                        return generateSingleSceneImage(sceneId, customModel);
                    } else {
                        // Max retries reached
                        storyboardScene.status = 'error';
                        storyboardScene.error = 'Service temporarily busy. Please try again later.';
                        storyboardScene.retryCount = 0; // Reset for manual retry
                        showToast('Service busy after 3 retries. Please wait a minute and try again.', 'error');
                    }
                } else {
                    storyboardScene.status = 'error';
                    storyboardScene.error = errorMsg || 'Failed to generate image';

                    // Show detailed error message
                    if (errorMsg.includes('token') || errorMsg.includes('balance')) {
                        showToast('Insufficient tokens. Visit Creative Studio to get more.', 'error');
                    } else if (errorMsg.includes('API key') || errorMsg.includes('configured')) {
                        showToast('Service not configured. Contact support.', 'error');
                    } else {
                        showToast(`Failed: ${errorMsg.substring(0, 50)}`, 'error');
                    }
                }
                render();
            }
        }

        async function regenerateSingleSceneImage(sceneId) {
            await generateSingleSceneImage(sceneId);
        }

        // Upscale a scene image to HD or 4K
        async function upscaleSceneImage(sceneId, quality = null) {
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene || !storyboardScene.imageUrl) {
                showToast('No image to upscale', 'error');
                return;
            }

            // If quality not specified, show quality selection modal
            if (!quality) {
                showUpscaleQualityModal(sceneId);
                return;
            }

            try {
                // Mark as processing
                storyboardScene.upscaleStatus = 'processing';
                render();
                showToast(`Upscaling to ${quality.toUpperCase()}...`, 'info');

                const upscaleFn = functions.httpsCallable('upscaleSceneImage');
                const result = await upscaleFn({
                    imageUrl: storyboardScene.imageUrl,
                    aspectRatio: state.aspectRatio || '16:9',
                    quality: quality,
                    sceneId: String(sceneId)
                });

                if (result.data.success) {
                    // Update scene with upscaled image
                    storyboardScene.imageUrl = result.data.upscaledUrl;
                    storyboardScene.upscaleStatus = 'completed';
                    storyboardScene.upscaleQuality = quality;
                    storyboardScene.width = result.data.width;
                    storyboardScene.height = result.data.height;

                    showToast(`Upscaled to ${result.data.width}x${result.data.height}!`, 'success');
                    render();
                    scheduleAutoSave();
                } else {
                    throw new Error('Upscale failed');
                }
            } catch (error) {
                console.error('Upscale error:', error);
                storyboardScene.upscaleStatus = 'error';
                showToast(`Upscale failed: ${error.message}`, 'error');
                render();
            }
        }

        function showUpscaleQualityModal(sceneId) {
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene) return;

            const modal = document.createElement('div');
            modal.id = 'upscale-quality-modal';
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;';
            modal.innerHTML = `
                <div style="background: #1a1a2e; border: 1px solid rgba(255,255,255,0.1); border-radius: 1rem; padding: 2rem; max-width: 400px; width: 90%;">
                    <h3 style="margin: 0 0 1rem 0; color: white; font-size: 1.25rem;"> Upscale Image</h3>
                    <p style="color: rgba(255,255,255,0.7); font-size: 0.9rem; margin-bottom: 1.5rem;">
                        Choose your target quality for the upscaled image:
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 1rem;">
                        <button onclick="closeUpscaleModal(); upscaleSceneImage(${sceneId}, 'hd')"
                                style="padding: 1rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.4), rgba(6, 182, 212, 0.4)); border: 1px solid rgba(139, 92, 246, 0.5); border-radius: 0.75rem; color: white; cursor: pointer; text-align: left;">
                            <div style="font-weight: 600; font-size: 1rem;"> HD (19201080)</div>
                            <div style="font-size: 0.8rem; color: rgba(255,255,255,0.7); margin-top: 0.25rem;">
                                Full HD quality  1 token
                            </div>
                        </button>
                        <button onclick="closeUpscaleModal(); upscaleSceneImage(${sceneId}, '4k')"
                                style="padding: 1rem; background: linear-gradient(135deg, rgba(251, 191, 36, 0.4), rgba(245, 158, 11, 0.4)); border: 1px solid rgba(251, 191, 36, 0.5); border-radius: 0.75rem; color: white; cursor: pointer; text-align: left;">
                            <div style="font-weight: 600; font-size: 1rem;"> 4K UHD (38402160)</div>
                            <div style="font-size: 0.8rem; color: rgba(255,255,255,0.7); margin-top: 0.25rem;">
                                Cinema quality  3 tokens
                            </div>
                        </button>
                    </div>
                    <button onclick="closeUpscaleModal()"
                            style="margin-top: 1.5rem; width: 100%; padding: 0.75rem; background: transparent; border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: rgba(255,255,255,0.7); cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeUpscaleModal() {
            const modal = document.getElementById('upscale-quality-modal');
            if (modal) modal.remove();
        }

        // ==========================================
        // PHASE 12: MULTI-SHOT SCENE FUNCTIONS
        // ==========================================

        /**
         * Toggle multi-shot mode for storyboard generation
         */
        function toggleMultiShotMode(enabled) {
            state.storyboard.multiShotMode.enabled = enabled;
            render();
            scheduleAutoSave();

            if (enabled) {
                showToast(' Multi-Shot Mode enabled! Each scene will have multiple camera angles.', 'success');
            } else {
                showToast('Multi-Shot Mode disabled', 'info');
            }
        }

        /**
         * Set default shot count for multi-shot mode
         */
        function setDefaultShotCount(count) {
            state.storyboard.multiShotMode.defaultShotCount = Math.max(2, Math.min(6, parseInt(count)));
            render();
            scheduleAutoSave();
        }

        /**
         * Decompose a scene into multiple shots using AI
         */
        async function decomposeSceneToShots(sceneId) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (!scene) {
                showToast('Scene not found', 'error');
                return;
            }

            // Mark as processing
            if (!state.storyboard.multiShotMode.decomposedScenes) {
                state.storyboard.multiShotMode.decomposedScenes = {};
            }
            state.storyboard.multiShotMode.decomposedScenes[sceneId] = {
                status: 'decomposing',
                shots: [],
                consistencyAnchors: null
            };
            render();
            showToast(' Decomposing scene into shots...', 'info');

            try {
                const decomposeFn = functions.httpsCallable('creationWizardDecomposeSceneToShots', { timeout: 120000 });

                // Get clip duration from script timing or default to 10s (allows more complex actions)
                const clipDuration = state.script.timing?.clipDuration || 10;

                const result = await decomposeFn({
                    scene: {
                        id: sceneId,
                        visualPrompt: scene.visualPrompt || scene.visual,
                        narration: scene.narration,
                        duration: scene.duration || 35,  // Hollywood-style scene duration (30-60s)
                        // NEW: Pass action data for video prompt generation
                        sceneAction: scene.sceneAction || scene.action || null,
                        actionBlueprint: scene.actionBlueprint || null,
                        // PHASE 1: Pass audioLayer for dialogue distribution to shots
                        audioLayer: scene.audioLayer || null,
                        sceneType: scene.sceneType || null,
                        charactersInScene: scene.charactersInScene || [],
                        // PHASE 3: Pass voice assignments for character voice synthesis
                        voiceAssignments: state.script?.voiceAssignments || {}
                    },
                    targetShotCount: state.storyboard.multiShotMode.defaultShotCount,
                    clipDuration: clipDuration,  // Pass clip duration for Hollywood math: shots = sceneDuration / clipDuration
                    genre: state.concept.genre,
                    productionMode: state.concept.productionMode || 'premium',
                    styleBible: state.storyboard.styleBible?.enabled ? state.storyboard.styleBible : null,
                    characterBible: state.storyboard.characterBible?.enabled ? state.storyboard.characterBible.characters : null
                });

                if (result.data.success) {
                    state.storyboard.multiShotMode.decomposedScenes[sceneId] = {
                        status: 'ready',
                        sceneType: result.data.sceneType,
                        totalDuration: result.data.totalDuration,
                        shots: result.data.shots,
                        consistencyAnchors: result.data.consistencyAnchors,
                        selectedShot: 0,
                        // PHASE 5-6: Store quality assurance and pipeline verification reports
                        qualityAssurance: result.data.qualityAssurance || null,
                        pipelineVerification: result.data.pipelineVerification || null
                    };

                    // PHASE 6: Log pipeline status for debugging
                    if (result.data.pipelineVerification) {
                        const pv = result.data.pipelineVerification;
                        console.log(`[decomposeSceneToShots] Pipeline: ${pv.status} (${pv.passRate}% pass rate)`);
                        if (pv.status !== 'pass') {
                            console.warn('[decomposeSceneToShots] Pipeline issues detected - check qualityAssurance for details');
                        }
                    }

                    // CRITICAL: Auto-sync scene image to Shot 1
                    // Shot 1 should automatically use the scene's existing image as its starting frame
                    const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                    if (storyboardScene?.imageUrl && result.data.shots.length > 0) {
                        const shot1 = state.storyboard.multiShotMode.decomposedScenes[sceneId].shots[0];
                        shot1.imageUrl = storyboardScene.imageUrl;
                        shot1.status = 'ready';
                        shot1.fromSceneImage = true;
                        console.log('[decomposeSceneToShots] Auto-synced scene image to Shot 1:', storyboardScene.imageUrl);
                    }

                    // PHASE 6: Show toast with pipeline status
                    const pipelineStatus = result.data.pipelineVerification?.status || 'unknown';
                    const qaStatus = result.data.qualityAssurance?.status || 'unknown';
                    const statusEmoji = pipelineStatus === 'pass' && qaStatus === 'healthy' ? '' :
                                       pipelineStatus === 'warning' || qaStatus === 'degraded' ? '' : '';
                    showToast(`${statusEmoji} Scene decomposed into ${result.data.shotCount} shots!`, 'success');
                    render();
                    scheduleAutoSave();
                } else {
                    throw new Error(result.data.message || 'Failed to decompose scene');
                }

            } catch (error) {
                console.error('Scene decomposition error:', error);
                state.storyboard.multiShotMode.decomposedScenes[sceneId] = {
                    status: 'error',
                    error: error.message || 'Failed to decompose scene',
                    shots: []
                };
                showToast(`Failed to decompose scene: ${error.message}`, 'error');
                render();
                // Also update modal state if open
                if (state.storyboard.decompositionModal.open && state.storyboard.decompositionModal.sceneId === sceneId) {
                    state.storyboard.decompositionModal.status = 'error';
                    state.storyboard.decompositionModal.error = error.message;
                    renderShotDecompositionModal();
                }
            }
        }

        // ==========================================
        // SHOT DECOMPOSITION MODAL
        // ==========================================

        /**
         * Open the shot decomposition modal
         */
        function openShotDecompositionModal(sceneId) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);

            if (!scene) {
                showToast('Scene not found', 'error');
                return;
            }

            // Check if scene already has shots
            const decomposed = state.storyboard.multiShotMode?.decomposedScenes?.[sceneId];
            const hasShots = decomposed && decomposed.shots && decomposed.shots.length > 0;

            state.storyboard.decompositionModal = {
                open: true,
                sceneId: sceneId,
                shotCount: hasShots ? decomposed.shots.length : 3,
                status: hasShots ? 'ready' : 'idle',
                error: null
            };

            renderShotDecompositionModal();
        }

        /**
         * Close the shot decomposition modal
         */
        function closeShotDecompositionModal() {
            state.storyboard.decompositionModal.open = false;
            state.storyboard.decompositionModal.sceneId = null;
            const modal = document.getElementById('shot-decomposition-modal');
            if (modal) modal.remove();
            render(); // Re-render to update UI if shots were created
        }

        /**
         * Set the number of shots for decomposition
         */
        function setDecompositionShotCount(count) {
            state.storyboard.decompositionModal.shotCount = parseInt(count);
            renderShotDecompositionModal();
        }

        /**
         * Start the decomposition process from modal
         */
        async function startDecompositionFromModal() {
            const sceneId = state.storyboard.decompositionModal.sceneId;
            state.storyboard.decompositionModal.status = 'decomposing';
            state.storyboard.multiShotMode.defaultShotCount = state.storyboard.decompositionModal.shotCount;
            renderShotDecompositionModal();

            // Call the existing decompose function
            await decomposeSceneToShots(sceneId);

            // Update modal state based on result
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (decomposed && decomposed.status === 'ready') {
                state.storyboard.decompositionModal.status = 'ready';
            } else if (decomposed && decomposed.status === 'error') {
                state.storyboard.decompositionModal.status = 'error';
                state.storyboard.decompositionModal.error = decomposed.error;
            }
            renderShotDecompositionModal();
        }

        /**
         * Generate a single shot image
         *
         * IMPORTANT: Shot 1 uses the scene's existing image as its base.
         * The scene's main image is NEVER overwritten by shot generation.
         */
        async function generateSingleShotImage(sceneId, shotIndex) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots || !decomposed.shots[shotIndex]) {
                showToast('Shot not found', 'error');
                return;
            }

            const shot = decomposed.shots[shotIndex];
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);

            // SHOT 1 SPECIAL HANDLING: If scene already has an image, use it for Shot 1
            if (shotIndex === 0 && storyboardScene?.imageUrl && !shot.imageUrl) {
                shot.imageUrl = storyboardScene.imageUrl;
                shot.status = 'ready';
                shot.fromSceneImage = true; // Mark as derived from scene image
                showToast(` Shot 1 initialized with scene image. Use "Regen" for a different shot.`, 'success');
                renderShotDecompositionModal();
                scheduleAutoSave();
                return;
            }

            shot.status = 'generating';
            renderShotDecompositionModal();
            showToast(` Generating shot ${shotIndex + 1}...`, 'info');

            try {
                // Build enhanced prompt
                let enhancedPrompt = shot.prompt;

                // Add consistency anchors if available
                if (decomposed.consistencyAnchors) {
                    enhancedPrompt += `\n\nVISUAL CONSISTENCY:
- Lighting: ${decomposed.consistencyAnchors.lighting || 'cinematic'}
- Colors: ${decomposed.consistencyAnchors.colorPalette || 'rich cinematic'}
- Atmosphere: ${decomposed.consistencyAnchors.atmosphere || 'professional'}`;
                }

                // Add style bible if enabled
                if (state.storyboard.styleBible?.enabled) {
                    enhancedPrompt += `\n\nSTYLE: ${state.storyboard.styleBible.style || ''} ${state.storyboard.styleBible.lighting || ''} ${state.storyboard.styleBible.atmosphere || ''}`;
                }

                // Add technical specs
                if (state.storyboard.technicalSpecs?.enabled) {
                    enhancedPrompt += `\n\n${state.storyboard.technicalSpecs.positive || '4K, ultra detailed, cinematic'}`;
                }

                const generateFn = functions.httpsCallable('generateCreativeImage', { timeout: 180000 });
                const result = await generateFn({
                    prompt: enhancedPrompt,
                    model: state.storyboard.imageModel || 'hidream',
                    quantity: 1,
                    aspectRatio: '16:9',
                    quality: 'hd',
                    negativePrompt: state.storyboard.technicalSpecs?.negative || 'blurry, low quality, watermark, text'
                });

                if (result.data.success && result.data.images && result.data.images.length > 0) {
                    shot.imageUrl = result.data.images[0].url;
                    shot.status = 'ready';
                    shot.fromSceneImage = false;

                    // NOTE: We do NOT sync back to scene image anymore.
                    // The scene's main image stays as it was originally generated.
                    // Shot images are independent and based on their specific prompts.

                    showToast(` Shot ${shotIndex + 1} generated!`, 'success');
                } else {
                    throw new Error(result.data.message || 'No image returned');
                }
            } catch (error) {
                console.error('Shot generation error:', error);
                shot.status = 'error';
                shot.error = error.message;
                showToast(`Failed to generate shot ${shotIndex + 1}: ${error.message}`, 'error');
            }

            renderShotDecompositionModal();
            scheduleAutoSave();
        }

        /**
         * Render the shot decomposition modal
         */
        function renderShotDecompositionModal() {
            const existing = document.getElementById('shot-decomposition-modal');
            if (existing) existing.remove();

            if (!state.storyboard.decompositionModal.open) return;

            const sceneId = state.storyboard.decompositionModal.sceneId;
            const scene = state.script.scenes.find(s => s.id === sceneId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            const sceneIndex = state.script.scenes.findIndex(s => s.id === sceneId);
            const decomposed = state.storyboard.multiShotMode?.decomposedScenes?.[sceneId];
            const modalStatus = state.storyboard.decompositionModal.status;
            const shotCount = state.storyboard.decompositionModal.shotCount;

            if (!scene) return;

            const imageUrl = storyboardScene?.imageUrl || '';
            const hasShots = decomposed && decomposed.shots && decomposed.shots.length > 0;

            const modal = document.createElement('div');
            modal.id = 'shot-decomposition-modal';
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.92); display: flex; align-items: center; justify-content: center; z-index: 1002; padding: 1rem;" onclick="if(event.target === this) closeShotDecompositionModal()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 900px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div style="padding: 1rem 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h3 style="margin: 0; color: white; font-size: 1.1rem; font-weight: 600;"> Shot Decomposition - Scene ${sceneIndex + 1}</h3>
                                <p style="margin: 0.25rem 0 0 0; color: rgba(255,255,255,0.6); font-size: 0.8rem;">Break this scene into multiple cinematic shots</p>
                            </div>
                            <button onclick="closeShotDecompositionModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Content -->
                        <div style="flex: 1; overflow-y: auto; padding: 1.25rem;">
                            <!-- Original Scene Preview -->
                            <div style="margin-bottom: 1.5rem;">
                                <div style="display: flex; gap: 1rem; align-items: flex-start;">
                                    ${imageUrl ? `
                                        <div style="flex-shrink: 0; width: 200px; height: 112px; border-radius: 0.5rem; overflow: hidden; border: 2px solid rgba(139, 92, 246, 0.5);">
                                            <img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">
                                        </div>
                                    ` : `
                                        <div style="flex-shrink: 0; width: 200px; height: 112px; border-radius: 0.5rem; background: rgba(139, 92, 246, 0.1); border: 2px dashed rgba(139, 92, 246, 0.3); display: flex; align-items: center; justify-content: center;">
                                            <span style="color: rgba(255,255,255,0.4); font-size: 0.8rem;">No image yet</span>
                                        </div>
                                    `}
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">SCENE PROMPT</div>
                                            ${(scene.visualPrompt || scene.visual || '').length > 200 ? `
                                                <button onclick="this.closest('.scene-prompt-container').querySelector('.prompt-text').classList.toggle('expanded'); this.textContent = this.textContent === 'Show All' ? 'Show Less' : 'Show All';"
                                                        style="font-size: 0.65rem; color: #8b5cf6; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.3); padding: 0.15rem 0.5rem; border-radius: 0.25rem; cursor: pointer; transition: all 0.2s;">
                                                    Show All
                                                </button>
                                            ` : ''}
                                        </div>
                                        <div class="scene-prompt-container">
                                            <div class="prompt-text" style="font-size: 0.85rem; color: rgba(255,255,255,0.9); line-height: 1.4; max-height: 4.2em; overflow: hidden; transition: max-height 0.3s ease;">
                                                ${scene.visualPrompt || scene.visual || 'No visual prompt'}
                                            </div>
                                            <style>
                                                .prompt-text.expanded { max-height: none !important; }
                                            </style>
                                        </div>
                                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: rgba(255,255,255,0.4);">
                                            Duration: ${scene.duration || 6}s
                                        </div>
                                    </div>
                                </div>
                            </div>

                            ${modalStatus === 'idle' ? (() => {
                                // Hollywood Math: Calculate recommended shots based on scene duration
                                const clipDur = state.script.timing?.clipDuration || 10;
                                const sceneDur = scene.duration || 35;
                                const recommendedShots = Math.ceil(sceneDur / clipDur);
                                const shotDur = Math.round((sceneDur / shotCount) * 10) / 10;

                                return `
                                <!-- Hollywood Scene Math -->
                                <div style="background: rgba(6, 182, 212, 0.1); border: 1px solid rgba(6, 182, 212, 0.3); border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem;">
                                    <div style="font-size: 0.7rem; color: #67e8f9; font-weight: 600; margin-bottom: 0.5rem;"> HOLLYWOOD MATH</div>
                                    <div style="display: flex; gap: 1rem; font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                                        <span>Scene: <strong style="color: white;">${sceneDur}s</strong></span>
                                        <span></span>
                                        <span>Clip: <strong style="color: white;">${clipDur}s</strong></span>
                                        <span>=</span>
                                        <span>Recommended: <strong style="color: #10b981;">${recommendedShots} shots</strong></span>
                                    </div>
                                </div>

                                <!-- Shot Count Selector -->
                                <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.75rem; padding: 1.25rem; margin-bottom: 1rem;">
                                    <div style="font-size: 0.9rem; color: white; font-weight: 600; margin-bottom: 0.75rem;">How many shots?</div>
                                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem;">
                                        ${[2, 3, 4, 5, 6, 7, 8].map(count => `
                                            <button onclick="setDecompositionShotCount(${count})"
                                                    style="flex: 1; min-width: 45px; padding: 0.6rem 0.3rem; border-radius: 0.5rem; border: 2px solid ${shotCount === count ? '#8b5cf6' : count === recommendedShots ? '#10b981' : 'rgba(255,255,255,0.2)'}; background: ${shotCount === count ? 'rgba(139, 92, 246, 0.3)' : count === recommendedShots ? 'rgba(16, 185, 129, 0.15)' : 'rgba(255,255,255,0.05)'}; color: white; cursor: pointer; font-size: 1rem; font-weight: 600; transition: all 0.2s; position: relative;">
                                                ${count}${count === recommendedShots ? '<span style="position: absolute; top: -6px; right: -6px; background: #10b981; color: white; font-size: 0.5rem; padding: 1px 4px; border-radius: 4px;"></span>' : ''}
                                            </button>
                                        `).join('')}
                                    </div>
                                    <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); margin-bottom: 0.5rem;">
                                        ${shotCount === 2 ? 'Minimal: Wide  Close-up' :
                                          shotCount === 3 ? 'Standard: Wide  Medium  Close-up' :
                                          shotCount === 4 ? 'Dynamic: Establishing  Wide  Medium  Close-up' :
                                          shotCount === 5 ? 'Cinematic: Establishing  Wide  Medium  Close-up  Detail' :
                                          shotCount === 6 ? 'Professional: Full shot progression with multiple angles' :
                                          shotCount === 7 ? 'Hollywood: Complete coverage with reaction shots' :
                                          'Epic: Maximum coverage for complex scenes'}
                                    </div>
                                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-bottom: 1rem;">
                                        Each shot will be ~${shotDur}s (${clipDur}s video clips)
                                    </div>
                                    <button onclick="startDecompositionFromModal()"
                                            style="width: 100%; padding: 0.875rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border: none; border-radius: 0.5rem; color: white; font-size: 1rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                         Decompose into ${shotCount} Shots
                                    </button>
                                </div>
                            `; })() : modalStatus === 'decomposing' ? `
                                <!-- Loading State -->
                                <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.75rem; padding: 2rem; text-align: center;">
                                    <div style="width: 50px; height: 50px; margin: 0 auto 1rem; border: 3px solid rgba(139, 92, 246, 0.2); border-top-color: #8b5cf6; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                    <div style="color: white; font-weight: 600; margin-bottom: 0.5rem;">Analyzing scene...</div>
                                    <div style="color: rgba(255,255,255,0.5); font-size: 0.85rem;">AI is breaking down your scene into ${shotCount} cinematic shots</div>
                                </div>
                            ` : modalStatus === 'error' ? `
                                <!-- Error State -->
                                <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                                        <span style="font-size: 1.25rem;"></span>
                                        <span style="color: #ef4444; font-weight: 600;">Decomposition Failed</span>
                                    </div>
                                    <div style="color: rgba(255,255,255,0.7); font-size: 0.85rem; margin-bottom: 1rem;">
                                        ${state.storyboard.decompositionModal.error || 'Unknown error occurred'}
                                    </div>
                                    <button onclick="state.storyboard.decompositionModal.status = 'idle'; renderShotDecompositionModal();"
                                            style="padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; cursor: pointer;">
                                        Try Again
                                    </button>
                                </div>
                            ` : ''}

                            ${hasShots ? `
                                <!-- PHASE 4: Duration Timeline Visualization -->
                                ${(() => {
                                    const totalDuration = decomposed.shots.reduce((sum, s) => sum + (s.selectedDuration || s.calculatedDuration || s.duration || 10), 0);
                                    const dialogueShots = decomposed.shots.filter(s => s.hasDialogue);
                                    const multiVoiceShots = decomposed.shots.filter(s => s.isMultiVoice);
                                    return `
                                    <div style="margin-top: 1rem; margin-bottom: 1rem;">
                                        <!-- Timeline Header -->
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                            <div style="font-size: 0.8rem; color: white; font-weight: 600;"> Duration Timeline</div>
                                            <div style="display: flex; gap: 0.75rem; align-items: center;">
                                                <span style="font-size: 0.65rem; color: rgba(255,255,255,0.6);">Total: <span style="color: #3b82f6; font-weight: 600;">${totalDuration}s</span></span>
                                                ${dialogueShots.length > 0 ? `<span style="font-size: 0.65rem; color: #fbbf24;"> ${dialogueShots.length} with dialogue</span>` : ''}
                                                ${multiVoiceShots.length > 0 ? `<span style="font-size: 0.65rem; color: #a78bfa;"> ${multiVoiceShots.length} multi-voice</span>` : ''}
                                            </div>
                                        </div>
                                        <!-- Visual Timeline Bar -->
                                        <div style="display: flex; height: 32px; background: rgba(0,0,0,0.3); border-radius: 0.5rem; overflow: hidden; border: 1px solid rgba(255,255,255,0.1);">
                                            ${decomposed.shots.map((shot, idx) => {
                                                const duration = shot.selectedDuration || shot.calculatedDuration || shot.duration || 10;
                                                const widthPercent = (duration / totalDuration) * 100;
                                                const hasDialogue = shot.hasDialogue;
                                                const durationClass = duration <= 5 ? 'quick' : duration <= 6 ? 'short' : 'standard';
                                                const bgColor = hasDialogue ? 'rgba(251, 191, 36, 0.4)' :
                                                               durationClass === 'quick' ? 'rgba(34, 197, 94, 0.3)' :
                                                               durationClass === 'short' ? 'rgba(234, 179, 8, 0.3)' : 'rgba(59, 130, 246, 0.3)';
                                                const borderColor = hasDialogue ? 'rgba(251, 191, 36, 0.6)' :
                                                                   durationClass === 'quick' ? 'rgba(34, 197, 94, 0.5)' :
                                                                   durationClass === 'short' ? 'rgba(234, 179, 8, 0.5)' : 'rgba(59, 130, 246, 0.5)';
                                                return '<div style="width: ' + widthPercent + '%; min-width: 30px; background: ' + bgColor + '; border-right: 1px solid ' + borderColor + '; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s;" ' +
                                                     'onclick="openShotPreviewModal(' + sceneId + ', ' + idx + ')" ' +
                                                     'title="Shot ' + (idx + 1) + ': ' + duration + 's' + (hasDialogue ? ' (dialogue)' : '') + '">' +
                                                    '<div style="font-size: 0.6rem; font-weight: 600; color: white;">' + (idx + 1) + '</div>' +
                                                    '<div style="font-size: 0.5rem; color: rgba(255,255,255,0.7);">' + duration + 's</div>' +
                                                    (hasDialogue ? '<div style="font-size: 0.4rem;"></div>' : '') +
                                                '</div>';
                                            }).join('')}
                                        </div>
                                        <!-- Legend -->
                                        <div style="display: flex; gap: 1rem; margin-top: 0.35rem; justify-content: center;">
                                            <span style="font-size: 0.5rem; display: flex; align-items: center; gap: 0.2rem;"><span style="width: 8px; height: 8px; background: rgba(34, 197, 94, 0.5); border-radius: 2px;"></span> 5s</span>
                                            <span style="font-size: 0.5rem; display: flex; align-items: center; gap: 0.2rem;"><span style="width: 8px; height: 8px; background: rgba(234, 179, 8, 0.5); border-radius: 2px;"></span> 6s</span>
                                            <span style="font-size: 0.5rem; display: flex; align-items: center; gap: 0.2rem;"><span style="width: 8px; height: 8px; background: rgba(59, 130, 246, 0.5); border-radius: 2px;"></span> 10s</span>
                                            <span style="font-size: 0.5rem; display: flex; align-items: center; gap: 0.2rem;"><span style="width: 8px; height: 8px; background: rgba(251, 191, 36, 0.5); border-radius: 2px;"></span>  Dialogue</span>
                                        </div>
                                    </div>
                                `})()}

                                <!-- PHASE 6: Pipeline Health Status Indicator -->
                                ${(() => {
                                    const qa = decomposed.qualityAssurance || {};
                                    const pipeline = decomposed.pipelineVerification || {};
                                    const qaStatus = qa.status || 'unknown';
                                    const pipelineStatus = pipeline.status || 'unknown';
                                    const passRate = pipeline.passRate || 0;

                                    const statusConfig = {
                                        'healthy': { icon: '[OK]', color: '#22c55e', label: 'Healthy' },
                                        'pass': { icon: '[OK]', color: '#22c55e', label: 'Pass' },
                                        'degraded': { icon: '[!]', color: '#fbbf24', label: 'Degraded' },
                                        'warning': { icon: '[!]', color: '#fbbf24', label: 'Warning' },
                                        'unhealthy': { icon: '[X]', color: '#ef4444', label: 'Unhealthy' },
                                        'fail': { icon: '[X]', color: '#ef4444', label: 'Failed' },
                                        'unknown': { icon: '[?]', color: '#6b7280', label: 'Unknown' }
                                    };

                                    const qaConfig = statusConfig[qaStatus] || statusConfig['unknown'];
                                    const pipelineConfig = statusConfig[pipelineStatus] || statusConfig['unknown'];

                                    // Only show if we have status data
                                    if (!qa.status && !pipeline.status) return '';

                                    const qaBgRgb = qaConfig.color === '#22c55e' ? '34, 197, 94' : qaConfig.color === '#fbbf24' ? '251, 191, 36' : '239, 68, 68';
                                    const pipeBgRgb = pipelineConfig.color === '#22c55e' ? '34, 197, 94' : pipelineConfig.color === '#fbbf24' ? '251, 191, 36' : '239, 68, 68';
                                    const issuesHtml = qa.issues && qa.issues.length > 0
                                        ? '<div style="font-size: 0.55rem; color: #fbbf24;" title="' + qa.issues.join(', ') + '">! ' + qa.issues.length + ' issue' + (qa.issues.length > 1 ? 's' : '') + '</div>'
                                        : '';

                                    return '<div style="margin: 0.75rem 0; padding: 0.5rem 0.75rem; background: rgba(139, 92, 246, 0.05); border: 1px solid rgba(139, 92, 246, 0.15); border-radius: 0.5rem;">' +
                                        '<div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem;">' +
                                            '<div style="display: flex; align-items: center; gap: 0.5rem;">' +
                                                '<span style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">Quality:</span>' +
                                                '<span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(' + qaBgRgb + ', 0.15); border: 1px solid ' + qaConfig.color + '40; border-radius: 0.25rem; color: ' + qaConfig.color + ';">' +
                                                    qaConfig.icon + ' ' + qaConfig.label +
                                                '</span>' +
                                            '</div>' +
                                            '<div style="display: flex; align-items: center; gap: 0.5rem;">' +
                                                '<span style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">Pipeline:</span>' +
                                                '<span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(' + pipeBgRgb + ', 0.15); border: 1px solid ' + pipelineConfig.color + '40; border-radius: 0.25rem; color: ' + pipelineConfig.color + ';">' +
                                                    pipelineConfig.icon + ' ' + pipelineConfig.label + ' (' + passRate + '%)' +
                                                '</span>' +
                                            '</div>' +
                                            issuesHtml +
                                        '</div>' +
                                    '</div>';
                                })()}

                                <!-- Frame Chain Pipeline Header -->
                                <div style="margin-top: 1rem;">
                                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
                                        <div>
                                            <div style="font-size: 0.9rem; color: white; font-weight: 600;">Shot Timeline</div>
                                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">
                                                 Frame Chain: Scene image  Shot 1 video  Last frame  Shot 2 video  ...
                                            </div>
                                        </div>
                                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">
                                                 ${decomposed.shots.filter(s => s.status === 'ready' && s.imageUrl).length}/${decomposed.shots.length}
                                            </span>
                                            <span style="font-size: 0.7rem; color: rgba(6, 182, 212, 0.8);">
                                                 ${decomposed.shots.filter(s => s.videoStatus === 'ready' && s.videoUrl).length}/${decomposed.shots.length}
                                            </span>
                                        </div>
                                    </div>

                                    <!-- Visual Timeline with Frame Chain connectors -->
                                    <div style="position: relative; display: flex; align-items: flex-start; gap: 0.75rem; padding: 0.5rem 0; overflow-x: auto;">
                                        ${decomposed.shots.map((shot, idx) => {
                                            const hasImage = shot.status === 'ready' && shot.imageUrl;
                                            const hasVideo = shot.videoStatus === 'ready' && shot.videoUrl;
                                            const isGeneratingVideo = shot.videoStatus === 'generating' || shot.videoStatus === 'processing';
                                            const wasTransferred = shot.transferredFrom !== undefined;
                                            const nextShot = decomposed.shots[idx + 1];
                                            const isLastShot = idx === decomposed.shots.length - 1;

                                            return `
                                            <div style="flex: 1; min-width: 160px; max-width: 200px; position: relative;">
                                                <!-- Frame Chain Connector -->
                                                ${!isLastShot ? `
                                                    <div style="position: absolute; top: 55px; right: -0.75rem; width: 1.5rem; height: 24px; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 3;">
                                                        ${hasVideo ? `
                                                            <div style="font-size: 1rem; color: ${nextShot?.transferredFrom === idx ? '#10b981' : 'rgba(139, 92, 246, 0.6)'};">
                                                                ${nextShot?.transferredFrom === idx ? '' : ''}
                                                            </div>
                                                        ` : `
                                                            <div style="width: 100%; height: 2px; background: rgba(255,255,255,0.15);"></div>
                                                        `}
                                                    </div>
                                                ` : ''}

                                                <!-- Shot Card -->
                                                <div style="background: rgba(255,255,255,0.05); border: 1px solid ${wasTransferred ? 'rgba(16, 185, 129, 0.4)' : hasVideo ? 'rgba(6, 182, 212, 0.4)' : 'rgba(255,255,255,0.15)'}; border-radius: 0.5rem; overflow: hidden; position: relative; z-index: 1;">
                                                    <!-- Shot Number Badge -->
                                                    <div style="position: absolute; top: 0.25rem; left: 0.25rem; background: rgba(0,0,0,0.7); color: white; padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.6rem; font-weight: 600; z-index: 2;">
                                                        ${idx + 1}
                                                    </div>

                                                    <!-- Shot Type Badge -->
                                                    <div style="position: absolute; top: 0.25rem; right: 0.25rem; background: rgba(139, 92, 246, 0.8); color: white; padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.55rem; z-index: 2;">
                                                        ${shot.shotType || 'shot'}
                                                    </div>

                                                    <!-- PHASE 4: Audio Type Indicator Badge (Enhanced) -->
                                                    <!-- Uses backend shot.audioType: 'dialogue', 'voiceover', 'music_only', 'sfx', 'internal_monologue' -->
                                                    <!-- Uses backend shot.requiresLipSync to determine if Multitalk is needed -->
                                                    ${(() => {
                                                        const backendAudioType = shot.audioType || 'music_only';
                                                        const hasDialogue = shot.hasDialogue && shot.dialogue?.length > 0;
                                                        const hasNarration = shot.hasNarration || false;  // New: narrator voiceover flag
                                                        const isMultiVoice = shot.isMultiVoice || (shot.uniqueVoiceCount && shot.uniqueVoiceCount > 1);
                                                        const hasTTS = shot.ttsConfig && shot.ttsConfig.lines?.length > 0;
                                                        // Use backend requiresLipSync flag - only true for character dialogue, NOT narrator
                                                        const needsLipSync = shot.requiresLipSync || false;

                                                        // Determine display type based on backend audioType + dialogue info
                                                        let displayType = 'music';
                                                        if (backendAudioType === 'voiceover' || hasNarration) {
                                                            displayType = 'narrator';  // Narrator voiceover - no lip-sync
                                                        } else if (backendAudioType === 'internal_monologue') {
                                                            displayType = 'internal';
                                                        } else if (backendAudioType === 'sfx') {
                                                            displayType = 'sfx';
                                                        } else if (hasDialogue && !hasNarration) {
                                                            displayType = isMultiVoice ? 'multi-voice' : 'character';  // Character dialogue - needs lip-sync
                                                        }

                                                        const audioConfig = {
                                                            'narrator': { icon: '', label: 'Narrator', bg: 'rgba(34, 197, 94, 0.9)', title: 'Narrator voiceover (no lip-sync)', border: 'rgba(34, 197, 94, 1)' },
                                                            'character': { icon: '', label: 'Character', bg: 'rgba(251, 191, 36, 0.9)', title: 'Character dialogue (lip-sync)', border: 'rgba(251, 191, 36, 1)' },
                                                            'multi-voice': { icon: '', label: 'Multi', bg: 'rgba(167, 139, 250, 0.9)', title: 'Multiple characters (lip-sync)', border: 'rgba(167, 139, 250, 1)' },
                                                            'internal': { icon: '', label: 'Thought', bg: 'rgba(96, 165, 250, 0.9)', title: 'Internal monologue (no lip-sync)', border: 'rgba(96, 165, 250, 1)' },
                                                            'sfx': { icon: '', label: 'SFX', bg: 'rgba(249, 115, 22, 0.9)', title: 'Sound effects', border: 'rgba(249, 115, 22, 1)' },
                                                            'music': { icon: '', label: 'Music', bg: 'rgba(59, 130, 246, 0.7)', title: 'Background music only', border: 'rgba(59, 130, 246, 1)' }
                                                        };
                                                        const config = audioConfig[displayType];

                                                        return `
                                                            <div style="position: absolute; top: 1.5rem; right: 0.25rem; display: flex; flex-direction: column; gap: 0.15rem; z-index: 2;">
                                                                <!-- Audio Type Badge -->
                                                                <div style="background: ${config.bg}; color: white; padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-size: 0.45rem; display: flex; align-items: center; gap: 0.1rem; border: 1px solid ${config.border};" title="${config.title}${hasTTS ? ' - TTS Ready' : ''}">
                                                                    ${config.icon} ${config.label}${hasTTS ? ' ' : ''}
                                                                </div>
                                                                <!-- Lip-Sync Indicator (only for character dialogue) -->
                                                                ${needsLipSync ? `
                                                                    <div style="background: rgba(236, 72, 153, 0.9); color: white; padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-size: 0.4rem; display: flex; align-items: center; gap: 0.1rem; border: 1px solid rgba(236, 72, 153, 1);" title="This shot requires Multitalk lip-sync video generation">
                                                                         Lip-Sync
                                                                    </div>
                                                                ` : ''}
                                                            </div>
                                                        `;
                                                    })()}

                                                    <!-- Video Model Badge (shows which AI model will be used) -->
                                                    ${(() => {
                                                        const modelInfo = getVideoModelForShot(shot);
                                                        const isCharacterMode = modelInfo.model === 'S2V-01';
                                                        const bgColor = isCharacterMode ? 'rgba(16, 185, 129, 0.9)' : 'rgba(59, 130, 246, 0.8)';
                                                        const icon = isCharacterMode ? '' : '';
                                                        const label = isCharacterMode ? 'Character' : 'Standard';
                                                        return hasImage && !hasVideo ? `
                                                            <div style="position: absolute; bottom: 0.25rem; right: 0.25rem; background: ${bgColor}; color: white; padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-size: 0.5rem; z-index: 2; display: flex; align-items: center; gap: 0.15rem;" title="${modelInfo.reason}">
                                                                ${icon} ${label}
                                                            </div>
                                                        ` : '';
                                                    })()}

                                                    <!-- Transferred Badge -->
                                                    ${wasTransferred ? `
                                                        <div style="position: absolute; top: 0.25rem; left: 50%; transform: translateX(-50%); background: rgba(16, 185, 129, 0.9); color: white; padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-size: 0.5rem; z-index: 2;">
                                                             from ${shot.transferredFrom + 1}
                                                        </div>
                                                    ` : ''}

                                                    <!-- Image/Video Area (clickable for preview) -->
                                                    <div onclick="${hasImage ? `openShotPreviewModal(${sceneId}, ${idx})` : ''}" style="height: 90px; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; position: relative; ${hasImage ? 'cursor: pointer;' : ''}">
                                                        ${hasImage ? `
                                                            <img src="${shot.imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">
                                                            <!-- Hover overlay for preview hint -->
                                                            <div style="position: absolute; inset: 0; background: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s;" onmouseenter="this.style.opacity=1" onmouseleave="this.style.opacity=0">
                                                                <span style="font-size: 1.2rem; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${hasVideo ? '' : ''}</span>
                                                            </div>
                                                            <div style="position: absolute; bottom: 0.25rem; right: 0.25rem; display: flex; gap: 0.15rem;">
                                                                <div style="width: 14px; height: 14px; background: rgba(16, 185, 129, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                                                    <span style="color: white; font-size: 7px;"></span>
                                                                </div>
                                                                ${hasVideo ? `
                                                                    <div style="width: 14px; height: 14px; background: rgba(6, 182, 212, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                                                        <span style="color: white; font-size: 7px;"></span>
                                                                    </div>
                                                                ` : ''}
                                                            </div>
                                                        ` : shot.status === 'generating' ? `
                                                            <div style="display: flex; flex-direction: column; align-items: center;">
                                                                <div style="width: 24px; height: 24px; border: 2px solid rgba(139, 92, 246, 0.2); border-top-color: #8b5cf6; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                                                <span style="font-size: 0.6rem; color: rgba(255,255,255,0.5); margin-top: 0.25rem;">Generating image...</span>
                                                            </div>
                                                        ` : isGeneratingVideo && hasImage ? (() => {
                                                            const elapsedSecs = shot.videoPollStartTime ? Math.floor((Date.now() - shot.videoPollStartTime) / 1000) : 0;
                                                            const elapsedStr = elapsedSecs > 0 ? `${Math.floor(elapsedSecs / 60)}:${(elapsedSecs % 60).toString().padStart(2, '0')}` : '';
                                                            return `
                                                            <!-- Video generating with image visible -->
                                                            <img src="${shot.imageUrl}" style="width: 100%; height: 100%; object-fit: cover; filter: brightness(0.5);">
                                                            <div style="position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.5);">
                                                                <div style="width: 36px; height: 36px; border: 3px solid rgba(6, 182, 212, 0.3); border-top-color: #06b6d4; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                                                <span style="font-size: 0.65rem; color: #67e8f9; margin-top: 0.5rem; font-weight: 600; text-shadow: 0 1px 3px rgba(0,0,0,0.8);">
                                                                    ${shot.videoStatus === 'generating' ? ' Starting...' : ` ${elapsedStr || 'Rendering...'}`}
                                                                </span>
                                                                ${shot.videoPollCount > 0 ? `<span style="font-size: 0.5rem; color: rgba(255,255,255,0.6); margin-top: 0.2rem;">Check #${shot.videoPollCount}</span>` : ''}
                                                            </div>
                                                        `})() : isGeneratingVideo ? `
                                                            <div style="display: flex; flex-direction: column; align-items: center;">
                                                                <div style="width: 28px; height: 28px; border: 3px solid rgba(6, 182, 212, 0.2); border-top-color: #06b6d4; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                                                <span style="font-size: 0.6rem; color: #67e8f9; margin-top: 0.25rem;">Animating...</span>
                                                            </div>
                                                        ` : shot.status === 'error' ? `
                                                            <div style="text-align: center;">
                                                                <span style="font-size: 1.25rem;"></span>
                                                                <div style="font-size: 0.6rem; color: #ef4444; margin-top: 0.25rem;">Error</div>
                                                            </div>
                                                        ` : `
                                                            <div style="text-align: center;">
                                                                <span style="font-size: 1.5rem; color: rgba(255,255,255,0.3);"></span>
                                                            </div>
                                                        `}
                                                    </div>

                                                    <!-- Shot Info & Actions -->
                                                    <div style="padding: 0.4rem;">
                                                        <div style="font-size: 0.6rem; color: rgba(255,255,255,0.6); margin-bottom: 0.3rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                                            ${shot.cameraMovement || 'static'}  <span style="color: ${shot.durationClass === 'quick' ? '#22c55e' : shot.durationClass === 'short' ? '#eab308' : '#3b82f6'};">${shot.selectedDuration || shot.calculatedDuration || shot.duration || 10}s</span>${shot.hasDialogue ? ' ' : ''}
                                                        </div>
                                                        <!-- NEW: Narrative Beat Display - shows ACTION for video -->
                                                        ${shot.narrativeBeat?.motionDescription ? `
                                                            <div style="font-size: 0.55rem; color: #67e8f9; margin-bottom: 0.3rem; max-height: 2.4em; overflow: hidden; line-height: 1.2;" title="${shot.narrativeBeat.motionDescription}">
                                                                 ${shot.narrativeBeat.motionDescription.slice(0, 60)}${shot.narrativeBeat.motionDescription.length > 60 ? '...' : ''}
                                                            </div>
                                                        ` : ''}

                                                        <!-- PHASE 1: Dialogue Display - shows character dialogue in this shot -->
                                                        <!-- PHASE 3: Enhanced with voice profile info -->
                                                        ${shot.hasDialogue && shot.dialogue?.length > 0 ? `
                                                            <div style="font-size: 0.5rem; background: rgba(251, 191, 36, 0.15); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 0.25rem; padding: 0.25rem; margin-bottom: 0.3rem;">
                                                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.15rem;">
                                                                    <span style="color: #fbbf24; font-weight: 600;"> Dialogue</span>
                                                                    ${shot.uniqueVoiceCount > 0 ? `
                                                                        <span style="color: #a78bfa; font-size: 0.45rem;"> ${shot.uniqueVoiceCount} voice${shot.uniqueVoiceCount > 1 ? 's' : ''}</span>
                                                                    ` : ''}
                                                                </div>
                                                                ${shot.dialogue.slice(0, 2).map(d => `
                                                                    <div style="color: rgba(255,255,255,0.8); line-height: 1.3; margin-bottom: 0.1rem;">
                                                                        <span style="color: #fbbf24; font-weight: 500;">${d.character}</span>${d.voice?.voiceProfile?.name ? `<span style="color: #a78bfa; font-size: 0.4rem;"> (${d.voice.voiceProfile.name})</span>` : ''}: "${d.line?.slice(0, 35)}${d.line?.length > 35 ? '...' : ''}"
                                                                    </div>
                                                                `).join('')}
                                                                ${shot.dialogue.length > 2 ? `<div style="color: rgba(255,255,255,0.5);">+${shot.dialogue.length - 2} more...</div>` : ''}
                                                            </div>
                                                        ` : ''}

                                                        <!-- PHASE 2: Duration Control - flexible shot timing (Enhanced) -->
                                                        <div style="font-size: 0.5rem; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 0.25rem; padding: 0.25rem; margin-bottom: 0.3rem;">
                                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.15rem;">
                                                                <span style="color: #3b82f6; font-weight: 600;"> Duration</span>
                                                                <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                                    <!-- Raw calculated duration (before Minimax rounding) -->
                                                                    ${shot.rawOptimalDuration && shot.rawOptimalDuration !== (shot.selectedDuration || shot.calculatedDuration || shot.duration) ? `
                                                                        <span style="color: rgba(255,255,255,0.4); font-size: 0.4rem; text-decoration: line-through;" title="Raw calculation before Minimax rounding">
                                                                            ${shot.rawOptimalDuration}s
                                                                        </span>
                                                                        <span style="color: rgba(255,255,255,0.4);"></span>
                                                                    ` : ''}
                                                                    <!-- Final duration (Minimax-compatible) -->
                                                                    <span style="color: ${shot.durationClass === 'quick' ? '#22c55e' : shot.durationClass === 'short' ? '#eab308' : '#3b82f6'}; font-weight: 500;">
                                                                        ${shot.selectedDuration || shot.calculatedDuration || shot.duration || 10}s
                                                                        ${shot.requiresStitching ? ' (stitched)' : ''}
                                                                    </span>
                                                                </div>
                                                            </div>

                                                            <!-- Duration Factors Breakdown (when available) -->
                                                            ${shot.durationFactors ? (() => {
                                                                const df = shot.durationFactors;
                                                                let factors = [];
                                                                if (df.dialogue && df.dialogue.hasDialogue) {
                                                                    factors.push('<span style="background: rgba(251, 191, 36, 0.2); border: 1px solid rgba(251, 191, 36, 0.4); padding: 0.1rem 0.2rem; border-radius: 0.15rem; color: #fbbf24; font-size: 0.4rem;" title="Dialogue duration"> ' + (df.dialogue.totalWithBuffer ? df.dialogue.totalWithBuffer.toFixed(1) : '0') + 's</span>');
                                                                }
                                                                if (df.shotType && df.shotType.name) {
                                                                    factors.push('<span style="background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); padding: 0.1rem 0.2rem; border-radius: 0.15rem; color: #a78bfa; font-size: 0.4rem;" title="Shot type"> ' + df.shotType.name + '</span>');
                                                                }
                                                                if (df.action && df.action.actionCount > 0) {
                                                                    factors.push('<span style="background: rgba(249, 115, 22, 0.2); border: 1px solid rgba(249, 115, 22, 0.4); padding: 0.1rem 0.2rem; border-radius: 0.15rem; color: #fb923c; font-size: 0.4rem;" title="Action"> ' + (df.action.minimum ? df.action.minimum.toFixed(1) : '0') + 's</span>');
                                                                }
                                                                return factors.length > 0 ? '<div style="display: flex; flex-wrap: wrap; gap: 0.2rem; margin-bottom: 0.15rem;">' + factors.join('') + '</div>' : '';
                                                            })() : ''}

                                                            <div style="display: flex; gap: 0.2rem; margin-bottom: 0.15rem;">
                                                                <button onclick="setShotDuration(${sceneId}, ${idx}, 5); event.stopPropagation();"
                                                                        style="flex: 1; padding: 0.15rem 0.25rem; background: ${(shot.selectedDuration || shot.calculatedDuration || 10) === 5 ? 'rgba(34, 197, 94, 0.3)' : 'rgba(255,255,255,0.1)'}; border: 1px solid ${(shot.selectedDuration || shot.calculatedDuration || 10) === 5 ? 'rgba(34, 197, 94, 0.5)' : 'rgba(255,255,255,0.2)'}; border-radius: 0.2rem; color: white; cursor: pointer; font-size: 0.5rem;">
                                                                    5s
                                                                </button>
                                                                <button onclick="setShotDuration(${sceneId}, ${idx}, 6); event.stopPropagation();"
                                                                        style="flex: 1; padding: 0.15rem 0.25rem; background: ${(shot.selectedDuration || shot.calculatedDuration || 10) === 6 ? 'rgba(234, 179, 8, 0.3)' : 'rgba(255,255,255,0.1)'}; border: 1px solid ${(shot.selectedDuration || shot.calculatedDuration || 10) === 6 ? 'rgba(234, 179, 8, 0.5)' : 'rgba(255,255,255,0.2)'}; border-radius: 0.2rem; color: white; cursor: pointer; font-size: 0.5rem;">
                                                                    6s
                                                                </button>
                                                                <button onclick="setShotDuration(${sceneId}, ${idx}, 10); event.stopPropagation();"
                                                                        style="flex: 1; padding: 0.15rem 0.25rem; background: ${(shot.selectedDuration || shot.calculatedDuration || 10) === 10 ? 'rgba(59, 130, 246, 0.3)' : 'rgba(255,255,255,0.1)'}; border: 1px solid ${(shot.selectedDuration || shot.calculatedDuration || 10) === 10 ? 'rgba(59, 130, 246, 0.5)' : 'rgba(255,255,255,0.2)'}; border-radius: 0.2rem; color: white; cursor: pointer; font-size: 0.5rem;">
                                                                    10s
                                                                </button>
                                                            </div>
                                                            ${shot.durationRecommendation ? `
                                                                <div style="color: rgba(255,255,255,0.5); font-size: 0.45rem; line-height: 1.2;">
                                                                     ${shot.durationRecommendation}
                                                                </div>
                                                            ` : `
                                                                <div style="color: rgba(255,255,255,0.4); font-size: 0.4rem; line-height: 1.2;">
                                                                     Minimax video clips: 5s, 6s, or 10s
                                                                </div>
                                                            `}
                                                            ${shot.requiresStitching && shot.stitchingStrategy ? `
                                                                <div style="color: rgba(251, 146, 60, 0.8); font-size: 0.45rem; margin-top: 0.1rem;">
                                                                     ${shot.stitchingStrategy.clipCount} clips: ${shot.stitchingStrategy.clips?.map(c => c.duration + 's').join(' + ')}
                                                                </div>
                                                            ` : ''}
                                                        </div>

                                                        <!-- Action Buttons Grid -->
                                                        <div style="display: flex; flex-direction: column; gap: 0.25rem;">
                                                            ${shot.videoStatus === 'error' ? `
                                                                <!-- Video Error State -->
                                                                <div style="text-align: center; padding: 0.35rem; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.3rem;">
                                                                    <div style="font-size: 0.55rem; color: #f87171; font-weight: 500;">
                                                                         Video failed
                                                                    </div>
                                                                    <div style="font-size: 0.5rem; color: rgba(255,255,255,0.4); margin-top: 0.1rem; max-height: 24px; overflow: hidden;">
                                                                        ${(shot.videoError || 'Generation failed').substring(0, 50)}
                                                                    </div>
                                                                </div>
                                                                <div style="position: relative;">
                                                                    ${state.storyboard.videoModelSelector?.open && state.storyboard.videoModelSelector?.sceneId === sceneId && state.storyboard.videoModelSelector?.shotIndex === idx ? renderVideoModelSelectorPopup() : ''}
                                                                    <button onclick="openVideoModelSelector(${sceneId}, ${idx})"
                                                                            style="width: 100%; padding: 0.3rem; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 0.3rem; color: white; cursor: pointer; font-size: 0.6rem; font-weight: 500;">
                                                                         Retry Animation
                                                                    </button>
                                                                </div>
                                                            ` : shot.status !== 'generating' && !isGeneratingVideo ? `
                                                                <!-- FRAME CHAIN WORKFLOW: No standalone image generation -->
                                                                <!-- Shot 1: Uses scene image (auto-synced) -->
                                                                <!-- Shots 2+: Get image via frame transfer from previous shot's video -->

                                                                ${idx === 0 ? `
                                                                    <!-- Shot 1: Scene Image Status -->
                                                                    ${hasImage ? `
                                                                        <div style="text-align: center; padding: 0.25rem; background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.3rem;">
                                                                            <div style="font-size: 0.55rem; color: #10b981;"> Scene image</div>
                                                                        </div>
                                                                    ` : `
                                                                        <div style="text-align: center; padding: 0.25rem; background: rgba(245, 158, 11, 0.15); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 0.3rem;">
                                                                            <div style="font-size: 0.55rem; color: #f59e0b;"> Generate scene image first</div>
                                                                        </div>
                                                                    `}
                                                                ` : `
                                                                    <!-- Shots 2+: Frame Transfer Status -->
                                                                    ${!hasImage ? `
                                                                        <div style="text-align: center; padding: 0.25rem; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.3rem; margin-bottom: 0.25rem;">
                                                                            <div style="font-size: 0.55rem; color: #a78bfa;"> Waiting for frame from Shot ${idx}</div>
                                                                        </div>
                                                                        <!-- Pre-configure Video Model for this shot -->
                                                                        <div style="position: relative;">
                                                                            ${state.storyboard.videoModelSelector?.open && state.storyboard.videoModelSelector?.sceneId === sceneId && state.storyboard.videoModelSelector?.shotIndex === idx ? renderVideoModelSelectorPopup() : ''}
                                                                            <button onclick="openVideoModelSelector(${sceneId}, ${idx})"
                                                                                    style="width: 100%; padding: 0.25rem; background: ${shot.preConfiguredModel ? 'rgba(16, 185, 129, 0.15)' : 'rgba(139, 92, 246, 0.1)'}; border: 1px solid ${shot.preConfiguredModel ? 'rgba(16, 185, 129, 0.4)' : 'rgba(139, 92, 246, 0.3)'}; border-radius: 0.3rem; color: ${shot.preConfiguredModel ? '#10b981' : 'rgba(255,255,255,0.7)'}; cursor: pointer; font-size: 0.5rem;">
                                                                                ${shot.preConfiguredModel ? (shot.preConfiguredModel.model === 'multitalk' ? ' Multitalk Ready' : ' Minimax Ready') : ' Configure Model'}
                                                                            </button>
                                                                        </div>
                                                                    ` : wasTransferred ? `
                                                                        <div style="text-align: center; padding: 0.25rem; background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.3rem;">
                                                                            <div style="font-size: 0.55rem; color: #10b981;"> Frame from Shot ${shot.transferredFrom + 1}</div>
                                                                        </div>
                                                                    ` : ''}
                                                                `}

                                                                ${hasImage && hasVideo ? `
                                                                    <!-- Play Video -->
                                                                    <button onclick="openShotPreviewModal(${sceneId}, ${idx}); setTimeout(() => switchPreviewTab('video'), 100);"
                                                                            style="width: 100%; padding: 0.3rem; background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(6, 182, 212, 0.3)); border: 1px solid rgba(16, 185, 129, 0.5); border-radius: 0.3rem; color: white; cursor: pointer; font-size: 0.6rem; font-weight: 500;">
                                                                         Play Video
                                                                    </button>
                                                                ` : hasImage ? `
                                                                    <!-- Video Generation with Model Selector -->
                                                                    <div style="position: relative;">
                                                                        ${state.storyboard.videoModelSelector?.open && state.storyboard.videoModelSelector?.sceneId === sceneId && state.storyboard.videoModelSelector?.shotIndex === idx ? renderVideoModelSelectorPopup() : ''}
                                                                        <button onclick="openVideoModelSelector(${sceneId}, ${idx})"
                                                                                style="width: 100%; padding: 0.3rem; background: linear-gradient(135deg, rgba(6, 182, 212, 0.3), rgba(59, 130, 246, 0.3)); border: 1px solid rgba(6, 182, 212, 0.4); border-radius: 0.3rem; color: white; cursor: pointer; font-size: 0.6rem; font-weight: 500;">
                                                                             Animate
                                                                        </button>
                                                                    </div>
                                                                ` : ''}

                                                                ${hasVideo && !isLastShot ? `
                                                                    <!-- Frame Capture & Transfer to Next Shot -->
                                                                    <button onclick="openFrameCaptureModal(${sceneId}, ${idx})"
                                                                            style="width: 100%; padding: 0.3rem; background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(5, 150, 105, 0.3)); border: 1px solid rgba(16, 185, 129, 0.5); border-radius: 0.3rem; color: white; cursor: pointer; font-size: 0.6rem; font-weight: 500;">
                                                                         Capture  Shot ${idx + 2}
                                                                    </button>
                                                                ` : ''}

                                                                ${hasVideo ? `
                                                                    <!-- Re-animate option with model selector -->
                                                                    <div style="position: relative;">
                                                                        ${state.storyboard.videoModelSelector?.open && state.storyboard.videoModelSelector?.sceneId === sceneId && state.storyboard.videoModelSelector?.shotIndex === idx ? renderVideoModelSelectorPopup() : ''}
                                                                        <button onclick="openVideoModelSelector(${sceneId}, ${idx})"
                                                                                style="width: 100%; padding: 0.25rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.3rem; color: rgba(255,255,255,0.6); cursor: pointer; font-size: 0.55rem;">
                                                                             Re-Animate
                                                                        </button>
                                                                    </div>
                                                                ` : ''}
                                                            ` : (() => {
                                                                // Calculate elapsed time for video generation
                                                                const elapsedSecs = shot.videoPollStartTime ? Math.floor((Date.now() - shot.videoPollStartTime) / 1000) : 0;
                                                                const elapsedStr = elapsedSecs > 0 ? `${Math.floor(elapsedSecs / 60)}:${(elapsedSecs % 60).toString().padStart(2, '0')}` : '';
                                                                const pollCount = shot.videoPollCount || 0;

                                                                return `
                                                                <!-- Enhanced Loading Status -->
                                                                <div style="text-align: center; padding: 0.35rem; background: ${shot.status === 'generating' ? 'rgba(139, 92, 246, 0.15)' : 'rgba(6, 182, 212, 0.15)'}; border: 1px solid ${shot.status === 'generating' ? 'rgba(139, 92, 246, 0.3)' : 'rgba(6, 182, 212, 0.3)'}; border-radius: 0.3rem;">
                                                                    <div style="font-size: 0.6rem; color: ${shot.status === 'generating' ? '#a78bfa' : '#67e8f9'}; font-weight: 500;">
                                                                        ${shot.status === 'generating'
                                                                            ? ' Creating image...'
                                                                            : shot.videoStatus === 'generating'
                                                                                ? ' Sending to AI...'
                                                                                : ` Rendering... ${elapsedStr}`}
                                                                    </div>
                                                                    ${shot.videoStatus === 'processing' && pollCount > 0 ? `
                                                                        <div style="font-size: 0.5rem; color: rgba(255,255,255,0.4); margin-top: 0.15rem;">
                                                                            Check #${pollCount}  Usually 1-3 min
                                                                        </div>
                                                                    ` : ''}
                                                                    <div style="margin-top: 0.25rem; height: 3px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden;">
                                                                        <div style="height: 100%; width: ${shot.videoStatus === 'processing' ? Math.min(pollCount * 0.6 + 5, 95) : 60}%; background: linear-gradient(90deg, ${shot.status === 'generating' ? '#8b5cf6' : '#06b6d4'}, ${shot.status === 'generating' ? '#a78bfa' : '#22d3ee'}); transition: width 0.5s;"></div>
                                                                    </div>
                                                                </div>
                                                            `})()}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        `}).join('')}
                                    </div>

                                    <!-- Prompt Details (expandable) -->
                                    <details style="margin-top: 1rem;" class="shot-prompts-details">
                                        <summary style="cursor: pointer; color: rgba(255,255,255,0.6); font-size: 0.8rem; padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                                            <span> View Shot Prompts</span>
                                            <button onclick="event.stopPropagation(); const container = this.closest('.shot-prompts-details'); const prompts = container.querySelectorAll('.shot-prompt-text'); const allExpanded = Array.from(prompts).every(p => p.classList.contains('expanded')); prompts.forEach(p => allExpanded ? p.classList.remove('expanded') : p.classList.add('expanded')); this.textContent = allExpanded ? 'Expand All' : 'Collapse All';"
                                                    style="font-size: 0.6rem; color: #8b5cf6; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.3); padding: 0.15rem 0.4rem; border-radius: 0.25rem; cursor: pointer; margin-left: 0.5rem;">
                                                Expand All
                                            </button>
                                        </summary>
                                        <div style="margin-top: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem;">
                                            ${decomposed.shots.map((shot, idx) => `
                                                <div style="background: rgba(255,255,255,0.03); padding: 0.75rem; border-radius: 0.5rem; border-left: 3px solid rgba(139, 92, 246, 0.5);">
                                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Shot ${idx + 1} - ${shot.shotType || 'shot'}</div>
                                                        ${(shot.prompt || '').length > 150 ? `
                                                            <button onclick="const textEl = this.parentElement.nextElementSibling; textEl.classList.toggle('expanded'); this.textContent = textEl.classList.contains('expanded') ? '' : '+';"
                                                                    style="font-size: 0.7rem; color: #8b5cf6; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.3); width: 18px; height: 18px; border-radius: 0.25rem; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                                                                +
                                                            </button>
                                                        ` : ''}
                                                    </div>
                                                    <div class="shot-prompt-text" style="font-size: 0.8rem; color: rgba(255,255,255,0.8); line-height: 1.4; max-height: 3.6em; overflow: hidden; transition: max-height 0.3s ease;">
                                                        ${shot.prompt || 'No prompt'}
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                        <style>
                                            .shot-prompt-text.expanded { max-height: none !important; }
                                        </style>
                                    </details>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Footer -->
                        <div style="padding: 1rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">
                                ${hasShots ? `${decomposed.shots.length} shots  ${decomposed.totalDuration || scene.duration || 6}s total` : 'Select shot count and decompose'}
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                ${hasShots ? `
                                    <button onclick="closeShotDecompositionModal()"
                                            style="padding: 0.5rem 1.25rem; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer;">
                                         Done
                                    </button>
                                ` : `
                                    <button onclick="closeShotDecompositionModal()"
                                            style="padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; cursor: pointer;">
                                        Cancel
                                    </button>
                                `}
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        /**
         * Generate all shots for a decomposed scene
         */
        async function generateAllShotsForScene(sceneId) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || decomposed.status !== 'ready' || !decomposed.shots.length) {
                showToast('Scene must be decomposed first', 'error');
                return;
            }

            // Mark all shots as generating
            decomposed.shots.forEach(shot => {
                shot.status = 'generating';
            });
            render();
            showToast(` Generating ${decomposed.shots.length} shots...`, 'info');

            // Get character reference if available
            let characterReference = null;
            if (state.storyboard.characterBible?.enabled && state.storyboard.characterBible.characters.length > 0) {
                const charWithRef = state.storyboard.characterBible.characters.find(c => c.referenceImageBase64);
                if (charWithRef) {
                    characterReference = {
                        base64: charWithRef.referenceImageBase64,
                        mimeType: 'image/png'
                    };
                }
            }

            // CRITICAL: Get location reference for this scene
            const locationRef = getLocationReferenceForScene(sceneId);
            if (locationRef) {
                console.log(`[generateAllShotsForScene] Using location: "${locationRef.locationName}" for scene ${sceneId}`);
            } else {
                console.log(`[generateAllShotsForScene] No location reference for scene ${sceneId}`);
            }

            // Generate each shot sequentially for better consistency
            for (let i = 0; i < decomposed.shots.length; i++) {
                const shot = decomposed.shots[i];

                try {
                    // Build enhanced prompt with consistency anchors
                    let enhancedPrompt = shot.prompt;
                    if (decomposed.consistencyAnchors) {
                        enhancedPrompt += `\n\nCONSISTENCY: Lighting=${decomposed.consistencyAnchors.lighting || 'cinematic'}, Colors=${decomposed.consistencyAnchors.colorPalette || 'scene palette'}, Atmosphere=${decomposed.consistencyAnchors.atmosphere || 'consistent'}`;
                    }

                    // CRITICAL: Add location context to prompt if available
                    if (locationRef) {
                        enhancedPrompt += `\n\nLOCATION: ${locationRef.locationName}${locationRef.locationDescription ? ' - ' + locationRef.locationDescription : ''}`;
                        if (locationRef.lightingStyle) {
                            enhancedPrompt += `. Lighting: ${locationRef.lightingStyle}`;
                        }
                        if (locationRef.timeOfDay && locationRef.timeOfDay !== 'day') {
                            enhancedPrompt += `. Time: ${locationRef.timeOfDay}`;
                        }
                        if (locationRef.mood && locationRef.mood !== 'neutral') {
                            enhancedPrompt += `. Mood: ${locationRef.mood}`;
                        }
                    }

                    // Call image generation
                    const generateFn = functions.httpsCallable('generateCreativeImage', { timeout: 300000 });
                    const requestData = {
                        prompt: enhancedPrompt,
                        model: state.storyboard.imageModel || 'nanobanana-pro',
                        quantity: 1,
                        aspectRatio: state.platform.aspectRatio || '16:9',
                        quality: 'hd'
                    };

                    // Add character reference if available
                    if (characterReference) {
                        requestData.characterReference = characterReference;
                    }

                    // CRITICAL: Add location reference image as style reference
                    if (locationRef && locationRef.base64) {
                        requestData.styleReference = {
                            base64: locationRef.base64,
                            mimeType: locationRef.mimeType || 'image/png'
                        };
                        console.log(`[generateAllShotsForScene] Shot ${i + 1}: Added location style reference`);
                    }

                    const result = await generateFn(requestData);

                    if (result.data.success && result.data.images && result.data.images.length > 0) {
                        shot.imageUrl = result.data.images[0].url;
                        shot.status = 'ready';
                        showToast(`Shot ${i + 1}/${decomposed.shots.length} complete!`, 'success');
                    } else {
                        shot.status = 'error';
                        shot.error = 'No image returned';
                    }

                } catch (error) {
                    console.error(`Shot ${i + 1} generation error:`, error);
                    shot.status = 'error';
                    shot.error = error.message || 'Generation failed';
                }

                render();

                // Small delay between shots to avoid rate limiting
                if (i < decomposed.shots.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }

            // Check results
            const successCount = decomposed.shots.filter(s => s.status === 'ready').length;
            if (successCount === decomposed.shots.length) {
                showToast(` All ${successCount} shots generated successfully!`, 'success');
            } else {
                showToast(`Generated ${successCount}/${decomposed.shots.length} shots. Some failed.`, 'warning');
            }

            scheduleAutoSave();
        }

        /**
         * Generate a single shot
         */
        async function generateSingleShot(sceneId, shotIndex) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots[shotIndex]) {
                showToast('Shot not found', 'error');
                return;
            }

            const shot = decomposed.shots[shotIndex];
            shot.status = 'generating';
            render();

            try {
                let enhancedPrompt = shot.prompt;
                if (decomposed.consistencyAnchors) {
                    enhancedPrompt += `\n\nCONSISTENCY: Lighting=${decomposed.consistencyAnchors.lighting || 'cinematic'}, Colors=${decomposed.consistencyAnchors.colorPalette || 'scene palette'}`;
                }

                // Get location reference for this scene
                const locationRef = getLocationReferenceForScene(sceneId);
                if (locationRef) {
                    enhancedPrompt += `\n\nLOCATION: ${locationRef.locationName}${locationRef.locationDescription ? ' - ' + locationRef.locationDescription : ''}`;
                    if (locationRef.lightingStyle) enhancedPrompt += `. Lighting: ${locationRef.lightingStyle}`;
                }

                // Get character reference if available
                let characterReference = null;
                if (state.storyboard.characterBible?.enabled) {
                    const charWithRef = state.storyboard.characterBible.characters.find(c => c.referenceImageBase64);
                    if (charWithRef) {
                        characterReference = { base64: charWithRef.referenceImageBase64, mimeType: 'image/png' };
                    }
                }

                const generateFn = functions.httpsCallable('generateCreativeImage', { timeout: 300000 });
                const requestData = {
                    prompt: enhancedPrompt,
                    model: state.storyboard.imageModel || 'nanobanana-pro',
                    quantity: 1,
                    aspectRatio: state.platform.aspectRatio || '16:9',
                    quality: 'hd'
                };

                // Add references
                if (characterReference) requestData.characterReference = characterReference;
                if (locationRef && locationRef.base64) {
                    requestData.styleReference = { base64: locationRef.base64, mimeType: locationRef.mimeType || 'image/png' };
                }

                const result = await generateFn(requestData);

                if (result.data.success && result.data.images && result.data.images.length > 0) {
                    shot.imageUrl = result.data.images[0].url;
                    shot.status = 'ready';
                    showToast(`Shot ${shotIndex + 1} generated!`, 'success');
                } else {
                    throw new Error('No image returned');
                }

            } catch (error) {
                console.error(`Shot ${shotIndex + 1} generation error:`, error);
                shot.status = 'error';
                shot.error = error.message || 'Generation failed';
                showToast(`Shot ${shotIndex + 1} failed: ${error.message}`, 'error');
            }

            render();
            scheduleAutoSave();
        }

        /**
         * Select a shot to view in the main preview
         */
        function selectShot(sceneId, shotIndex) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (decomposed) {
                decomposed.selectedShot = shotIndex;
                render();
            }
        }

        /**
         * Clear shot decomposition for a scene
         */
        function clearShotDecomposition(sceneId) {
            if (state.storyboard.multiShotMode.decomposedScenes[sceneId]) {
                delete state.storyboard.multiShotMode.decomposedScenes[sceneId];
                render();
                scheduleAutoSave();
                showToast('Shot decomposition cleared', 'info');
            }
        }

        // ==========================================
        // PHASE 12B: SHOT VIDEO GENERATION
        // ==========================================

        /**
         * Generate videos for all shots in a scene
         */
        async function generateAllShotVideosForScene(sceneId) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || decomposed.status !== 'ready' || !decomposed.shots.length) {
                showToast('Generate images first before creating videos', 'error');
                return;
            }

            // Check that all shots have images
            const shotsWithImages = decomposed.shots.filter(s => s.imageUrl && s.status === 'ready');
            if (shotsWithImages.length === 0) {
                showToast('No shot images ready. Generate images first.', 'error');
                return;
            }

            // Mark shots as generating video
            shotsWithImages.forEach(shot => {
                shot.videoStatus = 'generating';
            });
            render();
            showToast(` Starting video generation for ${shotsWithImages.length} shots...`, 'info');

            try {
                const generateVideosFn = functions.httpsCallable('creationWizardGenerateAllShotVideos', { timeout: 540000 });
                const result = await generateVideosFn({
                    sceneId,
                    shots: shotsWithImages.map(shot => ({
                        id: shot.id,
                        imageUrl: shot.imageUrl,
                        prompt: shot.prompt,
                        cameraMovement: shot.cameraMovement,
                        duration: shot.duration
                    }))
                });

                if (result.data.success) {
                    // Store task IDs for polling
                    result.data.shots.forEach(resultShot => {
                        const shot = decomposed.shots.find(s => s.id === resultShot.shotId);
                        if (shot && resultShot.taskId) {
                            shot.videoTaskId = resultShot.taskId;
                            shot.videoStatus = 'processing';
                        } else if (shot && resultShot.status === 'error') {
                            shot.videoStatus = 'error';
                            shot.videoError = resultShot.error;
                        }
                    });

                    showToast(` ${result.data.startedCount} video generations started! Polling for completion...`, 'success');

                    // Start polling for video completion
                    startShotVideoPolling(sceneId);
                } else {
                    throw new Error('Failed to start video generation');
                }

            } catch (error) {
                console.error('Shot video generation error:', error);
                shotsWithImages.forEach(shot => {
                    shot.videoStatus = 'error';
                    shot.videoError = error.message;
                });
                showToast(`Video generation failed: ${error.message}`, 'error');
            }

            render();
            scheduleAutoSave();
        }

        // ==========================================
        // SMART MODEL SELECTION HELPERS
        // ==========================================

        /**
         * Detect if a shot likely contains characters based on shot type and prompt
         */
        function detectShotHasCharacters(shot) {
            // Shot types that typically contain characters
            const characterShotTypes = [
                'close_up', 'closeup', 'medium', 'medium_wide', 'wide',
                'over_shoulder', 'two_shot', 'group', 'reaction',
                'portrait', 'full_body', 'character'
            ];

            // Check shot type
            const shotType = (shot.shotType || '').toLowerCase().replace(/[_-]/g, '');
            const hasCharacterShotType = characterShotTypes.some(type =>
                shotType.includes(type.replace(/[_-]/g, ''))
            );

            // Check prompt for character-related keywords
            const prompt = (shot.prompt || '').toLowerCase();
            const characterKeywords = [
                'character', 'person', 'man', 'woman', 'he ', 'she ', 'they ',
                'face', 'looking', 'standing', 'walking', 'sitting',
                'protagonist', 'hero', 'villain', 'actor'
            ];
            const hasCharacterInPrompt = characterKeywords.some(kw => prompt.includes(kw));

            // Check if shot references specific characters from Character Bible
            const characterBible = state.storyboard?.characterBible?.characters || [];
            const hasNamedCharacter = characterBible.some(char =>
                prompt.toLowerCase().includes(char.name?.toLowerCase())
            );

            // Determine if shot has characters
            return hasCharacterShotType || hasCharacterInPrompt || hasNamedCharacter;
        }

        /**
         * Get the primary character reference for a shot
         * Returns the first character with a portrait that appears in the shot
         */
        function getCharacterReferenceForShot(shot) {
            const characterBible = state.storyboard?.characterBible?.characters || [];
            if (characterBible.length === 0) return null;

            const prompt = (shot.prompt || '').toLowerCase();

            // Find character mentioned in prompt that has a portrait
            for (const char of characterBible) {
                if (char.referenceImageUrl && char.referenceImageStatus === 'ready') {
                    // Check if this character is mentioned in the prompt
                    if (char.name && prompt.includes(char.name.toLowerCase())) {
                        return {
                            url: char.referenceImageUrl,
                            name: char.name,
                            id: char.id
                        };
                    }
                }
            }

            // If no specific character found but shot has characters, use first available portrait
            if (detectShotHasCharacters(shot)) {
                const charWithPortrait = characterBible.find(c =>
                    c.referenceImageUrl && c.referenceImageStatus === 'ready'
                );
                if (charWithPortrait) {
                    return {
                        url: charWithPortrait.referenceImageUrl,
                        name: charWithPortrait.name,
                        id: charWithPortrait.id
                    };
                }
            }

            return null;
        }

        /**
         * Get current style settings from Style Bible
         */
        function getStyleSettingsForVideo() {
            const styleBible = state.storyboard?.styleBible;
            if (!styleBible?.enabled) return null;

            return {
                style: styleBible.style || styleBible.visualStyle || null,
                colorGrade: styleBible.colorGrade || null,
                lighting: styleBible.lighting || null,
                atmosphere: styleBible.atmosphere || null
            };
        }

        /**
         * Determine which video model will be used for a shot
         * Returns { model: 'S2V-01'|'video-01', reason: string, characterName?: string }
         */
        function getVideoModelForShot(shot) {
            const hasCharacters = detectShotHasCharacters(shot);
            const charRef = getCharacterReferenceForShot(shot);

            if (hasCharacters && charRef) {
                return {
                    model: 'S2V-01',
                    modelName: 'Character Mode',
                    reason: `Using character reference (${charRef.name})`,
                    characterName: charRef.name,
                    characterUrl: charRef.url,
                    hasCharacters: true
                };
            } else if (hasCharacters && !charRef) {
                return {
                    model: 'video-01',
                    modelName: 'Standard Mode',
                    reason: 'Characters detected but no portrait available',
                    hasCharacters: true
                };
            } else {
                return {
                    model: 'video-01',
                    modelName: 'Standard Mode',
                    reason: 'No characters in shot',
                    hasCharacters: false
                };
            }
        }

        // ==========================================
        // VIDEO MODEL SELECTOR - Minimax vs Multitalk
        // ==========================================

        /**
         * Open video model selector popup
         */
        function openVideoModelSelector(sceneId, shotIndex) {
            // Get shot to determine default duration based on dialogue
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            const shot = decomposed?.shots?.[shotIndex];
            const hasDialogue = shot?.hasDialogue || false;
            const requiresLipSync = shot?.requiresLipSync || false;  // Only character dialogue needs lip-sync
            const hasNarration = shot?.hasNarration || false;  // Narrator voiceover - no lip-sync
            // Default: 10s for dialogue shots, 5s for non-dialogue shots
            const defaultDuration = hasDialogue ? '10s' : '5s';

            // Get unique speaking characters from dialogue
            const speakingCharacters = shot?.speakingCharacters || [];
            const uniqueCharacters = [...new Set(speakingCharacters)];

            // Check if shot has pre-configured model settings
            const preConfig = shot?.preConfiguredModel;

            // Default model: Multitalk only for character dialogue (requiresLipSync)
            // Narrator voiceover should use Minimax (audio added in post-production)
            const defaultModel = requiresLipSync ? 'multitalk' : 'minimax';

            // Initialize character audio slots
            let characterAudios = {};
            if (preConfig?.multitalk?.characterAudios) {
                // Load from pre-config
                characterAudios = preConfig.multitalk.characterAudios;
            } else if (uniqueCharacters.length > 0) {
                // Initialize empty slots for each character
                uniqueCharacters.forEach(char => {
                    characterAudios[char] = {
                        audioFile: null,
                        audioUrl: null,
                        audioFileName: null,
                        audioUploadStatus: 'idle',
                        audioDuration: null
                    };
                });
            }

            // Check for previously generated dialogue audio (stored on shot)
            const generatedAudio = shot?.generatedDialogueAudio;
            const hasGeneratedAudio = generatedAudio?.audioUrl;

            state.storyboard.videoModelSelector = {
                open: true,
                sceneId: sceneId,
                shotIndex: shotIndex,
                selectedModel: preConfig?.model || defaultModel,
                selectedDuration: preConfig?.duration || defaultDuration,
                requiresLipSync: requiresLipSync,  // Pass to UI for conditional rendering
                hasNarration: hasNarration,  // Pass to UI for info display
                speakingCharacters: uniqueCharacters,  // List of characters needing audio
                multitalk: {
                    // Priority: 1) Generated dialogue audio, 2) Pre-config, 3) null
                    audioFile: preConfig?.multitalk?.audioFile || null,
                    audioUrl: hasGeneratedAudio ? generatedAudio.audioUrl : (preConfig?.multitalk?.audioUrl || null),
                    audioFileName: hasGeneratedAudio ? `Generated (${generatedAudio.voiceCount || 'multi'} voices)` : (preConfig?.multitalk?.audioFileName || null),
                    audioUploadStatus: hasGeneratedAudio ? 'ready' : (preConfig?.multitalk?.audioUrl ? 'ready' : 'idle'),
                    audioDuration: hasGeneratedAudio ? generatedAudio.audioDuration : (preConfig?.multitalk?.audioDuration || null),
                    // Track dialogue audio generation status
                    dialogueAudioStatus: hasGeneratedAudio ? 'ready' : 'idle',
                    dialogueAudioSeed: generatedAudio?.seed || null,
                    // NEW: Per-character audio slots
                    characterAudios: characterAudios
                }
            };
            render();
            renderShotDecompositionModal();
        }

        /**
         * Close video model selector popup
         */
        function closeVideoModelSelector() {
            state.storyboard.videoModelSelector.open = false;
            render();
            renderShotDecompositionModal();
        }

        /**
         * Select video model in popup
         */
        function selectVideoModel(model) {
            state.storyboard.videoModelSelector.selectedModel = model;
            render();
            renderShotDecompositionModal();
        }

        /**
         * Select video duration in popup (5s or 10s)
         */
        function selectVideoDuration(duration) {
            state.storyboard.videoModelSelector.selectedDuration = duration;
            render();
            renderShotDecompositionModal();
        }

        /**
         * PHASE 2: Set individual shot duration
         * Updates the shot's selected duration and persists to state
         * @param {number} sceneId - Scene ID containing the shot
         * @param {number} shotIndex - Index of the shot within decomposed shots
         * @param {number} duration - Duration in seconds (5, 6, or 10)
         */
        function setShotDuration(sceneId, shotIndex, duration) {
            const scene = state.storyboard.scenes.find(s => s.id === sceneId);
            if (!scene || !scene.decomposedShots || !scene.decomposedShots[shotIndex]) {
                console.warn(`[setShotDuration] Shot not found: scene ${sceneId}, shot ${shotIndex}`);
                return;
            }

            // Update shot's selected duration
            scene.decomposedShots[shotIndex].selectedDuration = duration;
            scene.decomposedShots[shotIndex].duration = duration;

            // Recalculate duration class
            scene.decomposedShots[shotIndex].durationClass =
                duration <= 5 ? 'quick' : duration <= 6 ? 'short' : 'standard';

            console.log(`[setShotDuration] Set shot ${shotIndex} duration to ${duration}s (${scene.decomposedShots[shotIndex].durationClass})`);

            // Re-render to update UI
            render();
            renderShotDecompositionModal();
        }

        /**
         * PHASE 2: Auto-calculate duration for a shot based on its content
         * Uses the FLEXIBLE_DURATION_ENGINE logic (client-side approximation)
         * @param {number} sceneId - Scene ID
         * @param {number} shotIndex - Shot index
         */
        function autoCalculateShotDuration(sceneId, shotIndex) {
            const scene = state.storyboard.scenes.find(s => s.id === sceneId);
            if (!scene || !scene.decomposedShots || !scene.decomposedShots[shotIndex]) {
                console.warn(`[autoCalculateShotDuration] Shot not found: scene ${sceneId}, shot ${shotIndex}`);
                return;
            }

            const shot = scene.decomposedShots[shotIndex];

            // Calculate based on dialogue (client-side approximation)
            let suggestedDuration = 10; // Default

            if (shot.hasDialogue && shot.dialogue && shot.dialogue.length > 0) {
                // Calculate dialogue duration: ~2.5 words/second + buffer
                const WORDS_PER_SECOND = 2.5;
                const VISUAL_BUFFER = 1.5;

                let totalWords = 0;
                shot.dialogue.forEach(d => {
                    const words = (d.line || '').trim().split(/\s+/).length;
                    totalWords += words;
                });

                const dialogueDuration = totalWords / WORDS_PER_SECOND + VISUAL_BUFFER;

                // Round to Minimax durations
                if (dialogueDuration <= 5.5) suggestedDuration = 5;
                else if (dialogueDuration <= 8) suggestedDuration = 6;
                else suggestedDuration = 10;
            } else {
                // Non-dialogue shots: use shot type hints
                const shotType = (shot.shotType || '').toLowerCase();
                if (/establishing|wide|master/.test(shotType)) {
                    suggestedDuration = 5;
                } else if (/close.*up|insert|detail|reaction/.test(shotType)) {
                    suggestedDuration = 5;
                } else {
                    suggestedDuration = 10;
                }
            }

            // Apply the calculated duration
            setShotDuration(sceneId, shotIndex, suggestedDuration);
            showToast(`Duration auto-set to ${suggestedDuration}s`, 'success');
        }

        /**
         * Handle audio file selection for Multitalk
         */
        /**
         * Handle audio file selection for a specific character
         * @param {Event} event - File input change event
         * @param {string} characterName - Name of the character this audio is for
         */
        async function handleMultitalkAudioSelectForCharacter(event, characterName) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.startsWith('audio/')) {
                showToast('Please select an audio file (MP3, WAV, etc.)', 'error');
                return;
            }

            // Validate file size (max 50MB)
            if (file.size > 50 * 1024 * 1024) {
                showToast('Audio file too large. Max 50MB.', 'error');
                return;
            }

            // Initialize character audio slot if needed
            if (!state.storyboard.videoModelSelector.multitalk.characterAudios[characterName]) {
                state.storyboard.videoModelSelector.multitalk.characterAudios[characterName] = {};
            }

            const charAudio = state.storyboard.videoModelSelector.multitalk.characterAudios[characterName];
            charAudio.audioFile = file;
            charAudio.audioFileName = file.name;
            charAudio.audioUploadStatus = 'uploading';
            render();
            renderShotDecompositionModal();

            try {
                // Get audio duration
                const audioDuration = await getAudioDuration(file);
                charAudio.audioDuration = audioDuration;

                // Upload to Firebase Storage
                const { sceneId, shotIndex } = state.storyboard.videoModelSelector;
                const projectId = state.project.id || firebase.auth().currentUser?.uid || 'temp';
                const safeCharName = characterName.replace(/[^a-zA-Z0-9]/g, '_');
                const fileName = `creation-projects/${projectId}/multitalk-audio/scene_${sceneId}_shot_${shotIndex}_${safeCharName}_${Date.now()}.${file.name.split('.').pop()}`;

                const storageRef = firebase.storage().ref(fileName);
                const uploadTask = await storageRef.put(file);
                const audioUrl = await uploadTask.ref.getDownloadURL();

                charAudio.audioUrl = audioUrl;
                charAudio.audioUploadStatus = 'ready';

                showToast(`${characterName} audio uploaded: ${audioDuration.toFixed(1)}s`, 'success');
            } catch (error) {
                console.error('Audio upload error:', error);
                charAudio.audioUploadStatus = 'error';
                showToast('Failed to upload audio: ' + error.message, 'error');
            }

            render();
            renderShotDecompositionModal();
        }

        /**
         * Handle legacy single audio file selection (backward compatible)
         */
        async function handleMultitalkAudioSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.startsWith('audio/')) {
                showToast('Please select an audio file (MP3, WAV, etc.)', 'error');
                return;
            }

            // Validate file size (max 50MB)
            if (file.size > 50 * 1024 * 1024) {
                showToast('Audio file too large. Max 50MB.', 'error');
                return;
            }

            state.storyboard.videoModelSelector.multitalk.audioFile = file;
            state.storyboard.videoModelSelector.multitalk.audioFileName = file.name;
            state.storyboard.videoModelSelector.multitalk.audioUploadStatus = 'uploading';
            render();
            renderShotDecompositionModal();

            try {
                // Get audio duration
                const audioDuration = await getAudioDuration(file);
                state.storyboard.videoModelSelector.multitalk.audioDuration = audioDuration;

                // Upload to Firebase Storage
                const { sceneId, shotIndex } = state.storyboard.videoModelSelector;
                const projectId = state.project.id || firebase.auth().currentUser?.uid || 'temp';
                const fileName = `creation-projects/${projectId}/multitalk-audio/scene_${sceneId}_shot_${shotIndex}_${Date.now()}.${file.name.split('.').pop()}`;

                const storageRef = firebase.storage().ref(fileName);
                const uploadTask = await storageRef.put(file);
                const audioUrl = await uploadTask.ref.getDownloadURL();

                state.storyboard.videoModelSelector.multitalk.audioUrl = audioUrl;
                state.storyboard.videoModelSelector.multitalk.audioUploadStatus = 'ready';

                showToast(`Audio uploaded: ${audioDuration.toFixed(1)}s`, 'success');
            } catch (error) {
                console.error('Audio upload error:', error);
                state.storyboard.videoModelSelector.multitalk.audioUploadStatus = 'error';
                showToast('Failed to upload audio: ' + error.message, 'error');
            }

            render();
            renderShotDecompositionModal();
        }

        /**
         * Get audio duration from file
         */
        function getAudioDuration(file) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.onloadedmetadata = () => {
                    resolve(audio.duration);
                };
                audio.onerror = () => {
                    reject(new Error('Failed to load audio'));
                };
                audio.src = URL.createObjectURL(file);
            });
        }

        /**
         * Generate dialogue audio using FAL ElevenLabs text-to-dialogue API
         * Creates a single audio file with all characters' dialogue
         */
        async function generateDialogueAudio() {
            const { sceneId, shotIndex, speakingCharacters } = state.storyboard.videoModelSelector;
            const multitalk = state.storyboard.videoModelSelector.multitalk;

            // Get the shot to access its dialogue
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            const shot = decomposed?.shots?.[shotIndex];

            if (!shot || !shot.dialogue || shot.dialogue.length === 0) {
                showToast('No dialogue found for this shot', 'error');
                return;
            }

            // Build dialogue lines with voice assignments
            const dialogueLines = shot.dialogue.map(d => {
                // Get the voice for this character - check multiple sources
                const charVoice = getCharacterVoice(d.character);
                const voiceProfile = charVoice?.voiceProfile || CHARACTER_VOICE_PROFILES[charVoice?.voiceProfileId];

                // ALWAYS run through toElevenLabsVoice() to ensure proper mapping
                // Even if elevenLabsVoice is set, it might contain old OpenAI names
                let elevenLabsVoice = 'Roger';

                // Priority: voiceProfile.elevenLabsVoice > d.voice > charVoice.voiceProfileId > default
                if (voiceProfile?.elevenLabsVoice) {
                    // Map it - might be an old OpenAI name like 'rachel' instead of 'Laura'
                    elevenLabsVoice = toElevenLabsVoice(voiceProfile.elevenLabsVoice);
                } else if (d.voice) {
                    // d.voice can be string or object - toElevenLabsVoice handles both
                    elevenLabsVoice = toElevenLabsVoice(d.voice);
                } else if (charVoice?.voiceProfileId) {
                    elevenLabsVoice = toElevenLabsVoice(charVoice.voiceProfileId);
                }

                console.log(`[DialogueAudio] ${d.character}: using voice ${elevenLabsVoice} (source: ${voiceProfile?.elevenLabsVoice ? 'voiceProfile' : d.voice ? 'd.voice' : charVoice?.voiceProfileId ? 'charVoice' : 'default'})`);

                return {
                    character: d.character,
                    text: d.line,
                    voice: elevenLabsVoice
                };
            });

            if (dialogueLines.length === 0) {
                showToast('No valid dialogue lines found', 'error');
                return;
            }

            // Update state to show generating status
            multitalk.dialogueAudioStatus = 'generating';
            render();
            renderShotDecompositionModal();

            showToast(`Generating dialogue audio for ${dialogueLines.length} line(s)...`, 'info');

            try {
                const generateDialogueAudioFn = functions.httpsCallable('creationWizardGenerateDialogueAudio');
                const result = await generateDialogueAudioFn({
                    projectId: state.project.id,
                    sceneId: sceneId,
                    shotId: shot.id || `scene-${sceneId}-shot-${shotIndex}`,
                    dialogueLines: dialogueLines,
                    stability: 0.5,
                    useSpeakerBoost: true
                });

                if (result.data.success) {
                    // Update multitalk state with generated audio
                    multitalk.audioUrl = result.data.audioUrl;
                    multitalk.audioDuration = result.data.audioDuration;
                    multitalk.audioFileName = `Generated (${dialogueLines.length} voices)`;
                    multitalk.audioUploadStatus = 'ready';
                    multitalk.dialogueAudioStatus = 'ready';
                    multitalk.dialogueAudioSeed = result.data.seed;

                    // Also update the shot's generated audio reference
                    shot.generatedDialogueAudio = {
                        audioUrl: result.data.audioUrl,
                        audioDuration: result.data.audioDuration,
                        voiceCount: result.data.voiceCount,
                        seed: result.data.seed,
                        generatedAt: new Date().toISOString()
                    };

                    showToast(`Dialogue audio generated: ${result.data.audioDuration}s`, 'success');
                    scheduleAutoSave();
                } else {
                    throw new Error('Failed to generate dialogue audio');
                }
            } catch (error) {
                console.error('Dialogue audio generation error:', error);
                multitalk.dialogueAudioStatus = 'error';
                showToast('Failed to generate dialogue audio: ' + (error.message || 'Unknown error'), 'error');
            }

            render();
            renderShotDecompositionModal();
        }

        /**
         * Preview dialogue audio from URL
         */
        function previewDialogueAudio(audioUrl) {
            if (!audioUrl) return;

            // Create or reuse audio element
            let audioPlayer = document.getElementById('dialogue-audio-preview');
            if (!audioPlayer) {
                audioPlayer = document.createElement('audio');
                audioPlayer.id = 'dialogue-audio-preview';
                document.body.appendChild(audioPlayer);
            }

            if (audioPlayer.src === audioUrl && !audioPlayer.paused) {
                // Already playing, pause it
                audioPlayer.pause();
            } else {
                audioPlayer.src = audioUrl;
                audioPlayer.play().catch(err => {
                    console.error('Audio playback error:', err);
                    showToast('Could not play audio', 'error');
                });
            }
        }

        /**
         * Generate video with selected model
         */
        async function generateVideoWithSelectedModel() {
            console.log('[generateVideoWithSelectedModel] Called');
            const { sceneId, shotIndex, selectedModel, selectedDuration, multitalk, speakingCharacters } = state.storyboard.videoModelSelector;

            console.log('[generateVideoWithSelectedModel] State:', {
                sceneId, shotIndex, selectedModel,
                audioUrl: multitalk?.audioUrl,
                dialogueAudioStatus: multitalk?.dialogueAudioStatus,
                audioUploadStatus: multitalk?.audioUploadStatus,
                audioDuration: multitalk?.audioDuration,
                speakingCharacters
            });

            if (selectedModel === 'minimax') {
                console.log('[generateVideoWithSelectedModel] Using Minimax');
                // Use existing Minimax generation with selected duration
                closeVideoModelSelector();
                // Convert duration string to number (5s -> 5, 10s -> 10)
                const durationNum = selectedDuration ? parseInt(selectedDuration) : null;
                generateSingleShotVideo(sceneId, shotIndex, durationNum);
            } else if (selectedModel === 'multitalk') {
                console.log('[generateVideoWithSelectedModel] Using Multitalk');
                // Check if we have generated dialogue audio (NEW: FAL ElevenLabs)
                // This is the preferred method - single audio file with all characters
                const hasAudioUrl = !!multitalk.audioUrl;
                const hasDialogueStatus = multitalk.dialogueAudioStatus === 'ready';
                const hasUploadStatus = multitalk.audioUploadStatus === 'ready';
                console.log('[generateVideoWithSelectedModel] Audio check:', { hasAudioUrl, hasDialogueStatus, hasUploadStatus });

                if (multitalk.audioUrl && (multitalk.dialogueAudioStatus === 'ready' || multitalk.audioUploadStatus === 'ready')) {
                    // Use the generated/uploaded single audio file for all characters
                    console.log('[generateVideoWithSelectedModel] Starting Multitalk with audio:', multitalk.audioUrl);
                    closeVideoModelSelector();
                    generateMultitalkVideo(sceneId, shotIndex, multitalk.audioUrl, multitalk.audioDuration, null);
                    return;
                }

                // Fallback: Check for per-character audio uploads (legacy mode)
                const characters = speakingCharacters || [];
                const characterAudios = multitalk.characterAudios || {};
                console.log('[generateVideoWithSelectedModel] Fallback check - characters:', characters.length);

                if (characters.length > 1) {
                    // Multi-character: validate all character audios are uploaded
                    const missingAudios = characters.filter(charName => {
                        const charAudio = characterAudios[charName];
                        return !charAudio || charAudio.audioUploadStatus !== 'ready' || !charAudio.audioUrl;
                    });

                    if (missingAudios.length > 0) {
                        console.log('[generateVideoWithSelectedModel] Missing audio for:', missingAudios);
                        showToast('Please generate dialogue audio or upload audio for all characters', 'error');
                        return;
                    }

                    // Build character audio data object
                    const characterAudioData = {};
                    let totalDuration = 0;
                    characters.forEach(charName => {
                        const charAudio = characterAudios[charName];
                        characterAudioData[charName] = {
                            audioUrl: charAudio.audioUrl,
                            audioDuration: charAudio.audioDuration || 5
                        };
                        totalDuration = Math.max(totalDuration, charAudio.audioDuration || 5);
                    });

                    closeVideoModelSelector();
                    generateMultitalkVideo(sceneId, shotIndex, null, totalDuration, characterAudioData);
                } else {
                    // Single character or no characters: need audio
                    console.log('[generateVideoWithSelectedModel] No audio and no multi-character setup');
                    showToast('Please generate dialogue audio or upload a voiceover file', 'error');
                    return;
                }
            }
        }

        /**
         * Save video model configuration for a shot (pre-configure before frame is ready)
         */
        function saveVideoModelConfig() {
            const { sceneId, shotIndex, selectedModel, selectedDuration, multitalk } = state.storyboard.videoModelSelector;

            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots[shotIndex]) {
                showToast('Shot not found', 'error');
                return;
            }

            const shot = decomposed.shots[shotIndex];

            // Save pre-configured model settings to the shot
            shot.preConfiguredModel = {
                model: selectedModel,
                duration: selectedDuration,
                multitalk: selectedModel === 'multitalk' ? {
                    audioUrl: multitalk.audioUrl,
                    audioFileName: multitalk.audioFileName,
                    audioDuration: multitalk.audioDuration
                } : null
            };

            closeVideoModelSelector();
            render();

            const modelLabel = selectedModel === 'minimax' ? 'Minimax' : 'Multitalk';
            showToast(`Shot ${shotIndex + 1}: ${modelLabel} configured - will apply when frame is ready`, 'success');
        }

        /**
         * Generate video with Multitalk (RunPod)
         * @param {number} sceneId - Scene ID
         * @param {number} shotIndex - Shot index
         * @param {string|null} audioUrl - Single audio URL (legacy mode)
         * @param {number} audioDuration - Audio duration in seconds
         * @param {Object|null} characterAudioData - Per-character audio data { charName: { audioUrl, audioDuration } }
         */
        async function generateMultitalkVideo(sceneId, shotIndex, audioUrl, audioDuration, characterAudioData = null) {
            console.log('[generateMultitalkVideo] Called with:', { sceneId, shotIndex, audioUrl, audioDuration, hasCharacterData: !!characterAudioData });

            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots[shotIndex]) {
                console.error('[generateMultitalkVideo] Shot not found');
                showToast('Shot not found', 'error');
                return;
            }

            const shot = decomposed.shots[shotIndex];
            console.log('[generateMultitalkVideo] Shot status:', shot.status, 'hasImage:', !!shot.imageUrl);
            if (!shot.imageUrl || shot.status !== 'ready') {
                console.error('[generateMultitalkVideo] Image not ready');
                showToast('Generate image first before creating video', 'error');
                return;
            }

            // PHASE 5: Validate TTS config before Multitalk API call
            const ttsValidation = validateTTSConfigForMultitalk(shot);
            if (ttsValidation.warnings.length > 0) {
                console.warn('[Multitalk] TTS config warnings:', ttsValidation.warnings);
            }
            if (!ttsValidation.valid) {
                console.error('[Multitalk] TTS config errors:', ttsValidation.errors);
                showToast('TTS config issue: ' + ttsValidation.errors.join(', '), 'warning');
                // Continue anyway with enhanced config - graceful degradation
            }
            const validatedTTSConfig = ttsValidation.enhanced;
            console.log('[generateMultitalkVideo] TTS validation complete, setting status...');

            shot.videoStatus = 'generating';
            shot.videoModel = 'multitalk';
            shot.videoModelReason = characterAudioData ? 'Multitalk with multi-character audio' : 'Multitalk with voiceover';
            console.log('[generateMultitalkVideo] Calling render...');
            render();
            renderShotDecompositionModal();

            const characterCount = characterAudioData ? Object.keys(characterAudioData).length : 1;
            console.log('[generateMultitalkVideo] Showing toast, preparing cloud function call...');
            showToast(` Multitalk: Starting video with ${characterCount} voice track(s)...`, 'info');

            try {
                console.log('[generateMultitalkVideo] Creating httpsCallable...');
                const generateVideoFn = functions.httpsCallable('creationWizardGenerateMultitalkVideo', { timeout: 300000 });

                // Use videoPrompt for the animation
                const videoPromptToUse = shot.videoPrompt || shot.prompt || '';

                // Build dialogue info for prompt generation
                // The backend uses this to create the positive_prompt with character dialogue
                let dialogueLines = [];
                if (validatedTTSConfig && validatedTTSConfig.lines) {
                    dialogueLines = validatedTTSConfig.lines;
                } else if (shot.dialogue && Array.isArray(shot.dialogue)) {
                    // Fallback to shot's dialogue array
                    dialogueLines = shot.dialogue.map(d => ({
                        character: d.character || 'Character',
                        text: d.line || d.text || ''
                    }));
                }

                console.log('[generateMultitalkVideo] Calling cloud function with:', {
                    projectId: state.project.id,
                    sceneId,
                    shotId: shot.id,
                    imageUrl: shot.imageUrl?.substring(0, 50) + '...',
                    audioUrl: audioUrl?.substring(0, 50) + '...',
                    audioDuration: audioDuration || 10,
                    dialogueLinesCount: dialogueLines.length
                });

                const result = await generateVideoFn({
                    projectId: state.project.id,
                    sceneId,
                    shotId: shot.id,
                    shotIndex,
                    imageUrl: shot.imageUrl,
                    audioUrl: audioUrl,  // Single audio (null if multi-character)
                    audioDuration: audioDuration || 10,
                    prompt: videoPromptToUse,
                    aspectRatio: state.platform.aspectRatio || '16:9',
                    // Pass validated TTS config or build dialogue lines for prompt
                    ttsConfig: dialogueLines.length > 0 ? { lines: dialogueLines } : validatedTTSConfig,
                    voiceRequirements: shot.voiceRequirements || null,
                    characterVoices: state.animation?.characterVoices || {},
                    // Also pass raw dialogue for fallback
                    dialogue: shot.dialogue || [],
                    // NEW: Per-character audio data for multi-voice shots
                    characterAudioData: characterAudioData
                });

                console.log('[generateMultitalkVideo] Cloud function returned:', result.data);

                if (result.data.success) {
                    shot.videoTaskId = result.data.jobId;
                    shot.videoStatus = 'processing';
                    shot.videoModelUsed = 'multitalk';
                    // Store the expected video URL (worker will upload to this location)
                    shot.pendingVideoUrl = result.data.videoUrl;

                    showToast(' Multitalk video started! Polling...', 'success');

                    // Start polling for Multitalk - pass the video file path for status check
                    startMultitalkVideoPolling(sceneId, shotIndex, result.data.jobId, result.data.fileName);
                } else {
                    throw new Error(result.data.message || 'Failed to start Multitalk video');
                }

            } catch (error) {
                console.error('Multitalk video error:', error);
                shot.videoStatus = 'error';
                shot.videoError = error.message;
                showToast('Multitalk error: ' + error.message, 'error');
            }

            render();
            renderShotDecompositionModal();
            scheduleAutoSave();
        }

        /**
         * Poll for Multitalk video completion
         */
        function startMultitalkVideoPolling(sceneId, shotIndex, jobId, videoKey) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots[shotIndex]) return;

            const shot = decomposed.shots[shotIndex];
            shot.videoPollStartTime = Date.now();
            shot.videoPollCount = 0;

            let pollCount = 0;
            const maxPolls = 300; // 10 minutes (300  2s) - Multitalk can take up to 10 minutes

            const pollInterval = setInterval(async () => {
                pollCount++;
                shot.videoPollCount = pollCount;

                if (pollCount > maxPolls) {
                    clearInterval(pollInterval);
                    shot.videoStatus = 'error';
                    shot.videoError = 'Timed out after 10 minutes';
                    showToast(' Multitalk video timed out', 'error');
                    render();
                    renderShotDecompositionModal();
                    return;
                }

                try {
                    const checkStatusFn = functions.httpsCallable('creationWizardCheckMultitalkStatus');
                    const result = await checkStatusFn({ jobId, videoKey });

                    if (result.data.status === 'COMPLETED') {
                        clearInterval(pollInterval);
                        // Use the public URL from the backend for video playback
                        shot.videoUrl = result.data.videoUrl;
                        shot.videoStatus = 'ready';
                        shot.videoError = null;
                        shot.pendingVideoUrl = null;

                        showToast(` Shot ${shotIndex + 1} Multitalk video ready!`, 'success');

                        render();
                        renderShotDecompositionModal();
                        scheduleAutoSave();

                    } else if (result.data.status === 'FAILED') {
                        clearInterval(pollInterval);
                        shot.videoStatus = 'error';
                        shot.videoError = result.data.error || 'Multitalk generation failed';
                        shot.pendingVideoUrl = null;
                        showToast(' Multitalk video failed: ' + shot.videoError, 'error');
                        render();
                        renderShotDecompositionModal();
                    }
                    // If IN_PROGRESS or IN_QUEUE, keep polling

                } catch (error) {
                    console.error('Multitalk polling error:', error);
                }

                render();
                renderShotDecompositionModal();
            }, 2000);

            // Store for cleanup
            if (!state.storyboard.activePollingIntervals) {
                state.storyboard.activePollingIntervals = [];
            }
            state.storyboard.activePollingIntervals.push(pollInterval);
        }

        /**
         * Render video model selector popup HTML
         */
        function renderVideoModelSelectorPopup() {
            const selector = state.storyboard.videoModelSelector;
            if (!selector.open) return '';

            const { sceneId, shotIndex, selectedModel, multitalk, requiresLipSync, hasNarration } = selector;
            const isMinimaxSelected = selectedModel === 'minimax';
            const isMultitalkSelected = selectedModel === 'multitalk';

            // Check if shot has an image (ready to generate) or is waiting for frame
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            const shot = decomposed?.shots?.[shotIndex];
            const hasImage = shot?.status === 'ready' && shot?.imageUrl;
            const isWaitingForFrame = !hasImage && shotIndex > 0;

            // Check if audio is ready for Multitalk
            // Priority: Generated dialogue audio > Per-character uploads > Single upload
            const speakingCharacters = selector.speakingCharacters || [];
            const characterAudios = multitalk.characterAudios || {};
            let isMultitalkAudioReady = false;

            // NEW: Check for generated dialogue audio (FAL ElevenLabs)
            if (multitalk.audioUrl && (multitalk.dialogueAudioStatus === 'ready' || multitalk.audioUploadStatus === 'ready')) {
                isMultitalkAudioReady = true;
            } else if (speakingCharacters.length > 1) {
                // Multi-character: all characters must have audio uploaded (legacy fallback)
                isMultitalkAudioReady = speakingCharacters.every(charName => {
                    const charAudio = characterAudios[charName];
                    return charAudio && charAudio.audioUploadStatus === 'ready' && charAudio.audioUrl;
                });
            } else {
                // Single character or no characters: use legacy single upload
                isMultitalkAudioReady = !!multitalk.audioUrl;
            }

            return `
                <div style="position: absolute; bottom: calc(100% + 4px); left: 50%; transform: translateX(-50%); width: 180px; background: rgba(20, 20, 35, 0.98); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.5rem; padding: 0.5rem; z-index: 100; box-shadow: 0 -4px 20px rgba(0,0,0,0.5);">
                    <!-- Header -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4rem; padding-bottom: 0.3rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.6rem; font-weight: 600; color: white;"> Video Model</div>
                        <button onclick="closeVideoModelSelector()" style="background: none; border: none; color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.85rem; line-height: 1; padding: 0;"></button>
                    </div>

                    <!-- Narrator Info Banner (when narrator voiceover, no lip-sync needed) -->
                    ${hasNarration ? `
                        <div style="background: rgba(34, 197, 94, 0.15); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 0.25rem; padding: 0.25rem; margin-bottom: 0.4rem;">
                            <div style="font-size: 0.45rem; color: #22c55e; text-align: center;">
                                 Narrator Voiceover - No lip-sync needed
                            </div>
                            <div style="font-size: 0.4rem; color: rgba(255,255,255,0.5); text-align: center; margin-top: 0.1rem;">
                                Use Minimax, add narration in post
                            </div>
                        </div>
                    ` : ''}

                    <!-- Lip-Sync Required Banner (when character dialogue) -->
                    ${requiresLipSync ? `
                        <div style="background: rgba(236, 72, 153, 0.15); border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 0.25rem; padding: 0.25rem; margin-bottom: 0.4rem;">
                            <div style="font-size: 0.45rem; color: #ec4899; text-align: center;">
                                 Character Dialogue - Lip-sync required
                            </div>
                            <div style="font-size: 0.4rem; color: rgba(255,255,255,0.5); text-align: center; margin-top: 0.1rem;">
                                Use Multitalk for lip-sync video
                            </div>
                        </div>
                    ` : ''}

                    <!-- Model Options - Horizontal layout -->
                    <div style="display: flex; gap: 0.25rem; margin-bottom: 0.4rem;">
                        <!-- Minimax Option -->
                        <div onclick="selectVideoModel('minimax')" style="flex: 1; padding: 0.3rem; border-radius: 0.3rem; background: ${isMinimaxSelected ? 'rgba(6, 182, 212, 0.2)' : 'rgba(255,255,255,0.05)'}; border: 1px solid ${isMinimaxSelected ? 'rgba(6, 182, 212, 0.5)' : 'rgba(255,255,255,0.1)'}; cursor: pointer; text-align: center;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 0.2rem; margin-bottom: 0.1rem;">
                                <div style="width: 8px; height: 8px; border-radius: 50%; border: 1.5px solid ${isMinimaxSelected ? '#06b6d4' : 'rgba(255,255,255,0.3)'}; display: flex; align-items: center; justify-content: center;">
                                    ${isMinimaxSelected ? '<div style="width: 4px; height: 4px; border-radius: 50%; background: #06b6d4;"></div>' : ''}
                                </div>
                                <span style="font-size: 0.55rem; font-weight: 600; color: white;">Minimax</span>
                            </div>
                            <div style="font-size: 0.45rem; color: rgba(255,255,255,0.5);">Standard</div>
                        </div>

                        <!-- Multitalk Option -->
                        <div onclick="selectVideoModel('multitalk')" style="flex: 1; padding: 0.3rem; border-radius: 0.3rem; background: ${isMultitalkSelected ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; border: 1px solid ${isMultitalkSelected ? 'rgba(139, 92, 246, 0.5)' : 'rgba(255,255,255,0.1)'}; cursor: pointer; text-align: center;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 0.2rem; margin-bottom: 0.1rem;">
                                <div style="width: 8px; height: 8px; border-radius: 50%; border: 1.5px solid ${isMultitalkSelected ? '#8b5cf6' : 'rgba(255,255,255,0.3)'}; display: flex; align-items: center; justify-content: center;">
                                    ${isMultitalkSelected ? '<div style="width: 4px; height: 4px; border-radius: 50%; background: #8b5cf6;"></div>' : ''}
                                </div>
                                <span style="font-size: 0.55rem; font-weight: 600; color: white;">Multitalk</span>
                            </div>
                            <div style="font-size: 0.45rem; color: rgba(255,255,255,0.5);">Voice sync</div>
                        </div>
                    </div>

                    <!-- Duration Selector (shown when Minimax selected) -->
                    ${isMinimaxSelected ? (() => {
                        const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
                        const shot = decomposed?.shots?.[shotIndex];
                        const hasDialogue = shot?.hasDialogue || false;
                        const recommendedDuration = hasDialogue ? '10s' : '5s';
                        const currentDuration = selector.selectedDuration || (shot?.duration === 5 ? '5s' : '10s');

                        return '<div style="background: rgba(6, 182, 212, 0.1); border: 1px solid rgba(6, 182, 212, 0.3); border-radius: 0.3rem; padding: 0.35rem; margin-bottom: 0.35rem;">' +
                                '<div style="font-size: 0.5rem; color: rgba(255,255,255,0.7); margin-bottom: 0.25rem;"> Duration ' + (hasDialogue ? '(has dialogue)' : '(no dialogue)') + '</div>' +
                                '<div style="display: flex; gap: 0.25rem;">' +
                                    '<button onclick="selectVideoDuration(\'5s\')" style="flex: 1; padding: 0.25rem; border-radius: 0.2rem; border: 1px solid ' + (currentDuration === '5s' ? 'rgba(6, 182, 212, 0.6)' : 'rgba(255,255,255,0.2)') + '; background: ' + (currentDuration === '5s' ? 'rgba(6, 182, 212, 0.2)' : 'transparent') + '; color: ' + (currentDuration === '5s' ? '#06b6d4' : 'rgba(255,255,255,0.7)') + '; cursor: pointer; font-size: 0.5rem; font-weight: ' + (currentDuration === '5s' ? '600' : '400') + ';">' +
                                        '5s ' + (recommendedDuration === '5s' ? '' : '') +
                                    '</button>' +
                                    '<button onclick="selectVideoDuration(\'10s\')" style="flex: 1; padding: 0.25rem; border-radius: 0.2rem; border: 1px solid ' + (currentDuration === '10s' ? 'rgba(6, 182, 212, 0.6)' : 'rgba(255,255,255,0.2)') + '; background: ' + (currentDuration === '10s' ? 'rgba(6, 182, 212, 0.2)' : 'transparent') + '; color: ' + (currentDuration === '10s' ? '#06b6d4' : 'rgba(255,255,255,0.7)') + '; cursor: pointer; font-size: 0.5rem; font-weight: ' + (currentDuration === '10s' ? '600' : '400') + ';">' +
                                        '10s ' + (recommendedDuration === '10s' ? '' : '') +
                                    '</button>' +
                                '</div>' +
                                '<div style="font-size: 0.4rem; color: rgba(255,255,255,0.4); margin-top: 0.2rem; text-align: center;"> = recommended for this shot</div>' +
                            '</div>';
                    })() : ''}

                    <!-- Multitalk Dialogue Audio (shown when Multitalk selected) -->
                    ${isMultitalkSelected ? (() => {
                        const characters = selector.speakingCharacters || [];
                        const dialogueAudioStatus = multitalk.dialogueAudioStatus || 'idle';

                        // Get shot dialogue for display
                        const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
                        const shot = decomposed?.shots?.[shotIndex];
                        const shotDialogue = shot?.dialogue || [];

                        let html = '<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.3rem; padding: 0.35rem; margin-bottom: 0.35rem;">';

                        // Show dialogue preview with voice assignments
                        if (shotDialogue.length > 0) {
                            html += '<div style="font-size: 0.4rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem;"> Dialogue:</div>';
                            shotDialogue.forEach(d => {
                                const charVoice = getCharacterVoice(d.character);
                                const voiceProfile = charVoice?.voiceProfile || CHARACTER_VOICE_PROFILES[charVoice?.voiceProfileId];
                                // ALWAYS use toElevenLabsVoice - even elevenLabsVoice might have old names
                                let voiceName = 'Roger';
                                if (voiceProfile?.elevenLabsVoice) {
                                    voiceName = toElevenLabsVoice(voiceProfile.elevenLabsVoice);
                                } else if (d.voice) {
                                    voiceName = toElevenLabsVoice(d.voice);
                                } else if (charVoice?.voiceProfileId) {
                                    voiceName = toElevenLabsVoice(charVoice.voiceProfileId);
                                }
                                const truncatedLine = d.line.length > 35 ? d.line.substring(0, 35) + '...' : d.line;
                                html += '<div style="font-size: 0.4rem; margin-bottom: 0.15rem; padding: 0.15rem; background: rgba(0,0,0,0.2); border-radius: 0.15rem;">';
                                html += '<span style="color: #c4b5fd; font-weight: 500;">' + d.character.split(' ')[0] + '</span>';
                                html += ' <span style="color: rgba(255,255,255,0.3);">(' + voiceName + ')</span>';
                                html += '<div style="color: rgba(255,255,255,0.6); font-style: italic; margin-top: 0.05rem;">"' + truncatedLine + '"</div>';
                                html += '</div>';
                            });
                        }

                        // Audio status section
                        if (dialogueAudioStatus === 'ready' || multitalk.audioUploadStatus === 'ready') {
                            // Audio is ready - show player and regenerate option
                            html += '<div style="margin-top: 0.3rem; padding: 0.2rem; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.2rem;">';
                            html += '<div style="display: flex; align-items: center; gap: 0.2rem;">';
                            html += '<span style="font-size: 0.5rem; color: #10b981;"></span>';
                            html += '<div style="flex: 1;">';
                            html += '<div style="font-size: 0.4rem; color: #10b981;">Audio Ready</div>';
                            html += '<div style="font-size: 0.35rem; color: rgba(255,255,255,0.5);">' + (multitalk.audioDuration ? multitalk.audioDuration.toFixed(1) + 's' : '') + '</div>';
                            html += '</div>';
                            html += '<button onclick="previewDialogueAudio(\'' + (multitalk.audioUrl || '').replace(/'/g, "\\'") + '\')" style="padding: 0.1rem 0.2rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.15rem; color: #10b981; cursor: pointer; font-size: 0.4rem;"></button>';
                            html += '<button onclick="generateDialogueAudio()" style="padding: 0.1rem 0.2rem; background: rgba(255,255,255,0.1); border: none; border-radius: 0.15rem; color: white; cursor: pointer; font-size: 0.4rem;"></button>';
                            html += '</div>';
                            html += '</div>';
                        } else if (dialogueAudioStatus === 'generating') {
                            // Generating audio
                            html += '<div style="margin-top: 0.3rem; text-align: center; padding: 0.3rem;">';
                            html += '<div class="animate-spin" style="display: inline-block; width: 14px; height: 14px; border: 2px solid rgba(139, 92, 246, 0.2); border-top-color: #8b5cf6; border-radius: 50%;"></div>';
                            html += '<div style="font-size: 0.4rem; color: rgba(255,255,255,0.6); margin-top: 0.15rem;">Generating dialogue audio...</div>';
                            html += '</div>';
                        } else {
                            // No audio yet - show generate button
                            html += '<button onclick="generateDialogueAudio()" style="width: 100%; margin-top: 0.3rem; padding: 0.3rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(236, 72, 153, 0.3)); border: 1px solid rgba(139, 92, 246, 0.5); border-radius: 0.2rem; color: white; cursor: pointer; font-size: 0.45rem; font-weight: 500;">';
                            html += ' Generate Dialogue Audio';
                            html += '</button>';
                            html += '<div style="font-size: 0.35rem; color: rgba(255,255,255,0.4); text-align: center; margin-top: 0.15rem;">Uses ElevenLabs AI voices</div>';

                            // Optional: Manual upload fallback
                            html += '<div style="margin-top: 0.25rem; padding-top: 0.2rem; border-top: 1px dashed rgba(255,255,255,0.1);">';
                            html += '<label style="display: flex; align-items: center; justify-content: center; gap: 0.15rem; padding: 0.15rem; cursor: pointer;">';
                            html += '<span style="font-size: 0.35rem; color: rgba(255,255,255,0.4);">or upload custom: </span>';
                            html += '<span style="font-size: 0.35rem; color: #a78bfa; text-decoration: underline;">Browse</span>';
                            html += '<input type="file" id="multitalk-audio-input" accept="audio/*" onchange="handleMultitalkAudioSelect(event)" style="display: none;">';
                            html += '</label>';
                            html += '</div>';
                        }

                        html += '</div>';
                        return html;
                    })() : ''}

                    <!-- Generate or Save Button -->
                    ${isWaitingForFrame ? `
                        <button onclick="saveVideoModelConfig()"
                                style="width: 100%; padding: 0.35rem; border-radius: 0.3rem; border: none; background: linear-gradient(135deg, #8b5cf6, #a78bfa); color: white; font-size: 0.55rem; font-weight: 600; cursor: pointer;">
                             Save Config
                        </button>
                        <div style="font-size: 0.4rem; color: rgba(255,255,255,0.4); text-align: center; margin-top: 0.25rem;">
                            Will apply when frame is ready
                        </div>
                    ` : `
                        <button onclick="generateVideoWithSelectedModel()"
                                ${isMultitalkSelected && !isMultitalkAudioReady ? 'disabled' : ''}
                                style="width: 100%; padding: 0.35rem; border-radius: 0.3rem; border: none; background: ${isMultitalkSelected && !isMultitalkAudioReady ? 'rgba(255,255,255,0.1)' : 'linear-gradient(135deg, #8b5cf6, #06b6d4)'}; color: ${isMultitalkSelected && !isMultitalkAudioReady ? 'rgba(255,255,255,0.4)' : 'white'}; font-size: 0.55rem; font-weight: 600; cursor: ${isMultitalkSelected && !isMultitalkAudioReady ? 'not-allowed' : 'pointer'};">
                            ${isMinimaxSelected ? ' Generate' : ' Generate'}
                        </button>
                    `}
                </div>
            `;
        }

        /**
         * Generate video for a single shot
         * @param {number} sceneId - Scene ID
         * @param {number} shotIndex - Shot index
         * @param {number|null} overrideDuration - Optional duration override (5 or 10 seconds)
         */
        async function generateSingleShotVideo(sceneId, shotIndex, overrideDuration = null) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots[shotIndex]) {
                showToast('Shot not found', 'error');
                return;
            }

            const shot = decomposed.shots[shotIndex];
            if (!shot.imageUrl || shot.status !== 'ready') {
                showToast('Generate image first before creating video', 'error');
                return;
            }

            // Use override duration if provided, otherwise use shot's duration
            const effectiveDuration = overrideDuration || shot.duration || 10;

            // ==========================================
            // SMART MODEL SELECTION
            // ==========================================
            const modelInfo = getVideoModelForShot(shot);
            const styleSettings = getStyleSettingsForVideo();

            console.log(`[Video Generation] Shot ${shotIndex + 1}: Model=${modelInfo.model}, Reason=${modelInfo.reason}`);

            shot.videoStatus = 'generating';
            shot.videoModel = modelInfo.model; // Store for UI display
            shot.videoModelReason = modelInfo.reason;
            render();

            const modelLabel = modelInfo.model === 'S2V-01' ? ' Character Mode' : ' Standard Mode';
            showToast(`${modelLabel}: Starting video for shot ${shotIndex + 1}...`, 'info');

            try {
                const generateVideoFn = functions.httpsCallable('creationWizardGenerateShotVideo', { timeout: 120000 });

                // Use effective duration (from selector or shot decomposition) - 5, 6, or 10 seconds
                const shotDuration = effectiveDuration === 10 ? '10s' : effectiveDuration === 5 ? '5s' : '6s';
                console.log(`[Video Generation] Duration: ${shotDuration} (effective: ${effectiveDuration}, shot.duration: ${shot.duration})`);

                // Use videoPrompt (ACTION-focused) for video generation, fallback to prompt for backward compatibility
                const videoPromptToUse = shot.videoPrompt || shot.prompt;

                console.log(`[Video Generation] Using ${shot.videoPrompt ? 'ACTION-focused videoPrompt' : 'legacy prompt'}:`, videoPromptToUse);

                const result = await generateVideoFn({
                    sceneId,
                    shotId: shot.id,
                    shotIndex,
                    imageUrl: shot.imageUrl,
                    prompt: videoPromptToUse,  // Use ACTION-focused videoPrompt
                    cameraMovement: shot.cameraMovement,
                    duration: shotDuration,
                    // NEW: Narrative beat info for context
                    narrativeBeat: shot.narrativeBeat || null,
                    // NEW: Character consistency parameters
                    hasCharacters: modelInfo.hasCharacters,
                    characterReference: modelInfo.characterUrl || null,
                    primaryCharacterName: modelInfo.characterName || null,
                    // NEW: Style enforcement
                    styleSettings: styleSettings
                });

                if (result.data.success) {
                    shot.videoTaskId = result.data.taskId;
                    shot.videoStatus = 'processing';
                    shot.videoModelUsed = result.data.modelUsed;
                    shot.usedCharacterConsistency = result.data.usedCharacterConsistency;

                    const modeLabel = result.data.usedCharacterConsistency ? '' : '';
                    showToast(`${modeLabel} Shot ${shotIndex + 1} video started! Polling...`, 'success');

                    // Start polling for this shot - pass effective duration for timeout calculation
                    startSingleShotVideoPolling(sceneId, shotIndex, result.data.taskId, effectiveDuration);
                } else {
                    throw new Error('Failed to start video generation');
                }

            } catch (error) {
                console.error('Shot video error:', error);
                shot.videoStatus = 'error';
                shot.videoError = error.message;
                const friendlyError = formatVideoGenerationError(error);
                showToast(friendlyError, 'error');
            }

            render();
            renderShotDecompositionModal(); // Refresh modal if open
            scheduleAutoSave();
        }

        /**
         * Poll for shot video completion (all shots in a scene)
         */
        function startShotVideoPolling(sceneId) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed) return;

            const processingShots = decomposed.shots.filter(s => s.videoStatus === 'processing' && s.videoTaskId);
            if (processingShots.length === 0) return;

            // Determine if we're generating 10s videos (check from video model or first shot's duration)
            const clipDuration = state.content.videoModel?.duration || '10s';
            const firstShotDuration = processingShots[0]?.duration;
            const is10sVideo = clipDuration === '10s' || firstShotDuration === 10;

            let pollCount = 0;
            let consecutiveErrors = 0;
            // Dynamic timeout: 10s videos need 10 minutes, 6s videos need 6 minutes
            const maxPolls = is10sVideo ? 300 : 180; // 10 min (3002s) or 6 min (1802s)
            const timeoutMinutes = is10sVideo ? 10 : 6;
            const maxConsecutiveErrors = 10; // Stop after 10 consecutive errors

            console.log(`[Video Poll Batch] Starting batch polling - ${is10sVideo ? '10s' : '6s'} videos, timeout: ${timeoutMinutes} minutes`);

            const pollInterval = setInterval(async () => {
                pollCount++;

                if (pollCount > maxPolls) {
                    clearInterval(pollInterval);
                    removePollingInterval(pollInterval);
                    processingShots.forEach(shot => {
                        if (shot.videoStatus === 'processing') {
                            shot.videoStatus = 'error';
                            shot.videoError = `Timed out after ${timeoutMinutes} minutes`;
                        }
                    });
                    showToast(` Video generation timed out after ${timeoutMinutes} minutes`, 'error');
                    render();
                    return;
                }

                // Check if too many consecutive errors
                if (consecutiveErrors >= maxConsecutiveErrors) {
                    clearInterval(pollInterval);
                    removePollingInterval(pollInterval);
                    processingShots.forEach(shot => {
                        if (shot.videoStatus === 'processing') {
                            shot.videoStatus = 'error';
                            shot.videoError = 'Too many errors checking status. Please retry.';
                        }
                    });
                    showToast(' Video status check failed repeatedly. Please retry.', 'error');
                    render();
                    return;
                }

                const checkStatusFn = functions.httpsCallable('creationWizardCheckShotVideoStatus');
                let hasSuccess = false;

                for (const shot of processingShots) {
                    if (shot.videoStatus !== 'processing') continue;

                    try {
                        const result = await checkStatusFn({
                            taskId: shot.videoTaskId,
                            shotId: shot.id
                        });

                        hasSuccess = true; // At least one call succeeded

                        if (result.data.status === 'ready' && result.data.videoUrl) {
                            shot.videoUrl = result.data.videoUrl;
                            shot.videoStatus = 'ready';
                            showToast(` Shot ${shot.shotIndex + 1} video ready!`, 'success');
                        } else if (result.data.status === 'error') {
                            shot.videoStatus = 'error';
                            shot.videoError = result.data.error || 'Generation failed';
                        }

                    } catch (error) {
                        console.error('Poll error:', error);
                    }
                }

                // Reset or increment consecutive error count
                if (hasSuccess) {
                    consecutiveErrors = 0;
                } else {
                    consecutiveErrors++;
                }

                render();

                // Check if all done
                const stillProcessing = decomposed.shots.filter(s => s.videoStatus === 'processing');
                if (stillProcessing.length === 0) {
                    clearInterval(pollInterval);
                    removePollingInterval(pollInterval);

                    const readyCount = decomposed.shots.filter(s => s.videoStatus === 'ready').length;
                    if (readyCount === decomposed.shots.length) {
                        showToast(` All ${readyCount} shot videos ready!`, 'success');
                    }
                    scheduleAutoSave();
                }

            }, 2000);

            // Track this polling interval for cleanup (ensure array exists)
            if (!state.storyboard.multiShotMode.activePollingIntervals) {
                state.storyboard.multiShotMode.activePollingIntervals = [];
            }
            state.storyboard.multiShotMode.activePollingIntervals.push(pollInterval);
        }

        /**
         * Remove a polling interval from tracking
         */
        function removePollingInterval(interval) {
            const intervals = state.storyboard.multiShotMode?.activePollingIntervals;
            if (!intervals || !Array.isArray(intervals)) return;
            const idx = intervals.indexOf(interval);
            if (idx > -1) {
                intervals.splice(idx, 1);
            }
        }

        /**
         * Clean up all active polling intervals
         */
        function cleanupAllPollingIntervals() {
            const intervals = state.storyboard.multiShotMode?.activePollingIntervals;
            if (intervals && Array.isArray(intervals)) {
                intervals.forEach(interval => {
                    clearInterval(interval);
                });
                state.storyboard.multiShotMode.activePollingIntervals = [];
                console.log('[Polling] Cleaned up all polling intervals');
            }
        }

        /**
         * Poll for single shot video completion
         * @param {string} sceneId - Scene identifier
         * @param {number} shotIndex - Shot index
         * @param {string} taskId - Minimax task ID
         * @param {number} shotDuration - Shot duration in seconds (6 or 10)
         */
        function startSingleShotVideoPolling(sceneId, shotIndex, taskId, shotDuration = 10) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots[shotIndex]) return;

            const shot = decomposed.shots[shotIndex];
            shot.videoPollCount = 0;
            shot.videoPollStartTime = Date.now();
            shot.videoConsecutiveErrors = 0;

            // Dynamic timeout based on video duration:
            // - 5s videos: 4 minutes (120 polls  2s) - quickest generation
            // - 6s videos: 5 minutes (150 polls  2s) - typically complete in 3-4 minutes
            // - 10s videos: 10 minutes (300 polls  2s) - can take 6-8 minutes on Minimax
            const is10sVideo = shotDuration === 10 || shotDuration === '10s' || shotDuration === '10';
            const is5sVideo = shotDuration === 5 || shotDuration === '5s' || shotDuration === '5';
            const maxPolls = is10sVideo ? 300 : is5sVideo ? 120 : 150;
            const timeoutMinutes = is10sVideo ? 10 : is5sVideo ? 4 : 5;
            const maxConsecutiveErrors = 10; // Stop after 10 consecutive errors

            console.log(`[Video Poll] Starting polling for ${shotDuration}s video - timeout: ${timeoutMinutes} minutes (${maxPolls} polls)`);

            const pollInterval = setInterval(async () => {
                shot.videoPollCount = (shot.videoPollCount || 0) + 1;

                // Update UI every poll to show progress
                renderShotDecompositionModal();

                if (shot.videoPollCount > maxPolls || shot.videoStatus !== 'processing') {
                    clearInterval(pollInterval);
                    removePollingInterval(pollInterval);
                    if (shot.videoStatus === 'processing') {
                        shot.videoStatus = 'error';
                        shot.videoError = `Video generation timed out after ${timeoutMinutes} minutes`;
                        showToast(` Shot ${shotIndex + 1} video timed out after ${timeoutMinutes} min. Try again.`, 'error');
                        render();
                        renderShotDecompositionModal();
                    }
                    delete shot.videoPollCount;
                    delete shot.videoPollStartTime;
                    delete shot.videoConsecutiveErrors;
                    return;
                }

                // Check for too many consecutive errors
                if ((shot.videoConsecutiveErrors || 0) >= maxConsecutiveErrors) {
                    clearInterval(pollInterval);
                    removePollingInterval(pollInterval);
                    shot.videoStatus = 'error';
                    shot.videoError = 'Too many errors checking status. Please retry.';
                    delete shot.videoPollCount;
                    delete shot.videoPollStartTime;
                    delete shot.videoConsecutiveErrors;
                    showToast(` Shot ${shotIndex + 1} status check failed repeatedly. Please retry.`, 'error');
                    render();
                    renderShotDecompositionModal();
                    return;
                }

                try {
                    const checkStatusFn = functions.httpsCallable('creationWizardCheckShotVideoStatus');
                    const result = await checkStatusFn({ taskId, shotId: shot.id });

                    // Reset consecutive errors on success
                    shot.videoConsecutiveErrors = 0;

                    console.log(`[Video Poll] Shot ${shotIndex + 1}, Poll #${shot.videoPollCount}: ${result.data.status}`);

                    if (result.data.status === 'ready' && result.data.videoUrl) {
                        clearInterval(pollInterval);
                        removePollingInterval(pollInterval);
                        shot.videoUrl = result.data.videoUrl;
                        shot.videoStatus = 'ready';
                        delete shot.videoPollCount;
                        delete shot.videoPollStartTime;
                        delete shot.videoConsecutiveErrors;
                        showToast(` Shot ${shotIndex + 1} video ready!`, 'success');
                        render();
                        renderShotDecompositionModal();
                        scheduleAutoSave();
                    } else if (result.data.status === 'error') {
                        clearInterval(pollInterval);
                        removePollingInterval(pollInterval);
                        shot.videoStatus = 'error';
                        shot.videoError = result.data.error || 'Video generation failed';
                        delete shot.videoPollCount;
                        delete shot.videoPollStartTime;
                        delete shot.videoConsecutiveErrors;
                        showToast(` Shot ${shotIndex + 1} video failed`, 'error');
                        render();
                        renderShotDecompositionModal();
                    }

                } catch (error) {
                    console.error('Poll error:', error);
                    shot.videoConsecutiveErrors = (shot.videoConsecutiveErrors || 0) + 1;

                    // Stop immediately on balance/quota errors
                    if (error.message?.includes('insufficient') || error.message?.includes('quota')) {
                        clearInterval(pollInterval);
                        removePollingInterval(pollInterval);
                        shot.videoStatus = 'error';
                        shot.videoError = formatVideoGenerationError(error);
                        delete shot.videoPollCount;
                        delete shot.videoPollStartTime;
                        delete shot.videoConsecutiveErrors;
                        render();
                        renderShotDecompositionModal();
                    }
                }

            }, 2000);

            // Track this polling interval for cleanup (ensure array exists)
            if (!state.storyboard.multiShotMode.activePollingIntervals) {
                state.storyboard.multiShotMode.activePollingIntervals = [];
            }
            state.storyboard.multiShotMode.activePollingIntervals.push(pollInterval);
        }

        /**
         * Preview the assembled scene video sequence
         */
        async function previewSceneVideoSequence(sceneId) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed) {
                showToast('No shot data found', 'error');
                return;
            }

            const shotsWithVideos = decomposed.shots.filter(s => s.videoUrl && s.videoStatus === 'ready');
            if (shotsWithVideos.length === 0) {
                showToast('No shot videos ready. Generate videos first.', 'error');
                return;
            }

            // Create video preview modal
            const modal = document.createElement('div');
            modal.id = 'shot-video-preview-modal';
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10000; padding: 1rem;';

            const playlist = shotsWithVideos.map(s => s.videoUrl);
            let currentIndex = 0;

            modal.innerHTML = `
                <div style="max-width: 900px; width: 100%; background: #1a1a2e; border-radius: 1rem; overflow: hidden;">
                    <div style="padding: 1rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: white;"> Scene ${sceneId} - Shot Sequence</div>
                            <div style="font-size: 0.8rem; color: rgba(255,255,255,0.5);">${shotsWithVideos.length} shots ready</div>
                        </div>
                        <button onclick="document.getElementById('shot-video-preview-modal').remove()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer;"></button>
                    </div>
                    <div style="position: relative; background: black;">
                        <video id="shot-sequence-video" style="width: 100%; max-height: 500px;" controls>
                            <source src="${playlist[0]}" type="video/mp4">
                        </video>
                    </div>
                    <div style="padding: 1rem;">
                        <div style="display: flex; gap: 0.5rem; overflow-x: auto; padding-bottom: 0.5rem;">
                            ${shotsWithVideos.map((shot, idx) => `
                                <div onclick="playShot(${idx})" style="flex-shrink: 0; cursor: pointer; border: 2px solid ${idx === 0 ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; border-radius: 0.4rem; overflow: hidden; width: 80px;" data-shot-idx="${idx}">
                                    ${shot.imageUrl ? `<img src="${shot.imageUrl}" style="width: 100%; height: 50px; object-fit: cover;">` : '<div style="width: 100%; height: 50px; background: rgba(255,255,255,0.1);"></div>'}
                                    <div style="padding: 0.2rem; text-align: center;">
                                        <div style="font-size: 0.6rem; color: rgba(255,255,255,0.6);">${shot.shotType?.replace('_', ' ') || 'Shot ' + (idx + 1)}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="margin-top: 0.75rem; display: flex; gap: 0.5rem;">
                            <button onclick="playAllSequentially()" style="flex: 1; padding: 0.6rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border: none; border-radius: 0.5rem; color: white; cursor: pointer; font-weight: 600;">
                                 Play All Sequentially
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Add playShot function to window
            window.playShot = function(idx) {
                const video = document.getElementById('shot-sequence-video');
                if (video && playlist[idx]) {
                    video.src = playlist[idx];
                    video.play();

                    // Update selected thumbnail
                    document.querySelectorAll('#shot-video-preview-modal [data-shot-idx]').forEach((el, i) => {
                        el.style.borderColor = i === idx ? '#8b5cf6' : 'rgba(255,255,255,0.2)';
                    });
                }
            };

            // Add playAllSequentially function
            window.playAllSequentially = function() {
                const video = document.getElementById('shot-sequence-video');
                let idx = 0;

                function playNext() {
                    if (idx < playlist.length) {
                        video.src = playlist[idx];
                        video.play();

                        document.querySelectorAll('#shot-video-preview-modal [data-shot-idx]').forEach((el, i) => {
                            el.style.borderColor = i === idx ? '#8b5cf6' : 'rgba(255,255,255,0.2)';
                        });

                        idx++;
                    }
                }

                video.onended = playNext;
                playNext();
            };
        }

        // ==========================================
        // FRAME CHAIN PIPELINE - Capture & Transfer
        // ==========================================

        /**
         * Open frame capture modal for a shot's video
         */
        function openFrameCaptureModal(sceneId, shotIndex) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots[shotIndex]) {
                showToast('Shot not found', 'error');
                return;
            }

            const shot = decomposed.shots[shotIndex];
            if (!shot.videoUrl) {
                showToast('Generate video first to capture frames', 'error');
                return;
            }

            // Store capture context
            state.frameCaptureContext = {
                sceneId,
                shotIndex,
                videoUrl: shot.videoUrl,
                capturedFrame: null
            };

            const modal = document.createElement('div');
            modal.id = 'frame-capture-modal';
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex; align-items: center; justify-content: center; z-index: 10001; padding: 1rem;';

            const nextShotIndex = shotIndex + 1;
            const hasNextShot = decomposed.shots[nextShotIndex] !== undefined;

            modal.innerHTML = `
                <div style="max-width: 800px; width: 100%; background: linear-gradient(135deg, #1a1a2e, #0f172a); border-radius: 1rem; border: 1px solid rgba(139, 92, 246, 0.3); overflow: hidden;">
                    <!-- Header -->
                    <div style="padding: 1rem 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 1.1rem; font-weight: 700; color: white; display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 1.3rem;"></span> Frame Capture - Shot ${shotIndex + 1}
                            </div>
                            <div style="font-size: 0.8rem; color: rgba(255,255,255,0.5);">Scrub video to select frame for next shot</div>
                        </div>
                        <button onclick="closeFrameCaptureModal()" style="background: none; border: none; color: rgba(255,255,255,0.5); font-size: 1.5rem; cursor: pointer; padding: 0.5rem;">&times;</button>
                    </div>

                    <!-- Video Player -->
                    <div style="padding: 1rem; background: rgba(0,0,0,0.3);">
                        <video id="frame-capture-video" crossorigin="anonymous" style="width: 100%; border-radius: 0.5rem; max-height: 400px;" controls></video>

                        <!-- Frame Preview -->
                        <div style="margin-top: 1rem; display: flex; gap: 1rem; align-items: flex-start;">
                            <div style="flex: 1;">
                                <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); margin-bottom: 0.5rem;">CAPTURED FRAME</div>
                                <div id="captured-frame-preview" style="background: rgba(0,0,0,0.5); border: 2px dashed rgba(255,255,255,0.2); border-radius: 0.5rem; height: 150px; display: flex; align-items: center; justify-content: center;">
                                    <span style="color: rgba(255,255,255,0.3); font-size: 0.85rem;">Click "Capture Current Frame"</span>
                                </div>
                            </div>
                            ${hasNextShot ? `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0 1rem;">
                                <div style="font-size: 2rem; color: rgba(139, 92, 246, 0.5);"></div>
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">TRANSFER</div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); margin-bottom: 0.5rem;">SHOT ${nextShotIndex + 1} START FRAME</div>
                                <div id="next-shot-preview" style="background: rgba(0,0,0,0.5); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 0.5rem; height: 150px; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                                    ${decomposed.shots[nextShotIndex].imageUrl
                                        ? `<img src="${decomposed.shots[nextShotIndex].imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">`
                                        : `<span style="color: rgba(255,255,255,0.3); font-size: 0.85rem;">No image yet</span>`
                                    }
                                </div>
                            </div>
                            ` : `
                            <div style="flex: 1; text-align: center; padding: 2rem;">
                                <div style="color: rgba(255,255,255,0.4); font-size: 0.85rem;">This is the last shot</div>
                            </div>
                            `}
                        </div>
                    </div>

                    <!-- Actions -->
                    <div style="padding: 1rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 0.75rem; flex-wrap: wrap;">
                        <button onclick="captureCurrentFrame()" style="flex: 1; min-width: 150px; padding: 0.75rem; background: linear-gradient(135deg, #8b5cf6, #7c3aed); border: none; border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                             Capture Current Frame
                        </button>
                        <button onclick="captureLastFrame()" style="flex: 1; min-width: 150px; padding: 0.75rem; background: rgba(6, 182, 212, 0.2); border: 1px solid rgba(6, 182, 212, 0.5); border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                             Capture Last Frame
                        </button>
                        <!-- Fix Character Faces button (hidden until frame is captured) -->
                        <button id="fix-faces-btn" onclick="showFaceCorrectionPanel()" style="display: none; flex: 1; min-width: 180px; padding: 0.75rem; background: rgba(249, 115, 22, 0.2); border: 1px solid rgba(249, 115, 22, 0.5); border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer; align-items: center; justify-content: center; gap: 0.5rem;">
                             Fix Character Faces
                        </button>
                        ${hasNextShot ? `
                        <button id="transfer-frame-btn" onclick="transferFrameToNextShot()" disabled style="flex: 1; min-width: 200px; padding: 0.75rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.5rem; color: rgba(255,255,255,0.5); font-weight: 600; cursor: not-allowed; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                             Send to Shot ${nextShotIndex + 1}
                        </button>
                        ` : ''}
                    </div>

                    <!-- Face Correction Panel (hidden by default, shown when Fix Character Faces is clicked) -->
                    <div id="face-correction-panel" style="display: none; padding: 0 1.25rem 1.25rem 1.25rem;"></div>
                </div>
            `;

            document.body.appendChild(modal);

            // Load video with crossOrigin set (important: set src AFTER crossOrigin is set)
            const video = document.getElementById('frame-capture-video');
            video.addEventListener('loadedmetadata', () => {
                // Ready to capture
            });

            // Handle CORS errors by falling back to proxy approach
            video.addEventListener('error', (e) => {
                console.error('Video load error:', e);
                showToast('Video loading failed - trying alternative method...', 'info');
            });

            // Set src after crossOrigin attribute is already in place
            video.src = shot.videoUrl;
        }

        /**
         * Close frame capture modal
         */
        function closeFrameCaptureModal() {
            const modal = document.getElementById('frame-capture-modal');
            if (modal) modal.remove();
            state.frameCaptureContext = null;
        }

        /**
         * Capture the current frame from the video
         */
        async function captureCurrentFrame() {
            const video = document.getElementById('frame-capture-video');
            if (!video) return;

            const currentTime = video.currentTime;

            try {
                // Try client-side canvas capture first
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth || 1280;
                canvas.height = video.videoHeight || 720;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                // This will throw SecurityError if canvas is tainted
                const frameDataUrl = canvas.toDataURL('image/png');
                state.frameCaptureContext.capturedFrame = frameDataUrl;

                // Update preview
                updateFrameCapturePreview(frameDataUrl);
                showToast('Frame captured! You can now transfer it to the next shot.', 'success');

            } catch (error) {
                console.error('Canvas capture failed (CORS):', error);

                // Fallback: Get a signed URL and retry with that
                showToast('Getting secure video URL...', 'info');

                try {
                    const extractFrameFn = functions.httpsCallable('extractVideoFrame', { timeout: 60000 });
                    const result = await extractFrameFn({
                        videoUrl: state.frameCaptureContext.videoUrl,
                        timestamp: currentTime
                    });

                    if (result.data.success && result.data.signedVideoUrl) {
                        // Reload video with signed URL and retry capture
                        const video = document.getElementById('frame-capture-video');
                        video.src = result.data.signedVideoUrl;

                        // Wait for video to load, then seek and capture
                        video.onloadedmetadata = () => {
                            video.currentTime = currentTime;
                            video.onseeked = () => {
                                try {
                                    const canvas = document.createElement('canvas');
                                    canvas.width = video.videoWidth || 1280;
                                    canvas.height = video.videoHeight || 720;
                                    const ctx = canvas.getContext('2d');
                                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                                    const frameDataUrl = canvas.toDataURL('image/png');
                                    state.frameCaptureContext.capturedFrame = frameDataUrl;
                                    updateFrameCapturePreview(frameDataUrl);
                                    showToast('Frame captured! You can now transfer it.', 'success');
                                } catch (retryError) {
                                    console.error('Retry capture also failed:', retryError);
                                    showToast('Frame capture failed. CORS may not be configured on storage.', 'error');
                                }
                                video.onseeked = null;
                            };
                        };
                    } else {
                        throw new Error(result.data.error || 'Failed to get signed URL');
                    }
                } catch (serverError) {
                    console.error('Server-side capture also failed:', serverError);
                    showToast('Frame capture failed. Please check Firebase Storage CORS settings.', 'error');
                }
            }
        }

        /**
         * Update the frame capture preview UI
         */
        function updateFrameCapturePreview(frameUrl) {
            const preview = document.getElementById('captured-frame-preview');
            if (preview) {
                preview.innerHTML = `<img src="${frameUrl}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 0.375rem;">`;
            }

            // Enable transfer button
            const transferBtn = document.getElementById('transfer-frame-btn');
            if (transferBtn) {
                transferBtn.disabled = false;
                transferBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                transferBtn.style.border = 'none';
                transferBtn.style.color = 'white';
                transferBtn.style.cursor = 'pointer';
            }

            // Show Fix Character Faces button if Character Bible is enabled
            const fixFacesBtn = document.getElementById('fix-faces-btn');
            if (fixFacesBtn && state.storyboard.characterBible?.enabled) {
                fixFacesBtn.style.display = 'flex';
            }
        }

        // ==========================================
        // FIX CHARACTER FACES - Face Correction Feature
        // Uses NanoBananaPro with Character Bible references to fix AI-generated faces
        // ==========================================

        /**
         * Show the face correction panel
         */
        function showFaceCorrectionPanel() {
            if (!state.frameCaptureContext?.capturedFrame) {
                showToast('Capture a frame first', 'error');
                return;
            }

            if (!state.storyboard.characterBible?.enabled) {
                showToast('Character Bible is required for face correction', 'error');
                return;
            }

            const characters = state.storyboard.characterBible.characters || [];
            const charsWithPortraits = characters.filter(c => c.referenceImageUrl && c.referenceImageStatus === 'ready');

            if (charsWithPortraits.length === 0) {
                showToast('No character portraits available. Generate portraits in Character Bible first.', 'error');
                return;
            }

            // Store face correction context
            state.faceCorrectionContext = {
                originalFrame: state.frameCaptureContext.capturedFrame,
                correctedFrame: null,
                selectedCharacters: charsWithPortraits.map(c => c.id), // Select all by default
                status: 'idle' // idle, processing, done, error
            };

            // Build the face correction panel
            const panel = document.getElementById('face-correction-panel');
            if (panel) {
                panel.innerHTML = buildFaceCorrectionPanelHTML(charsWithPortraits);
                panel.style.display = 'block';
            }
        }

        /**
         * Build the HTML for the face correction panel
         */
        function buildFaceCorrectionPanelHTML(characters) {
            return `
                <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 1rem; margin-top: 1rem;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
                        <div style="font-size: 0.9rem; font-weight: 600; color: white; display: flex; align-items: center; gap: 0.5rem;">
                            <span style="font-size: 1.2rem;"></span> Fix Character Faces
                        </div>
                        <button onclick="closeFaceCorrectionPanel()" style="background: none; border: none; color: rgba(255,255,255,0.5); cursor: pointer; font-size: 1rem;"></button>
                    </div>

                    <div style="color: rgba(255,255,255,0.6); font-size: 0.75rem; margin-bottom: 1rem;">
                        Select characters whose faces need correction. Their Character Bible portraits will be used as reference.
                    </div>

                    <!-- Character Selection -->
                    <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; margin-bottom: 1rem;">
                        ${characters.map(char => `
                            <div onclick="toggleFaceCorrectionCharacter('${char.id}')"
                                 id="face-char-${char.id}"
                                 style="cursor: pointer; padding: 0.5rem; background: rgba(139, 92, 246, 0.2); border: 2px solid rgba(139, 92, 246, 0.5); border-radius: 0.5rem; display: flex; align-items: center; gap: 0.5rem; transition: all 0.2s;">
                                <img src="${char.referenceImageUrl}" style="width: 40px; height: 40px; object-fit: cover; border-radius: 0.25rem;">
                                <div>
                                    <div style="font-size: 0.75rem; font-weight: 600; color: white;">${char.name}</div>
                                    <div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);"> Selected</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <!-- Before/After Preview -->
                    <div id="face-correction-preview" style="display: none; margin-bottom: 1rem;">
                        <div style="display: flex; gap: 1rem;">
                            <div style="flex: 1;">
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.25rem;">BEFORE</div>
                                <div style="border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; overflow: hidden; aspect-ratio: 16/9;">
                                    <img id="face-before-img" src="${state.frameCaptureContext?.capturedFrame || ''}" style="width: 100%; height: 100%; object-fit: cover;">
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.25rem;">AFTER</div>
                                <div id="face-after-container" style="border: 1px solid rgba(16, 185, 129, 0.5); border-radius: 0.5rem; overflow: hidden; aspect-ratio: 16/9; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3);">
                                    <span style="color: rgba(255,255,255,0.3); font-size: 0.75rem;">Click "Apply Correction"</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Progress indicator -->
                    <div id="face-correction-progress" style="display: none; margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem; border: 1px solid rgba(139, 92, 246, 0.3);">
                            <div class="spinner" style="width: 20px; height: 20px; border: 2px solid rgba(139, 92, 246, 0.3); border-top-color: #8b5cf6; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                            <div style="color: white; font-size: 0.85rem;">Correcting faces with AI...</div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 0.75rem;">
                        <button id="apply-face-correction-btn" onclick="applyFaceCorrection()" style="flex: 1; padding: 0.75rem; background: linear-gradient(135deg, #8b5cf6, #7c3aed); border: none; border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                             Apply Correction
                        </button>
                        <button id="save-corrected-frame-btn" onclick="saveCorrectedFrame()" disabled style="flex: 1; padding: 0.75rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.5rem; color: rgba(255,255,255,0.5); font-weight: 600; cursor: not-allowed; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                             Save Corrected Frame
                        </button>
                    </div>
                </div>
            `;
        }

        /**
         * Toggle character selection for face correction
         */
        function toggleFaceCorrectionCharacter(charId) {
            if (!state.faceCorrectionContext) return;

            const idx = state.faceCorrectionContext.selectedCharacters.indexOf(charId);
            const charEl = document.getElementById(`face-char-${charId}`);

            if (idx >= 0) {
                // Deselect
                state.faceCorrectionContext.selectedCharacters.splice(idx, 1);
                if (charEl) {
                    charEl.style.background = 'rgba(255,255,255,0.05)';
                    charEl.style.borderColor = 'rgba(255,255,255,0.2)';
                    charEl.querySelector('div > div:last-child').textContent = 'Click to select';
                    charEl.querySelector('div > div:last-child').style.color = 'rgba(255,255,255,0.3)';
                }
            } else {
                // Select
                state.faceCorrectionContext.selectedCharacters.push(charId);
                if (charEl) {
                    charEl.style.background = 'rgba(139, 92, 246, 0.2)';
                    charEl.style.borderColor = 'rgba(139, 92, 246, 0.5)';
                    charEl.querySelector('div > div:last-child').textContent = ' Selected';
                    charEl.querySelector('div > div:last-child').style.color = 'rgba(255,255,255,0.5)';
                }
            }
        }

        /**
         * Close the face correction panel
         */
        function closeFaceCorrectionPanel() {
            const panel = document.getElementById('face-correction-panel');
            if (panel) {
                panel.style.display = 'none';
                panel.innerHTML = '';
            }
            state.faceCorrectionContext = null;
        }

        /**
         * Apply face correction using NanoBananaPro with character references
         */
        async function applyFaceCorrection() {
            if (!state.faceCorrectionContext?.originalFrame) {
                showToast('No frame captured', 'error');
                return;
            }

            const selectedIds = state.faceCorrectionContext.selectedCharacters;
            if (selectedIds.length === 0) {
                showToast('Select at least one character', 'error');
                return;
            }

            // Get selected character portraits
            const characters = state.storyboard.characterBible.characters || [];
            const selectedChars = characters.filter(c => selectedIds.includes(c.id));

            // Ensure all selected characters have base64
            for (const char of selectedChars) {
                if (!char.referenceImageBase64 && char.referenceImageUrl) {
                    try {
                        char.referenceImageBase64 = await fetchImageAsBase64(char.referenceImageUrl);
                    } catch (err) {
                        console.warn(`Failed to fetch base64 for ${char.name}:`, err);
                    }
                }
            }

            const charsWithBase64 = selectedChars.filter(c => c.referenceImageBase64);
            if (charsWithBase64.length === 0) {
                showToast('Could not load character portraits', 'error');
                return;
            }

            // Show progress
            state.faceCorrectionContext.status = 'processing';
            document.getElementById('face-correction-progress').style.display = 'block';
            document.getElementById('face-correction-preview').style.display = 'flex';
            document.getElementById('apply-face-correction-btn').disabled = true;
            document.getElementById('apply-face-correction-btn').style.opacity = '0.5';

            try {
                // Extract base64 from data URL
                const frameBase64 = state.faceCorrectionContext.originalFrame.split(',')[1];

                // Build character references for the API
                const characterReferences = charsWithBase64.map(c => ({
                    name: c.name,
                    description: c.description,
                    base64: c.referenceImageBase64,
                    mimeType: c.referenceImageMimeType || 'image/png'
                }));

                console.log(`[Face Correction] Sending ${characterReferences.length} character reference(s) for correction`);

                // Call the backend function
                const fixFacesFn = functions.httpsCallable('creationWizardFixCharacterFaces', { timeout: 120000 });
                const result = await fixFacesFn({
                    frameBase64: frameBase64,
                    frameMimeType: 'image/png',
                    characterReferences: characterReferences,
                    aspectRatio: state.platform.aspectRatio || '16:9'
                });

                if (result.data.success && result.data.correctedImageUrl) {
                    // Show the corrected frame
                    state.faceCorrectionContext.correctedFrame = result.data.correctedImageUrl;
                    state.faceCorrectionContext.status = 'done';

                    const afterContainer = document.getElementById('face-after-container');
                    if (afterContainer) {
                        afterContainer.innerHTML = `<img src="${result.data.correctedImageUrl}" style="width: 100%; height: 100%; object-fit: cover;">`;
                    }

                    // Enable save button
                    const saveBtn = document.getElementById('save-corrected-frame-btn');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                        saveBtn.style.border = 'none';
                        saveBtn.style.color = 'white';
                        saveBtn.style.cursor = 'pointer';
                    }

                    showToast('Face correction complete! Review and save.', 'success');
                } else {
                    throw new Error(result.data.error || 'Face correction failed');
                }

            } catch (error) {
                console.error('Face correction error:', error);
                state.faceCorrectionContext.status = 'error';
                showToast(`Face correction failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('face-correction-progress').style.display = 'none';
                document.getElementById('apply-face-correction-btn').disabled = false;
                document.getElementById('apply-face-correction-btn').style.opacity = '1';
            }
        }

        /**
         * Save the corrected frame - updates the captured frame and can be used for transfer
         */
        function saveCorrectedFrame() {
            if (!state.faceCorrectionContext?.correctedFrame) {
                showToast('No corrected frame available', 'error');
                return;
            }

            // Update the captured frame with the corrected version
            state.frameCaptureContext.capturedFrame = state.faceCorrectionContext.correctedFrame;

            // Update the preview
            updateFrameCapturePreview(state.faceCorrectionContext.correctedFrame);

            // Close the face correction panel
            closeFaceCorrectionPanel();

            showToast('Corrected frame saved! You can now transfer it to the next shot.', 'success');
        }

        /**
         * Capture the last frame of the video
         */
        function captureLastFrame() {
            const video = document.getElementById('frame-capture-video');
            if (!video) return;

            // Seek to just before the end
            video.currentTime = Math.max(0, video.duration - 0.1);

            // Wait for seek to complete
            video.onseeked = () => {
                captureCurrentFrame();
                video.onseeked = null;
            };
        }

        /**
         * Transfer captured frame to the next shot as its starting image
         * Handles both data URLs (from canvas capture) and regular URLs (from face correction)
         */
        async function transferFrameToNextShot() {
            const ctx = state.frameCaptureContext;
            if (!ctx || !ctx.capturedFrame) {
                showToast('Capture a frame first', 'error');
                return;
            }

            const decomposed = state.storyboard.multiShotMode.decomposedScenes[ctx.sceneId];
            if (!decomposed) return;

            const nextShotIndex = ctx.shotIndex + 1;
            const nextShot = decomposed.shots[nextShotIndex];
            if (!nextShot) {
                showToast('No next shot to transfer to', 'error');
                return;
            }

            showToast('Transferring frame to next shot...', 'info');

            try {
                let finalImageUrl;

                // Check if capturedFrame is a data URL or a regular URL
                if (ctx.capturedFrame.startsWith('data:')) {
                    // It's a data URL from canvas capture - upload it
                    const uploadFn = functions.httpsCallable('uploadBase64Image', { timeout: 60000 });
                    const result = await uploadFn({
                        imageBase64: ctx.capturedFrame.split(',')[1], // Remove data:image/png;base64, prefix
                        mimeType: 'image/png',
                        filename: `shot_${nextShotIndex + 1}_transferred_frame.png`
                    });

                    if (result.data.success && result.data.url) {
                        finalImageUrl = result.data.url;
                    } else {
                        throw new Error('Upload failed');
                    }
                } else if (ctx.capturedFrame.startsWith('http')) {
                    // It's already a URL (from face correction) - use it directly
                    finalImageUrl = ctx.capturedFrame;
                } else {
                    throw new Error('Invalid frame format');
                }

                // Update next shot with the transferred frame
                nextShot.imageUrl = finalImageUrl;
                nextShot.status = 'ready';
                nextShot.transferredFrom = ctx.shotIndex; // Mark that this was transferred

                // Update preview in modal
                const nextPreview = document.getElementById('next-shot-preview');
                if (nextPreview) {
                    nextPreview.innerHTML = `
                        <img src="${finalImageUrl}" style="width: 100%; height: 100%; object-fit: cover;">
                        <div style="position: absolute; bottom: 0.25rem; right: 0.25rem; background: rgba(16, 185, 129, 0.9); color: white; padding: 0.2rem 0.4rem; border-radius: 0.25rem; font-size: 0.6rem;">
                             Transferred
                        </div>
                    `;
                }

                showToast(`Frame transferred to Shot ${nextShotIndex + 1}! Visual continuity established.`, 'success');

                // Re-render the main modal
                renderShotDecompositionModal();
                scheduleAutoSave();

            } catch (error) {
                console.error('Frame transfer error:', error);
                showToast(`Transfer failed: ${error.message}`, 'error');
            }
        }

        // ==========================================
        // SHOT PREVIEW MODAL - Full-size Image/Video
        // ==========================================

        /**
         * Open large preview modal for a shot's image or video
         * Supports sequential auto-play through consecutive shots with videos
         */
        function openShotPreviewModal(sceneId, shotIndex) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots[shotIndex]) {
                showToast('Shot not found', 'error');
                return;
            }

            const shot = decomposed.shots[shotIndex];
            const hasImage = shot.status === 'ready' && shot.imageUrl;
            const hasVideo = shot.videoStatus === 'ready' && shot.videoUrl;
            const isGeneratingVideo = shot.videoStatus === 'generating' || shot.videoStatus === 'processing';

            if (!hasImage && !hasVideo) {
                showToast('Generate image first to preview', 'info');
                return;
            }

            // Calculate sequential playback info (shots with videos from current onwards)
            const shotsWithVideos = [];
            for (let i = shotIndex; i < decomposed.shots.length; i++) {
                const s = decomposed.shots[i];
                if (s.videoStatus === 'ready' && s.videoUrl) {
                    shotsWithVideos.push({ index: i, shot: s });
                } else {
                    break; // Stop at first shot without video (consecutive only)
                }
            }
            const hasSequentialPlayback = shotsWithVideos.length > 1;
            const currentPositionInSequence = 1;
            const totalInSequence = shotsWithVideos.length;

            // Store context for sequential playback
            window.shotPreviewContext = {
                sceneId,
                currentShotIndex: shotIndex,
                decomposed,
                shotsWithVideos,
                currentPositionInSequence,
                totalInSequence,
                isAutoPlaying: false
            };

            const modal = document.createElement('div');
            modal.id = 'shot-preview-modal';
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex; align-items: center; justify-content: center; z-index: 10001; padding: 1rem;';

            modal.innerHTML = `
                <div style="max-width: 1000px; width: 100%; background: linear-gradient(135deg, #1a1a2e, #0f172a); border-radius: 1rem; border: 1px solid rgba(139, 92, 246, 0.3); overflow: hidden; max-height: 90vh; display: flex; flex-direction: column;">
                    <!-- Header -->
                    <div style="padding: 1rem 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;">
                        <div>
                            <div id="shot-preview-title" style="font-size: 1.1rem; font-weight: 700; color: white; display: flex; align-items: center; gap: 0.5rem;">
                                <span id="shot-number-badge" style="background: rgba(139, 92, 246, 0.3); padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.9rem;">${shotIndex + 1}</span>
                                <span id="shot-type-label">Shot Preview - ${shot.shotType || 'Shot'}</span>
                                ${hasSequentialPlayback ? `
                                    <span id="autoplay-indicator" style="display: none; background: linear-gradient(135deg, #06b6d4, #8b5cf6); padding: 0.2rem 0.5rem; border-radius: 0.25rem; font-size: 0.7rem; font-weight: 600; animation: pulse 2s infinite;">
                                         Auto-playing: <span id="autoplay-position">1</span> of ${totalInSequence}
                                    </span>
                                ` : ''}
                            </div>
                            <div id="shot-preview-subtitle" style="font-size: 0.8rem; color: rgba(255,255,255,0.5); margin-top: 0.25rem;">
                                <span id="shot-camera-info">${shot.cameraMovement || 'static'}  ${shot.duration || 6}s</span>
                                ${shot.transferredFrom !== undefined ? `   Frame from Shot ${shot.transferredFrom + 1}` : ''}
                                ${hasSequentialPlayback ? `  <span style="color: #67e8f9;">${totalInSequence} consecutive shots ready</span>` : ''}
                            </div>
                        </div>
                        <button onclick="closeShotPreviewModal()" style="background: none; border: none; color: rgba(255,255,255,0.5); font-size: 1.5rem; cursor: pointer; padding: 0.5rem; transition: color 0.2s;" onmouseover="this.style.color='white'" onmouseout="this.style.color='rgba(255,255,255,0.5)'">&times;</button>
                    </div>

                    <!-- Content Area -->
                    <div style="flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                        <!-- Tab Buttons (if has video) -->
                        ${hasVideo ? `
                            <div style="display: flex; gap: 0.5rem; padding: 1rem 1rem 0.5rem; background: rgba(0,0,0,0.2);">
                                <button id="preview-tab-image" onclick="switchPreviewTab('image')" style="padding: 0.5rem 1rem; background: rgba(139, 92, 246, 0.3); border: 1px solid rgba(139, 92, 246, 0.5); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                                     Image
                                </button>
                                <button id="preview-tab-video" onclick="switchPreviewTab('video')" style="padding: 0.5rem 1rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: rgba(255,255,255,0.7); cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                                     Video
                                </button>
                            </div>
                        ` : ''}

                        <!-- Preview Container -->
                        <div style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 1rem; background: rgba(0,0,0,0.3); min-height: 280px; max-height: 50vh; overflow: hidden;">
                            <!-- Image Preview -->
                            <div id="preview-content-image" style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">
                                ${hasImage ? `
                                    <img src="${shot.imageUrl}" style="max-width: 100%; max-height: 48vh; object-fit: contain; border-radius: 0.5rem; box-shadow: 0 8px 32px rgba(0,0,0,0.5);">
                                ` : `
                                    <div style="text-align: center; color: rgba(255,255,255,0.4);">
                                        <span style="font-size: 3rem;"></span>
                                        <div style="margin-top: 0.5rem;">No image generated yet</div>
                                    </div>
                                `}
                            </div>
                            <!-- Video Preview (hidden by default) -->
                            <div id="preview-content-video" style="display: none; align-items: center; justify-content: center; width: 100%; height: 100%;">
                                ${hasVideo ? `
                                    <video id="shot-preview-video" src="${shot.videoUrl}" controls autoplay style="max-width: 100%; max-height: 48vh; object-fit: contain; border-radius: 0.5rem; box-shadow: 0 8px 32px rgba(0,0,0,0.5);"></video>
                                ` : isGeneratingVideo ? `
                                    <div style="text-align: center; color: rgba(255,255,255,0.6);">
                                        <div style="width: 48px; height: 48px; margin: 0 auto 1rem; border: 3px solid rgba(6, 182, 212, 0.2); border-top-color: #06b6d4; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                        <div>Video generating...</div>
                                    </div>
                                ` : `
                                    <div style="text-align: center; color: rgba(255,255,255,0.4);">
                                        <span style="font-size: 3rem;"></span>
                                        <div style="margin-top: 0.5rem;">No video generated yet</div>
                                    </div>
                                `}
                            </div>
                        </div>

                        <!-- Prompts Section (Image + Video) -->
                        <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-top: 1px solid rgba(255,255,255,0.1);">
                            <!-- Narrative Beat (Action Info) -->
                            ${shot.narrativeBeat?.motionDescription ? `
                                <div style="margin-bottom: 0.75rem; padding: 0.5rem 0.75rem; background: rgba(6, 182, 212, 0.15); border: 1px solid rgba(6, 182, 212, 0.3); border-radius: 0.375rem;">
                                    <div style="font-size: 0.65rem; color: #67e8f9; font-weight: 600; margin-bottom: 0.25rem;"> ACTION (for video)</div>
                                    <div style="font-size: 0.8rem; color: rgba(255,255,255,0.9); line-height: 1.4;">
                                        ${shot.narrativeBeat.motionDescription}
                                    </div>
                                    ${shot.narrativeBeat.transitionHook ? `
                                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-top: 0.25rem; font-style: italic;">
                                             ${shot.narrativeBeat.transitionHook}
                                        </div>
                                    ` : ''}
                                </div>
                            ` : ''}

                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                                <!-- Image Prompt -->
                                <div>
                                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.25rem;"> IMAGE PROMPT</div>
                                    <div style="font-size: 0.75rem; color: rgba(255,255,255,0.7); line-height: 1.4; max-height: 60px; overflow-y: auto;">
                                        ${shot.imagePrompt || shot.prompt || 'No prompt'}
                                    </div>
                                </div>
                                <!-- Video Prompt -->
                                <div>
                                    <div style="font-size: 0.65rem; color: rgba(6, 182, 212, 0.8); margin-bottom: 0.25rem;"> VIDEO PROMPT</div>
                                    <div style="font-size: 0.75rem; color: rgba(103, 232, 249, 0.9); line-height: 1.4; max-height: 60px; overflow-y: auto;">
                                        ${shot.videoPrompt || 'Action prompt will be generated from scene data'}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Actions Footer - Frame Chain Workflow -->
                    <div style="padding: 1rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 0.75rem; flex-wrap: wrap; flex-shrink: 0;">
                        <!-- Image Source Status (no generate button - frame chain only) -->
                        ${shotIndex === 0 ? `
                            <div style="flex: 1; min-width: 120px; padding: 0.6rem; background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.5rem; text-align: center;">
                                <span style="color: #10b981; font-size: 0.85rem;"> Uses Scene Image</span>
                            </div>
                        ` : `
                            <div style="flex: 1; min-width: 120px; padding: 0.6rem; background: ${hasImage ? 'rgba(16, 185, 129, 0.15)' : 'rgba(139, 92, 246, 0.15)'}; border: 1px solid ${hasImage ? 'rgba(16, 185, 129, 0.3)' : 'rgba(139, 92, 246, 0.3)'}; border-radius: 0.5rem; text-align: center;">
                                <span style="color: ${hasImage ? '#10b981' : '#a78bfa'}; font-size: 0.85rem;">
                                    ${hasImage ? ' Frame Chain Image' : ' Awaiting Frame Transfer'}
                                </span>
                            </div>
                        `}
                        ${hasImage ? `
                            <button onclick="generateSingleShotVideo(${sceneId}, ${shotIndex}); closeShotPreviewModal();"
                                    style="flex: 1; min-width: 120px; padding: 0.6rem; background: ${hasVideo ? 'rgba(6, 182, 212, 0.15)' : 'linear-gradient(135deg, rgba(6, 182, 212, 0.3), rgba(59, 130, 246, 0.3))'}; border: 1px solid rgba(6, 182, 212, 0.4); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                                ${hasVideo ? ' Re-Animate' : ' Animate Shot'}
                            </button>
                        ` : ''}
                        ${hasVideo && shotIndex < decomposed.shots.length - 1 ? `
                            <button onclick="closeShotPreviewModal(); openFrameCaptureModal(${sceneId}, ${shotIndex});"
                                    style="flex: 1; min-width: 140px; padding: 0.6rem; background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(5, 150, 105, 0.3)); border: 1px solid rgba(16, 185, 129, 0.5); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                                 Capture Frame  Shot ${shotIndex + 2}
                            </button>
                        ` : ''}
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Close on escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    closeShotPreviewModal();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);

            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeShotPreviewModal();
                }
            });

            // Setup sequential playback if video exists and has consecutive shots
            if (hasVideo && hasSequentialPlayback) {
                const video = document.getElementById('shot-preview-video');
                if (video) {
                    video.addEventListener('ended', handleVideoEnded);
                    video.addEventListener('play', () => {
                        window.shotPreviewContext.isAutoPlaying = true;
                        const indicator = document.getElementById('autoplay-indicator');
                        if (indicator) indicator.style.display = 'inline-flex';
                    });
                }
            }
        }

        /**
         * Handle video ended - advance to next shot in sequence
         */
        function handleVideoEnded() {
            const ctx = window.shotPreviewContext;
            if (!ctx || !ctx.shotsWithVideos || ctx.shotsWithVideos.length <= 1) return;

            // Find current position in sequence
            const currentIdx = ctx.shotsWithVideos.findIndex(s => s.index === ctx.currentShotIndex);
            const nextIdx = currentIdx + 1;

            if (nextIdx < ctx.shotsWithVideos.length) {
                // Advance to next shot
                const nextShot = ctx.shotsWithVideos[nextIdx];
                ctx.currentShotIndex = nextShot.index;
                ctx.currentPositionInSequence = nextIdx + 1;

                // Update modal content without closing
                updateShotPreviewContent(nextShot.index, nextShot.shot, ctx);
            } else {
                // Reached end of sequence
                window.shotPreviewContext.isAutoPlaying = false;
                const indicator = document.getElementById('autoplay-indicator');
                if (indicator) {
                    indicator.innerHTML = ' Sequence Complete';
                    indicator.style.background = 'rgba(16, 185, 129, 0.5)';
                }
            }
        }

        /**
         * Update shot preview content without closing the modal (for sequential playback)
         */
        function updateShotPreviewContent(shotIndex, shot, ctx) {
            // Update header
            const badge = document.getElementById('shot-number-badge');
            const typeLabel = document.getElementById('shot-type-label');
            const cameraInfo = document.getElementById('shot-camera-info');
            const positionIndicator = document.getElementById('autoplay-position');

            if (badge) badge.textContent = shotIndex + 1;
            if (typeLabel) typeLabel.textContent = `Shot Preview - ${shot.shotType || 'Shot'}`;
            if (cameraInfo) cameraInfo.textContent = `${shot.cameraMovement || 'static'}  ${shot.duration || 6}s`;
            if (positionIndicator) positionIndicator.textContent = ctx.currentPositionInSequence;

            // Update video source
            const video = document.getElementById('shot-preview-video');
            if (video && shot.videoUrl) {
                video.src = shot.videoUrl;
                video.play();
            }

            // Update image if exists
            const imageContent = document.getElementById('preview-content-image');
            if (imageContent && shot.imageUrl) {
                imageContent.innerHTML = `
                    <img src="${shot.imageUrl}" style="max-width: 100%; max-height: 48vh; object-fit: contain; border-radius: 0.5rem; box-shadow: 0 8px 32px rgba(0,0,0,0.5);">
                `;
            }

            // Update prompts section
            updateShotPreviewPrompts(shot);
        }

        /**
         * Update the prompts section in the preview modal
         */
        function updateShotPreviewPrompts(shot) {
            // Find and update the prompts container (simplified update)
            const promptsContainer = document.querySelector('#shot-preview-modal [style*="grid-template-columns: 1fr 1fr"]');
            if (promptsContainer) {
                promptsContainer.innerHTML = `
                    <!-- Image Prompt -->
                    <div>
                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.25rem;"> IMAGE PROMPT</div>
                        <div style="font-size: 0.75rem; color: rgba(255,255,255,0.7); line-height: 1.4; max-height: 60px; overflow-y: auto;">
                            ${shot.imagePrompt || shot.prompt || 'No prompt'}
                        </div>
                    </div>
                    <!-- Video Prompt -->
                    <div>
                        <div style="font-size: 0.65rem; color: rgba(6, 182, 212, 0.8); margin-bottom: 0.25rem;"> VIDEO PROMPT</div>
                        <div style="font-size: 0.75rem; color: rgba(103, 232, 249, 0.9); line-height: 1.4; max-height: 60px; overflow-y: auto;">
                            ${shot.videoPrompt || 'Action prompt will be generated from scene data'}
                        </div>
                    </div>
                `;
            }
        }

        /**
         * Close shot preview modal
         */
        function closeShotPreviewModal() {
            const modal = document.getElementById('shot-preview-modal');
            if (modal) modal.remove();
            // Clean up context
            window.shotPreviewContext = null;
        }

        /**
         * Switch between image and video tabs in preview
         */
        function switchPreviewTab(tab) {
            const imageContent = document.getElementById('preview-content-image');
            const videoContent = document.getElementById('preview-content-video');
            const imageTab = document.getElementById('preview-tab-image');
            const videoTab = document.getElementById('preview-tab-video');

            if (tab === 'video') {
                if (imageContent) imageContent.style.display = 'none';
                if (videoContent) videoContent.style.display = 'flex';
                if (imageTab) {
                    imageTab.style.background = 'rgba(255,255,255,0.05)';
                    imageTab.style.borderColor = 'rgba(255,255,255,0.2)';
                    imageTab.style.color = 'rgba(255,255,255,0.7)';
                }
                if (videoTab) {
                    videoTab.style.background = 'rgba(6, 182, 212, 0.3)';
                    videoTab.style.borderColor = 'rgba(6, 182, 212, 0.5)';
                    videoTab.style.color = 'white';
                }
            } else {
                if (imageContent) imageContent.style.display = 'flex';
                if (videoContent) videoContent.style.display = 'none';
                if (imageTab) {
                    imageTab.style.background = 'rgba(139, 92, 246, 0.3)';
                    imageTab.style.borderColor = 'rgba(139, 92, 246, 0.5)';
                    imageTab.style.color = 'white';
                }
                if (videoTab) {
                    videoTab.style.background = 'rgba(255,255,255,0.05)';
                    videoTab.style.borderColor = 'rgba(255,255,255,0.2)';
                    videoTab.style.color = 'rgba(255,255,255,0.7)';
                }
            }
        }

        /**
         * Parse and format API error messages for user-friendly display
         */
        function formatVideoGenerationError(error) {
            const msg = error.message || error.toString();

            // Check for common API errors
            if (msg.includes('insufficient balance') || msg.includes('insufficient_balance')) {
                return ' Minimax account has insufficient balance. Please add credits to your Minimax account.';
            }
            if (msg.includes('rate limit') || msg.includes('too many requests')) {
                return ' Rate limit reached. Please wait a moment and try again.';
            }
            if (msg.includes('invalid') && msg.includes('key')) {
                return ' API key issue. Please check your Minimax API configuration.';
            }
            if (msg.includes('timeout')) {
                return ' Request timed out. Please try again.';
            }
            if (msg.includes('network') || msg.includes('ECONNREFUSED')) {
                return ' Network error. Please check your connection and try again.';
            }

            // Return sanitized error
            return msg.length > 100 ? msg.substring(0, 100) + '...' : msg;
        }

        /**
         * Render multi-shot timeline HTML for a scene
         */
        function renderMultiShotTimeline(sceneId) {
            const decomposed = state.storyboard.multiShotMode.decomposedScenes[sceneId];
            if (!decomposed || !decomposed.shots || decomposed.shots.length === 0) {
                return '';
            }

            const selectedShot = decomposed.selectedShot || 0;
            const imagesReady = decomposed.shots.filter(s => s.status === 'ready' && s.imageUrl).length;
            const videosReady = decomposed.shots.filter(s => s.videoStatus === 'ready' && s.videoUrl).length;
            const videosProcessing = decomposed.shots.filter(s => s.videoStatus === 'processing' || s.videoStatus === 'generating').length;

            return `
                <div style="margin-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 0.5rem;">
                    <!-- Header with action buttons -->
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.4rem; flex-wrap: wrap; gap: 0.3rem;">
                        <span style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">
                             ${decomposed.shots.length} SHOTS
                            ${imagesReady > 0 ? `<span style="color: #10b981;"> ${imagesReady} </span>` : ''}
                            ${videosReady > 0 ? `<span style="color: #06b6d4;"> ${videosReady} </span>` : ''}
                            ${videosProcessing > 0 ? `<span style="color: #f59e0b;"> ${videosProcessing} </span>` : ''}
                        </span>
                        <div style="display: flex; gap: 0.25rem;">
                            <!-- Frame Chain Workflow: Images come from scene (shot 1) or frame transfer (shots 2+) -->
                            ${videosReady > 0 ? `
                                <button onclick="previewSceneVideoSequence(${sceneId})"
                                        style="padding: 0.2rem 0.4rem; font-size: 0.55rem; background: linear-gradient(135deg, rgba(16,185,129,0.3), rgba(34,197,94,0.3)); border: 1px solid rgba(16,185,129,0.4); border-radius: 0.3rem; color: white; cursor: pointer;">
                                     Preview
                                </button>
                            ` : ''}
                        </div>
                    </div>

                    <!-- Shot thumbnails -->
                    <div style="display: flex; gap: 0.3rem; overflow-x: auto; padding-bottom: 0.3rem;">
                        ${decomposed.shots.map((shot, idx) => `
                            <div onclick="selectShot(${sceneId}, ${idx})"
                                 style="flex-shrink: 0; width: 55px; cursor: pointer; border: 2px solid ${selectedShot === idx ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; border-radius: 0.3rem; overflow: hidden; background: rgba(0,0,0,0.3); position: relative;">
                                ${shot.status === 'ready' && shot.imageUrl ? `
                                    <div style="position: relative;">
                                        <img src="${shot.imageUrl}" style="width: 100%; height: 35px; object-fit: cover;">
                                        ${shot.videoStatus === 'ready' ? `
                                            <div style="position: absolute; top: 2px; right: 2px; width: 12px; height: 12px; background: rgba(16,185,129,0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                                <span style="font-size: 6px;"></span>
                                            </div>
                                        ` : shot.videoStatus === 'processing' || shot.videoStatus === 'generating' ? `
                                            <div style="position: absolute; top: 2px; right: 2px; width: 12px; height: 12px; background: rgba(245,158,11,0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                                <div class="animate-spin" style="width: 6px; height: 6px; border: 1px solid rgba(0,0,0,0.3); border-top-color: white; border-radius: 50%;"></div>
                                            </div>
                                        ` : ''}
                                    </div>
                                ` : shot.status === 'generating' ? `
                                    <div style="width: 100%; height: 35px; display: flex; align-items: center; justify-content: center; background: rgba(139,92,246,0.2);">
                                        <div class="animate-spin" style="width: 12px; height: 12px; border: 2px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%;"></div>
                                    </div>
                                ` : `
                                    <div style="width: 100%; height: 35px; display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.05); font-size: 0.7rem; color: rgba(255,255,255,0.4);">
                                        ${shot.status === 'error' ? '' : idx === 0 ? '' : ''}
                                    </div>
                                `}
                                <div style="font-size: 0.45rem; text-align: center; padding: 0.1rem; color: rgba(255,255,255,0.6); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; background: rgba(0,0,0,0.5);">
                                    ${shot.shotType?.replace('_', ' ').substring(0, 8) || `Shot ${idx + 1}`}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // ==========================================
        // PHASE 12C: BATCH OPERATIONS & GLOBAL CONSISTENCY
        // ==========================================

        /**
         * Batch decompose ALL scenes at once with global visual consistency
         */
        async function batchDecomposeAllScenes() {
            if (!state.storyboard.scenes || state.storyboard.scenes.length === 0) {
                showToast('No scenes to decompose', 'warning');
                return;
            }

            // Initialize batch state
            if (!state.storyboard.multiShotMode) {
                state.storyboard.multiShotMode = { enabled: true, decomposedScenes: {} };
            }
            state.storyboard.multiShotMode.enabled = true;
            state.storyboard.multiShotMode.batchStatus = {
                status: 'processing',
                totalScenes: state.storyboard.scenes.length,
                processedScenes: 0,
                startTime: Date.now()
            };
            render();

            showToast('Starting batch decomposition with global visual consistency...', 'info');

            try {
                // Prepare scenes data for the batch function
                const scenesData = state.storyboard.scenes.map(scene => ({
                    sceneId: scene.sceneId,
                    description: scene.description || scene.content,
                    duration: scene.duration || 5,
                    shotCount: state.storyboard.multiShotMode?.defaultShotCount || 3
                }));

                const batchDecomposeFn = functions.httpsCallable('creationWizardBatchDecomposeScenes', { timeout: 540000 });

                // Get clip duration from script timing (Minimax only supports 6 or 10 seconds) - Default to 10s
                const clipDuration = state.script.timing?.clipDuration || 10;

                const result = await batchDecomposeFn({
                    projectId: state.projectId,
                    scenes: scenesData,
                    clipDuration: clipDuration, // CRITICAL: Pass clip duration for correct shot calculations
                    visualStyle: state.storyboard.visualStyle || {},
                    scriptSummary: state.script?.content?.substring(0, 500) || ''
                });

                if (result.data.success) {
                    // Store global visual profile
                    state.storyboard.multiShotMode.globalVisualProfile = result.data.globalVisualProfile;

                    // Store decomposed scenes
                    result.data.decomposedScenes.forEach(sceneResult => {
                        if (sceneResult.success) {
                            state.storyboard.multiShotMode.decomposedScenes[sceneResult.sceneId] = {
                                shots: sceneResult.shots,
                                consistencyAnchors: sceneResult.consistencyAnchors,
                                status: 'decomposed',
                                globalVisualDNA: result.data.globalVisualProfile
                            };
                        }
                    });

                    state.storyboard.multiShotMode.batchStatus = {
                        status: 'complete',
                        totalScenes: state.storyboard.scenes.length,
                        processedScenes: result.data.decomposedScenes.filter(s => s.success).length,
                        completedAt: Date.now()
                    };

                    showToast(`Decomposed ${result.data.decomposedScenes.filter(s => s.success).length}/${state.storyboard.scenes.length} scenes!`, 'success');
                } else {
                    throw new Error(result.data.error || 'Batch decomposition failed');
                }

            } catch (error) {
                console.error('Batch decomposition error:', error);
                state.storyboard.multiShotMode.batchStatus = {
                    status: 'error',
                    error: error.message
                };
                showToast(`Batch decomposition failed: ${error.message}`, 'error');
            }

            render();
            scheduleAutoSave();
        }

        /**
         * Batch generate ALL shot images across all scenes
         */
        async function batchGenerateAllShotImages() {
            const decomposedScenes = state.storyboard.multiShotMode?.decomposedScenes || {};
            const sceneIds = Object.keys(decomposedScenes);

            if (sceneIds.length === 0) {
                showToast('No decomposed scenes found. Please decompose scenes first.', 'warning');
                return;
            }

            // Count total shots
            let totalShots = 0;
            sceneIds.forEach(sceneId => {
                const scene = decomposedScenes[sceneId];
                if (scene?.shots) {
                    totalShots += scene.shots.filter(s => s.status !== 'ready').length;
                }
            });

            if (totalShots === 0) {
                showToast('All shot images are already generated!', 'info');
                return;
            }

            // Initialize batch image generation state
            state.storyboard.multiShotMode.batchImageStatus = {
                status: 'processing',
                totalShots: totalShots,
                processedShots: 0,
                startTime: Date.now()
            };
            render();

            showToast(`Generating ${totalShots} shot images across ${sceneIds.length} scenes...`, 'info');

            try {
                // Prepare decomposed scenes data in the format backend expects
                // Backend expects: Array of { sceneId, shots: [...] }
                const decomposedScenesArray = [];
                sceneIds.forEach(sceneId => {
                    const scene = decomposedScenes[sceneId];
                    if (scene?.shots) {
                        const shotsToGenerate = [];
                        scene.shots.forEach((shot, idx) => {
                            if (shot.status !== 'ready') {
                                shotsToGenerate.push({
                                    shotIndex: idx,
                                    shotType: shot.shotType,
                                    prompt: shot.prompt,
                                    imagePrompt: shot.imagePrompt || shot.prompt,
                                    cameraMovement: shot.cameraMovement,
                                    duration: shot.duration,
                                    narrativeBeat: shot.narrativeBeat || null,
                                    subject: shot.subject || '',
                                    action: shot.action || '',
                                    environment: shot.environment || '',
                                    mood: shot.mood || ''
                                });
                                // Mark as generating
                                shot.status = 'generating';
                            }
                        });
                        if (shotsToGenerate.length > 0) {
                            decomposedScenesArray.push({
                                sceneId: sceneId,
                                shots: shotsToGenerate
                            });
                        }
                    }
                });
                render();

                // CRITICAL FIX: Ensure character portrait base64 is ready before generation
                // This fixes race condition where base64 refresh runs in background after project load
                if (state.storyboard.characterBible?.enabled) {
                    const charsNeedingBase64 = (state.storyboard.characterBible.characters || []).filter(
                        c => c.referenceImageUrl && c.referenceImageStatus === 'ready' && !c.referenceImageBase64
                    );

                    if (charsNeedingBase64.length > 0) {
                        console.log(`[Batch Image Gen] Fetching base64 for ${charsNeedingBase64.length} character portrait(s)...`);
                        showToast(`Preparing ${charsNeedingBase64.length} character portrait(s)...`, 'info');

                        for (const char of charsNeedingBase64) {
                            try {
                                const base64 = await fetchImageAsBase64(char.referenceImageUrl);
                                if (base64) {
                                    char.referenceImageBase64 = base64;
                                    console.log(`[Batch Image Gen] Base64 ready for "${char.name}"`);
                                }
                            } catch (err) {
                                console.warn(`[Batch Image Gen] Failed to fetch base64 for "${char.name}":`, err);
                            }
                        }
                    }
                }

                // Get character reference for face consistency (first character with portrait)
                const characterReference = getCharacterReferenceForScene(sceneIds[0]);

                // Get full character bible for character descriptions in prompts
                const characterBible = state.storyboard.characterBible?.enabled ? {
                    enabled: true,
                    characters: (state.storyboard.characterBible.characters || []).map(c => ({
                        name: c.name,
                        description: c.description,
                        physicalDescription: c.description,
                        attire: c.attire || '',
                        appliedToScenes: c.appliedToScenes || []
                    }))
                } : null;

                console.log('[Batch Image Gen] Character reference:', characterReference ? 'YES (base64 ready)' : 'NO');
                console.log('[Batch Image Gen] Character bible:', characterBible ? `${characterBible.characters.length} characters` : 'disabled');

                // Build location bible data for backend
                const locationBible = state.storyboard.locationBible?.enabled ? {
                    enabled: true,
                    locations: (state.storyboard.locationBible.locations || []).filter(l => l.referenceImageBase64 && l.referenceImageStatus === 'ready').map(l => ({
                        id: l.id,
                        name: l.name,
                        description: l.description,
                        type: l.type,
                        timeOfDay: l.timeOfDay,
                        weather: l.weather,
                        mood: l.mood,
                        lightingStyle: l.lightingStyle,
                        keyElements: l.keyElements,
                        referenceImageBase64: l.referenceImageBase64,
                        referenceImageMimeType: l.referenceImageMimeType || 'image/png',
                        referenceImageStatus: l.referenceImageStatus,
                        appliedToScenes: l.appliedToScenes || []
                    }))
                } : null;
                console.log('[Batch Image Gen] Location bible:', locationBible ? `${locationBible.locations.length} locations with references` : 'disabled');

                const batchGenerateFn = functions.httpsCallable('creationWizardBatchGenerateShotImages', { timeout: 540000 });
                const result = await batchGenerateFn({
                    projectId: state.projectId,
                    decomposedScenes: decomposedScenesArray,
                    globalVisualProfile: state.storyboard.multiShotMode.globalVisualProfile || {},
                    model: state.storyboard.imageModel || 'nanobanana-pro',
                    aspectRatio: state.platform.aspectRatio || '16:9',
                    // Character consistency parameters
                    characterReference: characterReference,
                    characterBible: characterBible,
                    // Location consistency parameters
                    locationBible: locationBible,
                    // VISUAL_STYLE_DNA: Visual rendering style mode
                    visualStyleMode: state.content.visualStyleMode || 'photorealistic'
                });

                if (result.data.success) {
                    // Update shots with generated images
                    let successCount = 0;
                    result.data.results.forEach(shotResult => {
                        const scene = decomposedScenes[shotResult.sceneId];
                        if (scene && scene.shots[shotResult.shotIndex]) {
                            const shot = scene.shots[shotResult.shotIndex];
                            if (shotResult.success && shotResult.imageUrl) {
                                shot.imageUrl = shotResult.imageUrl;
                                shot.status = 'ready';
                                successCount++;
                            } else {
                                shot.status = 'error';
                                shot.error = shotResult.error || 'Generation failed';
                            }
                        }
                    });

                    state.storyboard.multiShotMode.batchImageStatus = {
                        status: 'complete',
                        totalShots: totalShots,
                        processedShots: successCount,
                        completedAt: Date.now()
                    };

                    showToast(`Generated ${successCount}/${totalShots} shot images!`, 'success');
                } else {
                    throw new Error(result.data.error || 'Batch image generation failed');
                }

            } catch (error) {
                console.error('Batch image generation error:', error);
                state.storyboard.multiShotMode.batchImageStatus = {
                    status: 'error',
                    error: error.message
                };
                showToast(`Batch image generation failed: ${error.message}`, 'error');
            }

            render();
            scheduleAutoSave();
        }

        /**
         * Export multi-shot project with all sequences
         */
        async function exportMultiShotProject() {
            const decomposedScenes = state.storyboard.multiShotMode?.decomposedScenes || {};
            const sceneIds = Object.keys(decomposedScenes);

            if (sceneIds.length === 0) {
                showToast('No multi-shot scenes to export', 'warning');
                return;
            }

            showToast('Preparing multi-shot project export...', 'info');

            try {
                // Prepare scene sequences
                const sceneSequences = [];
                sceneIds.forEach(sceneId => {
                    const scene = decomposedScenes[sceneId];
                    if (scene?.shots) {
                        const shots = scene.shots.map((shot, idx) => ({
                            shotIndex: idx,
                            shotType: shot.shotType,
                            imageUrl: shot.imageUrl,
                            videoUrl: shot.videoUrl,
                            duration: shot.duration || 3
                        }));
                        sceneSequences.push({
                            sceneId: sceneId,
                            shots: shots,
                            consistencyAnchors: scene.consistencyAnchors
                        });
                    }
                });

                const exportFn = functions.httpsCallable('creationWizardExportMultiShotProject', { timeout: 120000 });
                const result = await exportFn({
                    projectId: state.projectId,
                    projectTitle: state.topic || 'Untitled Project',
                    sceneSequences: sceneSequences,
                    globalVisualProfile: state.storyboard.multiShotMode.globalVisualProfile || {},
                    audioTrack: state.audioTrack?.url || null
                });

                if (result.data.success) {
                    // Show export modal with manifest
                    showExportMultiShotModal(result.data.manifest);
                    showToast('Export manifest ready!', 'success');
                } else {
                    throw new Error(result.data.error || 'Export failed');
                }

            } catch (error) {
                console.error('Export error:', error);
                showToast(`Export failed: ${error.message}`, 'error');
            }
        }

        /**
         * Show export modal with multi-shot manifest
         */
        function showExportMultiShotModal(manifest) {
            const modal = document.createElement('div');
            modal.id = 'export-multishot-modal';
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 2rem;';

            modal.innerHTML = `
                <div style="max-width: 700px; width: 100%; background: #1a1a2e; border-radius: 1rem; overflow: hidden; max-height: 90vh; overflow-y: auto;">
                    <div style="padding: 1.5rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 1.2rem; font-weight: 600; color: white;">Multi-Shot Project Export</div>
                                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.5);">${manifest.projectTitle}</div>
                            </div>
                            <button onclick="document.getElementById('export-multishot-modal').remove()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer;">x</button>
                        </div>
                    </div>
                    <div style="padding: 1.5rem;">
                        <!-- Summary -->
                        <div style="background: rgba(139,92,246,0.1); border: 1px solid rgba(139,92,246,0.3); border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center;">
                                <div>
                                    <div style="font-size: 1.5rem; font-weight: 700; color: #8b5cf6;">${manifest.totalScenes}</div>
                                    <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">Scenes</div>
                                </div>
                                <div>
                                    <div style="font-size: 1.5rem; font-weight: 700; color: #06b6d4;">${manifest.totalShots}</div>
                                    <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">Total Shots</div>
                                </div>
                                <div>
                                    <div style="font-size: 1.5rem; font-weight: 700; color: #10b981;">${Math.round(manifest.totalDuration)}s</div>
                                    <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">Duration</div>
                                </div>
                            </div>
                        </div>

                        <!-- Visual Profile -->
                        ${manifest.globalVisualProfile ? `
                            <div style="background: rgba(255,255,255,0.05); border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
                                <div style="font-size: 0.8rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">Global Visual DNA</div>
                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.6); line-height: 1.5;">
                                    ${manifest.globalVisualProfile.colorPalette ? `<span style="color: #f59e0b;">Colors:</span> ${manifest.globalVisualProfile.colorPalette}<br>` : ''}
                                    ${manifest.globalVisualProfile.lighting ? `<span style="color: #f59e0b;">Lighting:</span> ${manifest.globalVisualProfile.lighting}<br>` : ''}
                                    ${manifest.globalVisualProfile.style ? `<span style="color: #f59e0b;">Style:</span> ${manifest.globalVisualProfile.style}` : ''}
                                </div>
                            </div>
                        ` : ''}

                        <!-- Scene List -->
                        <div style="font-size: 0.8rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">Scene Sequences</div>
                        <div style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 0.5rem; padding: 0.5rem;">
                            ${manifest.scenes.map((scene, idx) => `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.05);">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-size: 0.7rem; color: rgba(255,255,255,0.4);">${idx + 1}.</span>
                                        <span style="font-size: 0.75rem; color: white;">Scene ${scene.sceneId}</span>
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; font-size: 0.65rem;">
                                        <span style="color: rgba(255,255,255,0.5);">${scene.shotCount} shots</span>
                                        <span style="color: rgba(255,255,255,0.4);">${scene.duration}s</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>

                        <!-- Export Actions -->
                        <div style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button onclick="downloadExportManifest()" style="flex: 1; padding: 0.75rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border: none; border-radius: 0.5rem; color: white; cursor: pointer; font-weight: 600;">
                                Download JSON Manifest
                            </button>
                            <button onclick="copyFFmpegCommand()" style="flex: 1; padding: 0.75rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; cursor: pointer; font-weight: 600;">
                                Copy FFmpeg Command
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Store manifest for download
            window.currentExportManifest = manifest;

            window.downloadExportManifest = function() {
                const blob = new Blob([JSON.stringify(manifest, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${manifest.projectTitle.replace(/[^a-z0-9]/gi, '_')}_multishot_export.json`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('Manifest downloaded!', 'success');
            };

            window.copyFFmpegCommand = function() {
                if (manifest.ffmpegConcatFile) {
                    navigator.clipboard.writeText(manifest.ffmpegConcatFile);
                    showToast('FFmpeg concat file copied to clipboard!', 'success');
                } else {
                    showToast('No FFmpeg command available', 'warning');
                }
            };
        }

        /**
         * Render global visual profile display
         */
        function renderGlobalVisualProfile() {
            const profile = state.storyboard.multiShotMode?.globalVisualProfile;
            if (!profile) return '';

            return `
                <div style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(6,182,212,0.1)); border: 1px solid rgba(139,92,246,0.3); border-radius: 0.5rem; padding: 0.75rem; margin-top: 0.5rem;">
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                        <span style="font-size: 0.75rem;"></span>
                        <span style="font-size: 0.7rem; font-weight: 600; color: white;">Global Visual DNA</span>
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.6rem;">
                        ${profile.colorPalette ? `<span style="background: rgba(245,158,11,0.2); padding: 0.2rem 0.4rem; border-radius: 0.25rem; color: #f59e0b;">${profile.colorPalette}</span>` : ''}
                        ${profile.lighting ? `<span style="background: rgba(6,182,212,0.2); padding: 0.2rem 0.4rem; border-radius: 0.25rem; color: #06b6d4;">${profile.lighting}</span>` : ''}
                        ${profile.style ? `<span style="background: rgba(139,92,246,0.2); padding: 0.2rem 0.4rem; border-radius: 0.25rem; color: #8b5cf6;">${profile.style}</span>` : ''}
                    </div>
                </div>
            `;
        }

        /**
         * Render batch operation progress
         */
        function renderBatchProgress() {
            const batchStatus = state.storyboard.multiShotMode?.batchStatus;
            const batchImageStatus = state.storyboard.multiShotMode?.batchImageStatus;

            if (!batchStatus && !batchImageStatus) return '';

            let html = '';

            if (batchStatus && batchStatus.status === 'processing') {
                const progress = Math.round((batchStatus.processedScenes / batchStatus.totalScenes) * 100);
                html += `
                    <div style="background: rgba(139,92,246,0.1); border: 1px solid rgba(139,92,246,0.3); border-radius: 0.5rem; padding: 0.5rem; margin-top: 0.5rem;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.25rem;">
                            <span style="font-size: 0.65rem; color: rgba(255,255,255,0.7);">Decomposing scenes...</span>
                            <span style="font-size: 0.6rem; color: #8b5cf6;">${batchStatus.processedScenes}/${batchStatus.totalScenes}</span>
                        </div>
                        <div style="height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden;">
                            <div style="height: 100%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); width: ${progress}%; transition: width 0.3s;"></div>
                        </div>
                    </div>
                `;
            }

            if (batchImageStatus && batchImageStatus.status === 'processing') {
                const progress = Math.round((batchImageStatus.processedShots / batchImageStatus.totalShots) * 100);
                html += `
                    <div style="background: rgba(6,182,212,0.1); border: 1px solid rgba(6,182,212,0.3); border-radius: 0.5rem; padding: 0.5rem; margin-top: 0.5rem;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.25rem;">
                            <span style="font-size: 0.65rem; color: rgba(255,255,255,0.7);">Generating shot images...</span>
                            <span style="font-size: 0.6rem; color: #06b6d4;">${batchImageStatus.processedShots}/${batchImageStatus.totalShots}</span>
                        </div>
                        <div style="height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden;">
                            <div style="height: 100%; background: linear-gradient(90deg, #06b6d4, #10b981); width: ${progress}%; transition: width 0.3s;"></div>
                        </div>
                    </div>
                `;
            }

            return html;
        }

        function startImagePolling(sceneId, jobId) {
            // Clear any existing polling for this scene
            if (imagePollingIntervals[sceneId]) {
                clearInterval(imagePollingIntervals[sceneId]);
            }

            let pollCount = 0;
            const maxPolls = 150; // 5 minutes max (2s intervals) - handles RunPod cold starts

            imagePollingIntervals[sceneId] = setInterval(async () => {
                pollCount++;

                if (pollCount > maxPolls) {
                    clearInterval(imagePollingIntervals[sceneId]);
                    const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                    if (storyboardScene && storyboardScene.status === 'generating') {
                        storyboardScene.status = 'error';
                        storyboardScene.error = 'Generation timed out. Try again.';
                        render();
                    }
                    return;
                }

                try {
                    const checkStatusFn = functions.httpsCallable('creationWizardCheckImageStatus');
                    const result = await checkStatusFn({ jobId });

                    if (result.data.status === 'COMPLETED') {
                        clearInterval(imagePollingIntervals[sceneId]);

                        const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                        if (storyboardScene) {
                            // Add cache-busting parameter to force browser to fetch fresh
                            if (storyboardScene.imageUrl) {
                                const separator = storyboardScene.imageUrl.includes('?') ? '&' : '?';
                                storyboardScene.imageUrl = `${storyboardScene.imageUrl}${separator}t=${Date.now()}`;
                            }

                            // Wait a moment for Firebase Storage to fully propagate the upload
                            await new Promise(resolve => setTimeout(resolve, 1000));

                            storyboardScene.status = 'ready';

                            // CRITICAL: Sync scene image to Shot 1 if decomposed
                            // When HiDream scene image completes, Shot 1 should automatically get the image
                            const decomposed = state.storyboard.multiShotMode?.decomposedScenes?.[sceneId];
                            if (decomposed?.shots?.length > 0 && storyboardScene.imageUrl) {
                                decomposed.shots[0].imageUrl = storyboardScene.imageUrl;
                                decomposed.shots[0].status = 'ready';
                                decomposed.shots[0].fromSceneImage = true;
                                console.log('[HiDream Polling] Synced completed scene image to Shot 1');
                            }
                        }

                        // Check if all generating scenes are done
                        const allDone = state.storyboard.scenes.every(s =>
                            s.status === 'ready' || s.status === 'pending' || s.status === 'error'
                        );
                        if (allDone) {
                            state.storyboard.status = 'ready';
                        }

                        render();
                        scheduleAutoSave();

                    } else if (result.data.status === 'FAILED') {
                        clearInterval(imagePollingIntervals[sceneId]);

                        const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                        if (storyboardScene) {
                            storyboardScene.status = 'error';
                            storyboardScene.error = result.data.error || 'Generation failed';
                        }
                        render();
                    }
                    // If IN_PROGRESS or IN_QUEUE, keep polling

                } catch (error) {
                    console.error('Polling error:', error);
                }
            }, 2000); // Poll every 2 seconds
        }

        // Modify Modal Functions
        function openModifyModal(sceneId) {
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            const scene = state.script.scenes.find(s => s.id === sceneId);

            state.storyboard.modifyingScene = sceneId;
            state.storyboard.modifyPrompt = storyboardScene?.prompt || scene?.visual || '';
            state.storyboard.modifyStyle = state.content.style || 'cinematic';

            render();
        }

        function closeModifyModal() {
            state.storyboard.modifyingScene = null;
            state.storyboard.modifyPrompt = null;
            state.storyboard.modifyStyle = null;
            render();
        }

        function setModifyStyle(style) {
            state.storyboard.modifyStyle = style;
            render();
        }

        function appendToModifyPrompt(text) {
            const input = document.getElementById('modify-prompt-input');
            if (input) {
                const currentPrompt = input.value.trim();
                input.value = currentPrompt ? `${currentPrompt}, ${text}` : text;
                state.storyboard.modifyPrompt = input.value;
            }
        }

        async function applyModifyAndGenerate() {
            const sceneId = state.storyboard.modifyingScene;
            if (!sceneId) return;

            const input = document.getElementById('modify-prompt-input');
            const newPrompt = input?.value?.trim();

            if (!newPrompt || newPrompt.length < 10) {
                showToast('Please enter a more detailed prompt', 'warning');
                return;
            }

            // Update the scene's visual description
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.visual = newPrompt;
            }

            // Update storyboard scene
            let storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (storyboardScene) {
                storyboardScene.prompt = newPrompt;
            }

            closeModifyModal();

            // Generate with new prompt
            await generateSingleSceneImage(sceneId);
        }

        // ==========================================
        // 6.8.5 STOCK MEDIA BROWSER (Enhanced with VIDEO + Trim)
        // ==========================================
        let stockBrowserState = {
            isOpen: false,
            targetSceneId: null,
            mediaType: 'image', // 'image' | 'video'
            activeTab: 'images', // 'images' | 'videos'
            query: '',
            suggestedQuery: '', // Primary AI suggestion
            alternativeQueries: [], // Additional AI suggestions
            suggestedCategory: '', // AI-suggested category
            loadingAiSuggestions: false, // Loading state for AI suggestions
            results: [],
            videoResults: [], // Separate storage for video results
            loading: false,
            page: 1,
            total: 0,
            // Video trim state
            selectedVideo: null,  // Selected video for preview/trim
            trimStart: 0,         // Trim start time in seconds
            trimEnd: null,        // Trim end time (null = full duration)
            videoDuration: 0,     // Total video duration
            isPreviewPlaying: false
        };

        async function openStockBrowser(sceneId, mediaType = 'image') {
            stockBrowserState.isOpen = true;
            stockBrowserState.targetSceneId = sceneId;
            stockBrowserState.mediaType = mediaType;
            stockBrowserState.activeTab = mediaType === 'video' ? 'videos' : 'images';
            stockBrowserState.results = [];
            stockBrowserState.videoResults = [];
            stockBrowserState.query = '';
            stockBrowserState.page = 1;
            stockBrowserState.selectedVideo = null;
            stockBrowserState.trimStart = 0;
            stockBrowserState.trimEnd = null;
            stockBrowserState.alternativeQueries = [];
            stockBrowserState.suggestedCategory = '';
            stockBrowserState.loadingAiSuggestions = true;

            // Get scene for smart suggestions
            const scene = state.script.scenes.find(s => s.id === sceneId);

            // Use basic extraction as initial placeholder
            if (scene) {
                const basicQuery = extractSmartKeywords(scene);
                stockBrowserState.query = basicQuery;
                stockBrowserState.suggestedQuery = basicQuery;
            } else {
                stockBrowserState.query = 'cinematic background';
                stockBrowserState.suggestedQuery = '';
            }

            renderStockBrowserModal();

            // Start initial search with basic query
            if (stockBrowserState.query) {
                searchStockMedia(stockBrowserState.query);
            }

            // Simultaneously fetch AI-powered smart suggestions
            if (scene) {
                try {
                    const generateQueriesFn = functions.httpsCallable('generateSmartStockQueries');
                    const result = await generateQueriesFn({
                        sceneDescription: scene.visual || '',
                        narration: scene.narration || '',
                        mediaType: stockBrowserState.activeTab === 'videos' ? 'video' : 'image'
                    });

                    if (result.data.success) {
                        stockBrowserState.suggestedQuery = result.data.primaryQuery;
                        stockBrowserState.alternativeQueries = result.data.queries.slice(1) || [];
                        stockBrowserState.suggestedCategory = result.data.category || '';
                        stockBrowserState.loadingAiSuggestions = false;

                        // Update the search input with AI suggestion
                        const searchInput = document.getElementById('stock-search-input');
                        if (searchInput && stockBrowserState.query !== result.data.primaryQuery) {
                            searchInput.value = result.data.primaryQuery;
                            stockBrowserState.query = result.data.primaryQuery;
                        }

                        // Re-render to show AI suggestions
                        updateStockSuggestionsUI();

                        // Re-search with AI query if different from basic
                        if (result.data.primaryQuery && result.data.primaryQuery !== extractSmartKeywords(scene)) {
                            searchStockMedia(result.data.primaryQuery);
                        }
                    }
                } catch (error) {
                    console.error('AI suggestions error:', error);
                    stockBrowserState.loadingAiSuggestions = false;
                    updateStockSuggestionsUI();
                }
            } else {
                stockBrowserState.loadingAiSuggestions = false;
            }
        }

        // Update just the suggestions UI without re-rendering entire modal
        function updateStockSuggestionsUI() {
            const suggestionsArea = document.getElementById('stock-ai-suggestions');
            if (!suggestionsArea) return;

            let suggestionsHtml = '';

            if (stockBrowserState.loadingAiSuggestions) {
                suggestionsHtml = `
                    <div style="padding: 0.5rem 1.25rem; background: rgba(139, 92, 246, 0.1); border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; gap: 0.5rem;">
                        <span class="animate-spin" style="width: 14px; height: 14px; border: 2px solid rgba(139,92,246,0.3); border-top-color: #a78bfa; border-radius: 50%;"></span>
                        <span style="color: #a78bfa; font-size: 0.75rem;">AI analyzing your scene...</span>
                    </div>
                `;
            } else if (stockBrowserState.suggestedQuery) {
                suggestionsHtml = `
                    <div style="padding: 0.6rem 1.25rem; background: rgba(139, 92, 246, 0.1); border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                            <span style="color: #a78bfa; font-size: 0.7rem;"> AI Smart Suggestions:</span>
                            ${stockBrowserState.suggestedCategory ? `<span style="background: rgba(139,92,246,0.3); color: #c4b5fd; padding: 0.1rem 0.4rem; border-radius: 1rem; font-size: 0.6rem;">${stockBrowserState.suggestedCategory}</span>` : ''}
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.4rem;">
                            <button onclick="applyStockSuggestion('${stockBrowserState.suggestedQuery.replace(/'/g, "\\'")}')"
                                    style="padding: 0.3rem 0.6rem; background: linear-gradient(135deg, rgba(139,92,246,0.4), rgba(236,72,153,0.3)); border: 1px solid rgba(139,92,246,0.5); border-radius: 1rem; color: white; cursor: pointer; font-size: 0.75rem; font-weight: 500;">
                                 ${stockBrowserState.suggestedQuery}
                            </button>
                            ${stockBrowserState.alternativeQueries.map(q => `
                                <button onclick="applyStockSuggestion('${q.replace(/'/g, "\\'")}')"
                                        style="padding: 0.3rem 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 1rem; color: rgba(255,255,255,0.8); cursor: pointer; font-size: 0.7rem;">
                                    ${q}
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            suggestionsArea.innerHTML = suggestionsHtml;
        }

        // Apply a suggestion to search
        function applyStockSuggestion(query) {
            stockBrowserState.query = query;
            const searchInput = document.getElementById('stock-search-input');
            if (searchInput) searchInput.value = query;
            searchStockMedia(query);
        }

        // Extract smart keywords from scene description for stock search
        function extractSmartKeywords(scene) {
            const visual = scene.visual || '';
            const narration = scene.narration || '';
            const combined = `${visual} ${narration}`.toLowerCase();

            // Remove common words and extract key nouns/adjectives
            const stopWords = ['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
                              'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
                              'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'dare',
                              'ought', 'used', 'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by',
                              'from', 'up', 'about', 'into', 'over', 'after', 'beneath', 'under',
                              'above', 'show', 'showing', 'shows', 'scene', 'image', 'video', 'clip'];

            // Extract words
            const words = combined
                .replace(/[^a-z\s]/g, '') // Remove non-letters
                .split(/\s+/)
                .filter(word => word.length > 2 && !stopWords.includes(word));

            // Prioritize descriptive words (colors, emotions, objects)
            const priorityWords = [];
            const visualKeywords = ['sunset', 'sunrise', 'ocean', 'mountain', 'forest', 'city',
                                   'beach', 'sky', 'cloud', 'rain', 'snow', 'fire', 'water',
                                   'office', 'business', 'technology', 'nature', 'people', 'team',
                                   'happy', 'sad', 'excited', 'calm', 'peaceful', 'dramatic',
                                   'bright', 'dark', 'colorful', 'minimal', 'modern', 'vintage',
                                   'aerial', 'closeup', 'portrait', 'landscape', 'abstract'];

            words.forEach(word => {
                if (visualKeywords.includes(word)) {
                    priorityWords.unshift(word);
                } else if (priorityWords.length < 3) {
                    priorityWords.push(word);
                }
            });

            // Return top 2-3 keywords
            const result = [...new Set(priorityWords)].slice(0, 3).join(' ');
            return result || 'cinematic background';
        }

        function closeStockBrowser() {
            stockBrowserState.isOpen = false;
            stockBrowserState.targetSceneId = null;
            const modal = document.getElementById('stock-browser-modal');
            if (modal) modal.remove();
        }

        async function searchStockMedia(query = stockBrowserState.query, page = 1) {
            if (!query || query.length < 2) {
                showToast('Please enter a search term', 'warning');
                return;
            }

            stockBrowserState.loading = true;
            stockBrowserState.query = query;
            stockBrowserState.page = page;
            renderStockBrowserModal();

            try {
                const searchFn = firebase.functions().httpsCallable('searchStockMedia');
                const result = await searchFn({
                    query: query,
                    type: stockBrowserState.mediaType,
                    source: 'all',
                    filters: {
                        orientation: state.platform.aspectRatio === '9:16' ? 'portrait' : 'landscape',
                        page: page,
                        perPage: 20
                    }
                });

                stockBrowserState.results = result.data.results || [];
                stockBrowserState.total = result.data.total || 0;
                stockBrowserState.loading = false;

            } catch (error) {
                console.error('Stock search error:', error);
                showToast('Failed to search stock media', 'error');
                stockBrowserState.loading = false;
            }

            renderStockBrowserModal();
        }

        async function selectStockMedia(media) {
            if (!stockBrowserState.targetSceneId) return;

            const sceneId = stockBrowserState.targetSceneId;
            showToast('Importing media...', 'info');

            try {
                // Import to Firebase Storage
                const importFn = firebase.functions().httpsCallable('importStockMedia');
                const result = await importFn({
                    mediaId: media.id,
                    url: media.url,
                    type: media.type,
                    projectId: state.project.id
                });

                if (result.data.success) {
                    // Update storyboard scene
                    let storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                    if (!storyboardScene) {
                        storyboardScene = {
                            sceneId: sceneId,
                            status: 'pending',
                            imageUrl: null,
                            prompt: '',
                            jobId: null,
                            source: 'stock'
                        };
                        state.storyboard.scenes.push(storyboardScene);
                    }

                    storyboardScene.imageUrl = result.data.url;
                    storyboardScene.status = 'ready';
                    storyboardScene.source = 'stock';
                    storyboardScene.stockInfo = {
                        id: media.id,
                        source: media.source,
                        author: media.author,
                        license: media.license
                    };

                    closeStockBrowser();
                    showToast('Stock image added!', 'success');
                    scheduleAutoSave();
                    render();
                }
            } catch (error) {
                console.error('Import error:', error);
                showToast('Failed to import media', 'error');
            }
        }

        // Switch between Images and Videos tabs
        async function switchStockTab(tab) {
            stockBrowserState.activeTab = tab;
            stockBrowserState.selectedVideo = null;
            stockBrowserState.trimStart = 0;
            stockBrowserState.trimEnd = null;

            // Search with current query for new media type
            const mediaType = tab === 'videos' ? 'video' : 'image';
            const needsNewSuggestions = stockBrowserState.mediaType !== mediaType;
            stockBrowserState.mediaType = mediaType;

            if (stockBrowserState.query) {
                searchStockMedia(stockBrowserState.query);
            } else {
                renderStockBrowserModal();
            }

            // Regenerate AI suggestions for new media type
            if (needsNewSuggestions && stockBrowserState.targetSceneId) {
                const scene = state.script.scenes.find(s => s.id === stockBrowserState.targetSceneId);
                if (scene) {
                    stockBrowserState.loadingAiSuggestions = true;
                    updateStockSuggestionsUI();

                    try {
                        const generateQueriesFn = functions.httpsCallable('generateSmartStockQueries');
                        const result = await generateQueriesFn({
                            sceneDescription: scene.visual || '',
                            narration: scene.narration || '',
                            mediaType: mediaType
                        });

                        if (result.data.success) {
                            stockBrowserState.suggestedQuery = result.data.primaryQuery;
                            stockBrowserState.alternativeQueries = result.data.queries.slice(1) || [];
                            stockBrowserState.suggestedCategory = result.data.category || '';
                        }
                    } catch (error) {
                        console.error('AI suggestions error on tab switch:', error);
                    }
                    stockBrowserState.loadingAiSuggestions = false;
                    updateStockSuggestionsUI();
                }
            }
        }

        // Preview a stock video for trimming
        function previewStockVideo(media) {
            stockBrowserState.selectedVideo = media;
            stockBrowserState.trimStart = 0;
            stockBrowserState.trimEnd = null;
            stockBrowserState.videoDuration = media.duration || 30;
            renderStockBrowserModal();
        }

        // Update trim values from timeline
        function updateStockVideoTrim(handle, percent) {
            const duration = stockBrowserState.videoDuration || 30;
            const time = (percent / 100) * duration;

            if (handle === 'start') {
                stockBrowserState.trimStart = Math.max(0, Math.min(time, (stockBrowserState.trimEnd || duration) - 3));
            } else {
                stockBrowserState.trimEnd = Math.min(duration, Math.max(time, stockBrowserState.trimStart + 3));
            }
            renderStockBrowserModal();
        }

        // Format duration for display
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Select stock video with trim settings
        async function selectStockVideoWithTrim() {
            if (!stockBrowserState.selectedVideo || !stockBrowserState.targetSceneId) return;

            const media = stockBrowserState.selectedVideo;
            const sceneId = stockBrowserState.targetSceneId;
            const trimStart = stockBrowserState.trimStart || 0;
            const trimEnd = stockBrowserState.trimEnd || stockBrowserState.videoDuration;

            // Store thumbnail from search results (Pexels/Pixabay allow hotlinking thumbnails)
            const thumbnailUrl = media.thumbnail || media.preview || media.image;

            showToast('Importing video...', 'info');

            try {
                const importFn = firebase.functions().httpsCallable('importStockMedia');
                const result = await importFn({
                    mediaId: media.id,
                    url: media.videoUrl || media.url,
                    type: 'video',
                    projectId: state.project.id,
                    thumbnailUrl: thumbnailUrl, // Pass thumbnail for reference
                    trimStart: trimStart,
                    trimEnd: trimEnd,
                    originalDuration: media.duration || stockBrowserState.videoDuration
                });

                if (result.data.success) {
                    let storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                    if (!storyboardScene) {
                        storyboardScene = {
                            sceneId: sceneId,
                            status: 'pending',
                            imageUrl: null,
                            prompt: '',
                            jobId: null,
                            source: 'stock'
                        };
                        state.storyboard.scenes.push(storyboardScene);
                    }

                    // Use thumbnail from search results for preview (not the video URL)
                    storyboardScene.imageUrl = thumbnailUrl;
                    storyboardScene.videoUrl = result.data.url;
                    storyboardScene.status = 'ready';
                    storyboardScene.source = 'stock-video';
                    storyboardScene.stockInfo = {
                        id: media.id,
                        source: media.source,
                        author: media.author,
                        license: media.license,
                        thumbnailUrl: thumbnailUrl,
                        thumbnailFallback: media.thumbnailFallback || media.preview || null,
                        trimStart: trimStart,
                        trimEnd: trimEnd,
                        originalDuration: media.duration || stockBrowserState.videoDuration,
                        clipDuration: trimEnd - trimStart
                    };

                    closeStockBrowser();
                    showToast(`Video clip added! (${formatDuration(trimEnd - trimStart)})`, 'success');
                    scheduleAutoSave();
                    render();
                }
            } catch (error) {
                console.error('Video import error:', error);
                showToast('Failed to import video', 'error');
            }
        }

        function renderStockBrowserModal() {
            // Remove existing modal
            const existing = document.getElementById('stock-browser-modal');
            if (existing) existing.remove();

            if (!stockBrowserState.isOpen) return;

            const isVideoTab = stockBrowserState.activeTab === 'videos';
            const hasVideoSelected = stockBrowserState.selectedVideo !== null;
            const trimStart = stockBrowserState.trimStart || 0;
            const trimEnd = stockBrowserState.trimEnd || stockBrowserState.videoDuration || 30;
            const duration = stockBrowserState.videoDuration || 30;
            const startPercent = (trimStart / duration) * 100;
            const endPercent = (trimEnd / duration) * 100;

            const modal = document.createElement('div');
            modal.id = 'stock-browser-modal';
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 1001; padding: 1rem;" onclick="if(event.target === this) closeStockBrowser()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 950px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div style="padding: 1rem 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h3 style="margin: 0; color: white; font-size: 1.1rem; font-weight: 600;"> Stock Media Browser</h3>
                                <p style="margin: 0.25rem 0 0 0; color: rgba(255,255,255,0.6); font-size: 0.8rem;">Free royalty-free media from Pexels & Pixabay</p>
                            </div>
                            <button onclick="closeStockBrowser()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Tab Switcher -->
                        <div style="display: flex; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <button onclick="switchStockTab('images')"
                                    style="flex: 1; padding: 0.75rem; background: ${!isVideoTab ? 'rgba(139, 92, 246, 0.2)' : 'transparent'}; border: none; border-bottom: ${!isVideoTab ? '2px solid #8b5cf6' : '2px solid transparent'}; color: ${!isVideoTab ? 'white' : 'rgba(255,255,255,0.6)'}; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                                 Images
                            </button>
                            <button onclick="switchStockTab('videos')"
                                    style="flex: 1; padding: 0.75rem; background: ${isVideoTab ? 'rgba(16, 185, 129, 0.2)' : 'transparent'}; border: none; border-bottom: ${isVideoTab ? '2px solid #10b981' : '2px solid transparent'}; color: ${isVideoTab ? 'white' : 'rgba(255,255,255,0.6)'}; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                                 Videos
                            </button>
                        </div>

                        <!-- AI Smart Suggestions Container -->
                        <div id="stock-ai-suggestions">
                            ${stockBrowserState.loadingAiSuggestions ? `
                                <div style="padding: 0.5rem 1.25rem; background: rgba(139, 92, 246, 0.1); border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; gap: 0.5rem;">
                                    <span class="animate-spin" style="width: 14px; height: 14px; border: 2px solid rgba(139,92,246,0.3); border-top-color: #a78bfa; border-radius: 50%;"></span>
                                    <span style="color: #a78bfa; font-size: 0.75rem;">AI analyzing your scene...</span>
                                </div>
                            ` : stockBrowserState.suggestedQuery ? `
                                <div style="padding: 0.6rem 1.25rem; background: rgba(139, 92, 246, 0.1); border-bottom: 1px solid rgba(255,255,255,0.1);">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <span style="color: #a78bfa; font-size: 0.7rem;"> AI Smart Suggestions:</span>
                                        ${stockBrowserState.suggestedCategory ? `<span style="background: rgba(139,92,246,0.3); color: #c4b5fd; padding: 0.1rem 0.4rem; border-radius: 1rem; font-size: 0.6rem;">${stockBrowserState.suggestedCategory}</span>` : ''}
                                    </div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 0.4rem;">
                                        <button onclick="applyStockSuggestion('${stockBrowserState.suggestedQuery.replace(/'/g, "\\'")}')"
                                                style="padding: 0.3rem 0.6rem; background: linear-gradient(135deg, rgba(139,92,246,0.4), rgba(236,72,153,0.3)); border: 1px solid rgba(139,92,246,0.5); border-radius: 1rem; color: white; cursor: pointer; font-size: 0.75rem; font-weight: 500;">
                                             ${stockBrowserState.suggestedQuery}
                                        </button>
                                        ${(stockBrowserState.alternativeQueries || []).map(q => `
                                            <button onclick="applyStockSuggestion('${q.replace(/'/g, "\\'")}')"
                                                    style="padding: 0.3rem 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 1rem; color: rgba(255,255,255,0.8); cursor: pointer; font-size: 0.7rem;">
                                                ${q}
                                            </button>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Search Bar -->
                        <div style="padding: 1rem 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <div style="display: flex; gap: 0.5rem;">
                                <input type="text"
                                       id="stock-search-input"
                                       value="${stockBrowserState.query}"
                                       placeholder="Search for ${isVideoTab ? 'videos' : 'images'}..."
                                       style="flex: 1; padding: 0.75rem 1rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem;"
                                       onkeydown="if(event.key === 'Enter') searchStockMedia(this.value)">
                                <button onclick="searchStockMedia(document.getElementById('stock-search-input').value)"
                                        style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, ${isVideoTab ? '#10b981, #059669' : '#8b5cf6, #06b6d4'}); border: none; border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer;">
                                     Search
                                </button>
                            </div>
                            <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem; flex-wrap: wrap;">
                                ${['nature', 'business', 'technology', 'people', 'city', 'abstract', 'motion', 'aerial'].map(tag => `
                                    <button onclick="searchStockMedia('${tag}')"
                                            style="padding: 0.4rem 0.75rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 1rem; color: rgba(255,255,255,0.8); font-size: 0.75rem; cursor: pointer; transition: all 0.2s;"
                                            onmouseover="this.style.background='rgba(139,92,246,0.3)'"
                                            onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                                        ${tag}
                                    </button>
                                `).join('')}
                            </div>
                        </div>

                        ${isVideoTab && hasVideoSelected ? `
                            <!-- Video Preview & Trim Panel -->
                            <div style="padding: 1rem; background: rgba(0,0,0,0.3);">
                                <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                                    <!-- Video Preview -->
                                    <div style="flex: 1; min-width: 300px;">
                                        <video id="stock-video-preview"
                                               src="${stockBrowserState.selectedVideo.videoUrl || stockBrowserState.selectedVideo.url}"
                                               style="width: 100%; max-height: 200px; border-radius: 0.5rem; background: black;"
                                               controls
                                               muted></video>
                                    </div>

                                    <!-- Trim Controls -->
                                    <div style="flex: 1; min-width: 250px;">
                                        <div style="color: white; font-size: 0.85rem; font-weight: 600; margin-bottom: 0.75rem;"> Trim Video Clip</div>

                                        <!-- Timeline -->
                                        <div style="position: relative; height: 40px; background: rgba(255,255,255,0.1); border-radius: 0.5rem; margin-bottom: 0.75rem; cursor: pointer;"
                                             id="video-trim-timeline">
                                            <!-- Selected region -->
                                            <div style="position: absolute; top: 0; bottom: 0; left: ${startPercent}%; width: ${endPercent - startPercent}%; background: linear-gradient(135deg, rgba(16, 185, 129, 0.4), rgba(6, 182, 212, 0.4)); border-radius: 0.25rem;"></div>

                                            <!-- Start handle -->
                                            <div style="position: absolute; top: 0; bottom: 0; left: ${startPercent}%; width: 12px; background: #10b981; border-radius: 0.25rem; cursor: ew-resize; transform: translateX(-50%); display: flex; align-items: center; justify-content: center;"
                                                 class="trim-handle" data-handle="start">
                                                <div style="width: 2px; height: 60%; background: white; border-radius: 1px;"></div>
                                            </div>

                                            <!-- End handle -->
                                            <div style="position: absolute; top: 0; bottom: 0; left: ${endPercent}%; width: 12px; background: #10b981; border-radius: 0.25rem; cursor: ew-resize; transform: translateX(-50%); display: flex; align-items: center; justify-content: center;"
                                                 class="trim-handle" data-handle="end">
                                                <div style="width: 2px; height: 60%; background: white; border-radius: 1px;"></div>
                                            </div>
                                        </div>

                                        <!-- Time Display -->
                                        <div style="display: flex; justify-content: space-between; color: rgba(255,255,255,0.7); font-size: 0.75rem; margin-bottom: 0.75rem;">
                                            <span>Start: ${formatDuration(trimStart)}</span>
                                            <span style="color: #10b981; font-weight: 600;">Duration: ${formatDuration(trimEnd - trimStart)}</span>
                                            <span>End: ${formatDuration(trimEnd)}</span>
                                        </div>

                                        <!-- Action Buttons -->
                                        <div style="display: flex; gap: 0.5rem;">
                                            <button onclick="stockBrowserState.selectedVideo = null; renderStockBrowserModal();"
                                                    style="flex: 1; padding: 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; cursor: pointer;">
                                                 Back
                                            </button>
                                            <button onclick="selectStockVideoWithTrim()"
                                                    style="flex: 2; padding: 0.6rem; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer;">
                                                 Use This Clip
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ` : `
                            <!-- Results Grid -->
                            <div style="flex: 1; overflow-y: auto; padding: 1rem;">
                                ${stockBrowserState.loading ? `
                                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 3rem;">
                                        <div style="width: 40px; height: 40px; border: 3px solid rgba(139, 92, 246, 0.2); border-top-color: #8b5cf6; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                        <p style="color: rgba(255,255,255,0.6); margin-top: 1rem;">Searching ${isVideoTab ? 'videos' : 'images'}...</p>
                                    </div>
                                ` : stockBrowserState.results.length === 0 ? `
                                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 3rem; text-align: center;">
                                        <div style="font-size: 3rem; margin-bottom: 1rem;">${isVideoTab ? '' : ''}</div>
                                        <p style="color: rgba(255,255,255,0.6);">Search for stock ${isVideoTab ? 'videos' : 'images'} above</p>
                                        <p style="color: rgba(255,255,255,0.4); font-size: 0.85rem;">Try keywords like "nature", "business", or "technology"</p>
                                    </div>
                                ` : `
                                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(${isVideoTab ? '200px' : '180px'}, 1fr)); gap: 0.75rem;">
                                        ${stockBrowserState.results.map(media => isVideoTab ? `
                                            <!-- Video Card -->
                                            <div onclick="previewStockVideo(${JSON.stringify(media).replace(/"/g, '&quot;')})"
                                                 style="position: relative; aspect-ratio: 16/9; border-radius: 0.5rem; overflow: hidden; cursor: pointer; border: 2px solid transparent; transition: all 0.2s;"
                                                 onmouseover="this.style.borderColor='#10b981'; this.style.transform='scale(1.02)'"
                                                 onmouseout="this.style.borderColor='transparent'; this.style.transform='scale(1)'">
                                                <img src="${media.thumbnail || media.preview}"
                                                     alt=""
                                                     style="width: 100%; height: 100%; object-fit: cover;">
                                                <!-- Play icon overlay -->
                                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; background: rgba(0,0,0,0.7); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                                    <div style="width: 0; height: 0; border-left: 12px solid white; border-top: 8px solid transparent; border-bottom: 8px solid transparent; margin-left: 3px;"></div>
                                                </div>
                                                <!-- Duration badge -->
                                                <div style="position: absolute; bottom: 0.5rem; right: 0.5rem; background: rgba(0,0,0,0.8); color: white; padding: 0.2rem 0.4rem; border-radius: 0.25rem; font-size: 0.7rem;">
                                                    ${formatDuration(media.duration || 30)}
                                                </div>
                                                <!-- Source badge -->
                                                <div style="position: absolute; bottom: 0.5rem; left: 0.5rem; background: rgba(0,0,0,0.8); color: rgba(255,255,255,0.8); padding: 0.15rem 0.35rem; border-radius: 0.25rem; font-size: 0.6rem;">
                                                    ${media.source === 'pexels' ? ' Pexels' : ' Pixabay'}
                                                </div>
                                            </div>
                                        ` : `
                                            <!-- Image Card -->
                                            <div onclick="selectStockMedia(${JSON.stringify(media).replace(/"/g, '&quot;')})"
                                                 style="position: relative; aspect-ratio: ${state.platform.aspectRatio === '9:16' ? '9/16' : '16/9'}; border-radius: 0.5rem; overflow: hidden; cursor: pointer; border: 2px solid transparent; transition: all 0.2s;"
                                                 onmouseover="this.style.borderColor='#8b5cf6'; this.style.transform='scale(1.02)'"
                                                 onmouseout="this.style.borderColor='transparent'; this.style.transform='scale(1)'">
                                                <img src="${media.thumbnail || media.preview}"
                                                     alt=""
                                                     style="width: 100%; height: 100%; object-fit: cover;">
                                                <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 0.5rem; background: linear-gradient(transparent, rgba(0,0,0,0.8));">
                                                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.8);">
                                                        ${media.source === 'pexels' ? ' Pexels' : ' Pixabay'}
                                                    </div>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                    ${stockBrowserState.total > 20 ? `
                                        <div style="display: flex; justify-content: center; gap: 0.5rem; margin-top: 1rem;">
                                            ${stockBrowserState.page > 1 ? `
                                                <button onclick="searchStockMedia(stockBrowserState.query, ${stockBrowserState.page - 1})"
                                                        style="padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; cursor: pointer;">
                                                     Previous
                                                </button>
                                            ` : ''}
                                            <span style="padding: 0.5rem 1rem; color: rgba(255,255,255,0.6);">
                                                Page ${stockBrowserState.page}
                                            </span>
                                            <button onclick="searchStockMedia(stockBrowserState.query, ${stockBrowserState.page + 1})"
                                                    style="padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; cursor: pointer;">
                                                Next 
                                            </button>
                                        </div>
                                    ` : ''}
                                `}
                            </div>
                        `}

                        <!-- Footer -->
                        <div style="padding: 0.75rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.75rem;">
                                ${stockBrowserState.total > 0 ? `${stockBrowserState.total.toLocaleString()} ${isVideoTab ? 'videos' : 'images'} found` : ''}
                            </div>
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">
                                 Stock media is free and doesn't use tokens
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Setup trim handle dragging for videos
            if (isVideoTab && hasVideoSelected) {
                setupTrimHandles();
            }

            // Focus search input
            setTimeout(() => {
                const input = document.getElementById('stock-search-input');
                if (input && !hasVideoSelected) input.focus();
            }, 100);
        }

        // Setup drag handlers for video trim timeline
        function setupTrimHandles() {
            const timeline = document.getElementById('video-trim-timeline');
            if (!timeline) return;

            let isDragging = null;

            timeline.addEventListener('mousedown', (e) => {
                const handle = e.target.closest('.trim-handle');
                if (handle) {
                    isDragging = handle.dataset.handle;
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const timeline = document.getElementById('video-trim-timeline');
                if (!timeline) return;

                const rect = timeline.getBoundingClientRect();
                const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));

                updateStockVideoTrim(isDragging, percent);
            });

            document.addEventListener('mouseup', () => {
                isDragging = null;
            });
        }

        // ==========================================
        // 6.8.6 EDIT WITH AI MODAL
        // ==========================================

        // Open the AI edit modal for a scene image
        function openEditModal(sceneId) {
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene || !storyboardScene.imageUrl) {
                showToast('No image to edit', 'warning');
                return;
            }

            state.storyboard.editingScene = sceneId;
            state.storyboard.editPrompt = '';
            state.storyboard.editLoading = false;
            state.storyboard.editHistory = [];
            state.storyboard.editMaskCanvas = null;
            state.storyboard.editMaskCtx = null;

            renderEditModal();
        }

        // Close the edit modal
        function closeEditModal() {
            state.storyboard.editingScene = null;
            state.storyboard.editPrompt = '';
            state.storyboard.editLoading = false;
            const modal = document.getElementById('edit-ai-modal');
            if (modal) modal.remove();
        }

        // Initialize the canvas for mask painting
        function initEditCanvas() {
            const sceneId = state.storyboard.editingScene;
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene || !storyboardScene.imageUrl) return;

            const canvas = document.getElementById('edit-canvas');
            if (!canvas) {
                setTimeout(initEditCanvas, 100);
                return;
            }

            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = function() {
                // Set canvas size - maintain aspect ratio, max width 600px
                const maxWidth = 600;
                const scale = Math.min(1, maxWidth / img.width);
                canvas.width = Math.floor(img.width * scale);
                canvas.height = Math.floor(img.height * scale);

                // Store original dimensions
                canvas.dataset.originalWidth = img.width;
                canvas.dataset.originalHeight = img.height;

                // Draw the image
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                // Store original image data
                state.storyboard.editOriginalData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Create mask canvas
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = canvas.width;
                maskCanvas.height = canvas.height;
                state.storyboard.editMaskCanvas = maskCanvas;
                state.storyboard.editMaskCtx = maskCanvas.getContext('2d');

                // Fill with black (unmasked)
                state.storyboard.editMaskCtx.fillStyle = 'black';
                state.storyboard.editMaskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);

                canvas.style.cursor = 'crosshair';
                setupEditCanvasEvents(canvas);
            };

            img.onerror = function() {
                console.error('Failed to load image for editing');
                showToast('Failed to load image', 'error');
            };

            img.src = storyboardScene.imageUrl;
        }

        // Setup mouse/touch events for canvas painting
        function setupEditCanvasEvents(canvas) {
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            const getCoords = (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            const startDraw = (e) => {
                isDrawing = true;
                const coords = getCoords(e);
                lastX = coords.x;
                lastY = coords.y;
                paintEditMask(lastX, lastY);
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const coords = getCoords(e);
                paintEditMaskLine(lastX, lastY, coords.x, coords.y);
                lastX = coords.x;
                lastY = coords.y;
            };

            const endDraw = () => {
                isDrawing = false;
            };

            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDraw);
            canvas.addEventListener('mouseleave', endDraw);

            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDraw(e); });
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); });
            canvas.addEventListener('touchend', endDraw);
        }

        // Paint a single point on the mask
        function paintEditMask(x, y) {
            if (!state.storyboard.editMaskCtx) return;

            const brushSize = state.storyboard.editBrushSize || 30;
            state.storyboard.editMaskCtx.fillStyle = 'white';
            state.storyboard.editMaskCtx.beginPath();
            state.storyboard.editMaskCtx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
            state.storyboard.editMaskCtx.fill();

            redrawEditCanvas();
        }

        // Paint a line on the mask
        function paintEditMaskLine(x1, y1, x2, y2) {
            if (!state.storyboard.editMaskCtx) return;

            const brushSize = state.storyboard.editBrushSize || 30;
            state.storyboard.editMaskCtx.strokeStyle = 'white';
            state.storyboard.editMaskCtx.lineWidth = brushSize;
            state.storyboard.editMaskCtx.lineCap = 'round';
            state.storyboard.editMaskCtx.lineJoin = 'round';
            state.storyboard.editMaskCtx.beginPath();
            state.storyboard.editMaskCtx.moveTo(x1, y1);
            state.storyboard.editMaskCtx.lineTo(x2, y2);
            state.storyboard.editMaskCtx.stroke();

            redrawEditCanvas();
        }

        // Redraw the canvas with mask overlay
        function redrawEditCanvas() {
            const canvas = document.getElementById('edit-canvas');
            if (!canvas || !state.storyboard.editOriginalData) return;

            const ctx = canvas.getContext('2d');

            // Draw original image
            const imgCanvas = document.createElement('canvas');
            imgCanvas.width = canvas.width;
            imgCanvas.height = canvas.height;
            imgCanvas.getContext('2d').putImageData(state.storyboard.editOriginalData, 0, 0);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(imgCanvas, 0, 0);

            // Draw pink overlay where mask is white
            if (state.storyboard.editMaskCanvas) {
                const maskCtx = state.storyboard.editMaskCtx;
                const maskData = maskCtx.getImageData(0, 0, state.storyboard.editMaskCanvas.width, state.storyboard.editMaskCanvas.height);

                const overlayCanvas = document.createElement('canvas');
                overlayCanvas.width = canvas.width;
                overlayCanvas.height = canvas.height;
                const overlayCtx = overlayCanvas.getContext('2d');
                overlayCtx.drawImage(state.storyboard.editMaskCanvas, 0, 0);

                const overlayData = overlayCtx.getImageData(0, 0, overlayCanvas.width, overlayCanvas.height);
                for (let i = 0; i < overlayData.data.length; i += 4) {
                    if (overlayData.data[i] > 128) {
                        overlayData.data[i] = 236;     // R - pink
                        overlayData.data[i + 1] = 72;  // G
                        overlayData.data[i + 2] = 153; // B
                        overlayData.data[i + 3] = 150; // A - semi-transparent
                    } else {
                        overlayData.data[i + 3] = 0;   // Transparent
                    }
                }
                overlayCtx.putImageData(overlayData, 0, 0);
                ctx.drawImage(overlayCanvas, 0, 0);
            }
        }

        // Get mask as base64 PNG
        function getEditMaskBase64() {
            if (!state.storyboard.editMaskCanvas) return null;

            const canvas = document.getElementById('edit-canvas');
            const originalWidth = parseInt(canvas.dataset.originalWidth) || 1280;
            const originalHeight = parseInt(canvas.dataset.originalHeight) || 720;

            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = originalWidth;
            exportCanvas.height = originalHeight;
            const ctx = exportCanvas.getContext('2d');

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            ctx.drawImage(state.storyboard.editMaskCanvas, 0, 0, exportCanvas.width, exportCanvas.height);

            // Check if mask has any white pixels
            const imageData = ctx.getImageData(0, 0, exportCanvas.width, exportCanvas.height);
            let hasWhite = false;
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i] > 200) {
                    hasWhite = true;
                    break;
                }
            }

            if (!hasWhite) return null;
            return exportCanvas.toDataURL('image/png').split(',')[1];
        }

        // Set brush size
        function setEditBrushSize(size) {
            state.storyboard.editBrushSize = parseInt(size) || 30;
        }

        // Clear the mask
        function clearEditMask() {
            if (!state.storyboard.editMaskCtx) return;

            state.storyboard.editMaskCtx.fillStyle = 'black';
            state.storyboard.editMaskCtx.fillRect(0, 0, state.storyboard.editMaskCanvas.width, state.storyboard.editMaskCanvas.height);
            redrawEditCanvas();
        }

        // Set edit prompt
        function setEditPrompt(value) {
            state.storyboard.editPrompt = value;
        }

        // Apply the AI edit
        async function applyAIEdit() {
            const sceneId = state.storyboard.editingScene;
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene || !storyboardScene.imageUrl) return;

            const maskBase64 = getEditMaskBase64();
            let editPrompt = state.storyboard.editPrompt.trim();

            if (!editPrompt && !maskBase64) {
                showToast('Please enter what you want to change, or paint an area', 'warning');
                return;
            }

            if (!editPrompt && maskBase64) {
                editPrompt = 'Remove the marked area seamlessly';
            }

            state.storyboard.editLoading = true;
            renderEditModal();

            try {
                const editFn = firebase.functions().httpsCallable('editThumbnailWithAI');
                const requestData = {
                    imageUrl: storyboardScene.imageUrl,
                    editPrompt: editPrompt
                };

                if (maskBase64) {
                    requestData.maskBase64 = maskBase64;
                }

                const result = await editFn(requestData);

                if (result.data.success && result.data.editedUrl) {
                    // Update scene with edited image
                    storyboardScene.imageUrl = result.data.editedUrl;
                    storyboardScene.editHistory = storyboardScene.editHistory || [];
                    storyboardScene.editHistory.push({
                        prompt: editPrompt,
                        timestamp: Date.now()
                    });

                    closeEditModal();
                    showToast('Image edited successfully!', 'success');
                    scheduleAutoSave();
                    render();
                } else {
                    throw new Error(result.data.message || 'Edit failed');
                }
            } catch (error) {
                console.error('AI edit error:', error);
                state.storyboard.editLoading = false;
                showToast(`Edit failed: ${error.message}`, 'error');
                renderEditModal();
            }
        }

        // Render the Edit with AI modal
        function renderEditModal() {
            const existing = document.getElementById('edit-ai-modal');
            if (existing) existing.remove();

            if (!state.storyboard.editingScene) return;

            const sceneId = state.storyboard.editingScene;
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            const scene = state.script.scenes.find(s => s.id === sceneId);
            const sceneIndex = state.script.scenes.findIndex(s => s.id === sceneId);

            if (!storyboardScene || !storyboardScene.imageUrl) return;

            const modal = document.createElement('div');
            modal.id = 'edit-ai-modal';
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 1002; padding: 1rem;" onclick="if(event.target === this) closeEditModal()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 700px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div style="padding: 1rem 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h3 style="margin: 0; color: white; font-size: 1.1rem; font-weight: 600;"> Edit Scene ${sceneIndex + 1} with AI</h3>
                                <p style="margin: 0.25rem 0 0 0; color: rgba(255,255,255,0.6); font-size: 0.8rem;">Paint to select areas, describe your edit</p>
                            </div>
                            <button onclick="closeEditModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Canvas Area -->
                        <div style="flex: 1; overflow-y: auto; padding: 1rem;">
                            ${state.storyboard.editLoading ? `
                                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 3rem;">
                                    <div style="width: 50px; height: 50px; border: 3px solid rgba(236, 72, 153, 0.2); border-top-color: #ec4899; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                    <p style="color: rgba(255,255,255,0.8); margin-top: 1rem; font-weight: 500;">AI is editing your image...</p>
                                    <p style="color: rgba(255,255,255,0.5); font-size: 0.8rem; margin-top: 0.5rem;">This may take 10-30 seconds</p>
                                </div>
                            ` : `
                                <!-- Canvas -->
                                <div style="display: flex; justify-content: center; margin-bottom: 1rem;">
                                    <canvas id="edit-canvas" style="max-width: 100%; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.3);"></canvas>
                                </div>

                                <!-- Brush Controls -->
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="color: rgba(255,255,255,0.7); font-size: 0.8rem;"> Brush:</span>
                                        <input type="range" min="10" max="100" value="${state.storyboard.editBrushSize || 30}"
                                               oninput="setEditBrushSize(this.value); document.getElementById('brush-size-display').textContent = this.value + 'px'"
                                               style="width: 100px; accent-color: #ec4899;">
                                        <span id="brush-size-display" style="color: white; font-size: 0.75rem; width: 40px;">${state.storyboard.editBrushSize || 30}px</span>
                                    </div>
                                    <button onclick="clearEditMask()" style="padding: 0.4rem 0.75rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem; cursor: pointer;">
                                         Clear
                                    </button>
                                </div>

                                <p style="color: rgba(255,255,255,0.5); font-size: 0.75rem; text-align: center; margin-bottom: 1rem;">
                                     <strong>Optional:</strong> Paint to select specific areas, or skip to edit the entire image
                                </p>

                                <!-- Prompt Input -->
                                <div style="margin-bottom: 1rem;">
                                    <label style="color: rgba(255,255,255,0.7); font-size: 0.85rem; display: block; margin-bottom: 0.5rem;">What do you want to change?</label>
                                    <input type="text" id="edit-prompt-input" value="${state.storyboard.editPrompt || ''}"
                                           placeholder="e.g., Make the sky more dramatic, remove the person, add lens flare..."
                                           oninput="setEditPrompt(this.value)"
                                           style="width: 100%; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem;">
                                </div>

                                <!-- Quick Suggestions -->
                                <div style="display: flex; flex-wrap: wrap; gap: 0.4rem; margin-bottom: 1rem;">
                                    ${['Remove marked area', 'Make it brighter', 'Add dramatic lighting', 'Make colors more vibrant', 'Add film grain effect'].map(suggestion => `
                                        <button onclick="setEditPrompt('${suggestion}'); document.getElementById('edit-prompt-input').value = '${suggestion}';"
                                                style="padding: 0.35rem 0.6rem; background: rgba(236, 72, 153, 0.1); border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 1rem; color: #f9a8d4; font-size: 0.7rem; cursor: pointer; transition: all 0.2s;"
                                                onmouseover="this.style.background='rgba(236, 72, 153, 0.2)'"
                                                onmouseout="this.style.background='rgba(236, 72, 153, 0.1)'">
                                            ${suggestion}
                                        </button>
                                    `).join('')}
                                </div>
                            `}
                        </div>

                        <!-- Footer -->
                        <div style="padding: 1rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <button onclick="closeEditModal()"
                                    style="padding: 0.6rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.85rem; cursor: pointer;">
                                Cancel
                            </button>
                            <button onclick="applyAIEdit()" ${state.storyboard.editLoading ? 'disabled' : ''}
                                    style="padding: 0.6rem 1.5rem; background: linear-gradient(135deg, #ec4899, #8b5cf6); border: none; border-radius: 0.5rem; color: white; font-weight: 600; font-size: 0.85rem; cursor: pointer; opacity: ${state.storyboard.editLoading ? '0.5' : '1'};">
                                ${state.storyboard.editLoading ? 'Editing...' : ' Apply Edit (2 tokens)'}
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Initialize canvas after render
            if (!state.storyboard.editLoading) {
                setTimeout(initEditCanvas, 100);
            }
        }

        // ==========================================
        // 6.9 COST ESTIMATION
        // ==========================================
        function estimateCost() {
            const duration = state.platform.targetDuration || 60;
            const sceneDuration = 10; // Average scene duration
            const sceneCount = Math.ceil(duration / sceneDuration);

            // Base costs (in tokens)
            const costs = {
                scriptGeneration: 5,
                imagesPerScene: 2, // HD quality
                voiceoverPer30s: 1,
                animationPerScene: 3, // Runpod Multi-talk
                export: 3
            };

            const totalImages = sceneCount * costs.imagesPerScene;
            const voiceoverUnits = Math.ceil(duration / 30);
            const animationCost = sceneCount * costs.animationPerScene;

            const total = costs.scriptGeneration +
                         totalImages +
                         (voiceoverUnits * costs.voiceoverPer30s) +
                         animationCost +
                         costs.export;

            return {
                total,
                breakdown: {
                    script: costs.scriptGeneration,
                    images: totalImages,
                    voiceover: voiceoverUnits * costs.voiceoverPer30s,
                    animation: animationCost,
                    export: costs.export
                },
                sceneCount
            };
        }

        // ==========================================
        // 6.7 UTILITY FUNCTIONS
        // ==========================================
        function formatDuration(seconds) {
            // Round to avoid floating point precision issues
            const roundedSeconds = Math.round(seconds);
            if (roundedSeconds < 60) {
                return `${roundedSeconds}s`;
            }
            const minutes = Math.floor(roundedSeconds / 60);
            const secs = roundedSeconds % 60;
            return secs > 0 ? `${minutes}m ${secs}s` : `${minutes}m`;
        }

        function showToast(message, type = 'info') {
            // Simple toast implementation
            const toast = document.createElement('div');
            toast.className = `fixed bottom-4 right-4 px-4 py-3 rounded-lg text-white text-sm font-medium z-50 fade-in`;
            toast.style.background = type === 'warning' ? '#f59e0b' :
                                    type === 'error' ? '#ef4444' :
                                    type === 'success' ? '#10b981' : '#8b5cf6';
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ==========================================
        // 6.8 PROJECTS MODAL
        // ==========================================
        let projectsModalOpen = false;

        async function openProjectsModal() {
            projectsModalOpen = true;
            renderProjectsModal();

            // Load projects list
            const projects = await loadProjectsList();
            renderProjectsModal(projects);
        }

        function closeProjectsModal() {
            projectsModalOpen = false;
            const modal = document.getElementById('projects-modal');
            if (modal) modal.remove();
        }

        function renderProjectsModal(projects = null) {
            // Remove existing modal if any
            const existing = document.getElementById('projects-modal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.id = 'projects-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                padding: 1rem;
            `;

            let content = `
                <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 600px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
                    <div style="padding: 1.5rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                        <h2 style="color: white; font-size: 1.25rem; font-weight: 700;">My Video Projects</h2>
                        <button onclick="closeProjectsModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                    </div>
                    <div style="padding: 1rem; overflow-y: auto; flex: 1;">
            `;

            if (projects === null) {
                // Loading state
                content += `
                    <div style="text-align: center; padding: 3rem; color: rgba(255,255,255,0.6);">
                        <div class="animate-spin" style="width: 2rem; height: 2rem; border: 3px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%; margin: 0 auto 1rem;"></div>
                        Loading projects...
                    </div>
                `;
            } else if (projects.length === 0) {
                // Empty state
                content += `
                    <div style="text-align: center; padding: 3rem; color: rgba(255,255,255,0.6);">
                        <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                        <p>No projects yet</p>
                        <p style="font-size: 0.85rem; margin-top: 0.5rem;">Create your first video to see it here!</p>
                    </div>
                `;
            } else {
                // Projects list
                projects.forEach(project => {
                    const isCurrent = state.project.id === project.id;
                    const nicheIcon = project.niche ? VIDEO_NICHES[project.niche]?.icon || '' : '';
                    const updatedDate = project.updatedAt ? new Date(project.updatedAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : 'Unknown';

                    content += `
                        <div style="background: ${isCurrent ? 'rgba(139,92,246,0.2)' : 'rgba(255,255,255,0.05)'}; border: 1px solid ${isCurrent ? 'rgba(139,92,246,0.4)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.75rem; padding: 1rem; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 1rem;">
                            <div style="font-size: 1.5rem;">${nicheIcon}</div>
                            <div style="flex: 1; min-width: 0;">
                                <div style="color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${project.name || 'Untitled'}</div>
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.8rem;">${project.platform || 'No platform'}  ${project.sceneCount} scenes  ${updatedDate}</div>
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                ${isCurrent ? '<span style="color: #8b5cf6; font-size: 0.75rem; font-weight: 600;">CURRENT</span>' : `
                                    <button onclick="loadProjectFromModal('${project.id}')" style="background: rgba(139,92,246,0.2); border: 1px solid rgba(139,92,246,0.4); border-radius: 0.5rem; padding: 0.4rem 0.75rem; color: white; cursor: pointer; font-size: 0.75rem;">Open</button>
                                `}
                                <button onclick="deleteProjectFromModal('${project.id}')" style="background: rgba(239,68,68,0.2); border: 1px solid rgba(239,68,68,0.4); border-radius: 0.5rem; padding: 0.4rem 0.5rem; color: #ef4444; cursor: pointer; font-size: 0.75rem;"></button>
                            </div>
                        </div>
                    `;
                });
            }

            content += `
                    </div>
                    <div style="padding: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <button onclick="startNewProject()" style="width: 100%; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border: none; border-radius: 0.5rem; padding: 0.75rem; color: white; font-weight: 600; cursor: pointer;">
                            + New Project
                        </button>
                    </div>
                </div>
            `;

            modal.innerHTML = content;
            modal.onclick = (e) => {
                if (e.target === modal) closeProjectsModal();
            };

            document.body.appendChild(modal);
        }

        function loadProjectFromModal(projectId) {
            closeProjectsModal();
            window.location.href = `/video-creation?project=${projectId}`;
        }

        async function deleteProjectFromModal(projectId) {
            if (!confirm('Are you sure you want to delete this project?')) return;

            try {
                const deleteProjectFn = functions.httpsCallable('creationWizardDeleteProject');
                await deleteProjectFn({ projectId });

                // Reload projects list
                const projects = await loadProjectsList();
                renderProjectsModal(projects);

                // If we deleted the current project, reset state
                if (state.project.id === projectId) {
                    state.project.id = null;
                    state.project.name = null;
                    render();
                }

                showToast('Project deleted', 'success');
            } catch (error) {
                console.error('Delete error:', error);
                showToast('Failed to delete project', 'error');
            }
        }

        function startNewProject() {
            closeProjectsModal();
            window.location.href = '/video-creation';
        }
    </script>

    <!-- ============================================
         SECTION 7: RENDER FUNCTIONS
         ============================================ -->
    <script>
        // ==========================================
        // 7.1 MAIN RENDER FUNCTION
        // ==========================================
        function render() {
            const app = document.getElementById('app-root');

            let html = '';

            // Normal wizard layout for steps 1-6
            // Header bar
            html += renderHeaderBar();

            // Main container
            html += '<div class="wizard-container">';

            // Wizard header
            html += renderWizardHeader();

            // Stepper
            html += renderStepper();

            // Step content
            switch (state.currentStep) {
                case 1:
                    html += renderStep1Platform();
                    break;
                case 2:
                    html += renderStep2NicheStyle();
                    break;
                case 3:
                    html += renderStep3Script();
                    break;
                case 4:
                    html += renderStep4Storyboard();
                    break;
                case 5:
                    html += renderStep5Animation();
                    break;
                case 6:
                    html += renderStep6Assembly();
                    break;
            }

            html += '</div>'; // End wizard-container

            app.innerHTML = html;
            attachEventListeners();

            // CRITICAL: Reattach preview engine to new canvas after DOM re-render
            // But ONLY if not currently playing to prevent flickering
            if (previewEngine && state.preview.isReady) {
                const canvasId = 'preview-canvas';
                const newCanvas = document.getElementById(canvasId);
                if (newCanvas && previewEngine.canvas !== newCanvas) {
                    // Only reattach if canvas element actually changed AND not playing
                    if (!state.preview.isPlaying) {
                        previewEngine.attachToCanvas(newCanvas);
                    } else {
                        // If playing, update canvas reference AND set dimensions
                        // CRITICAL: Must set canvas.width/height to match engine dimensions
                        // otherwise canvas defaults to 300x150 and rendering is distorted
                        previewEngine.canvas = newCanvas;
                        previewEngine.ctx = newCanvas.getContext('2d');
                        newCanvas.width = previewEngine.width;
                        newCanvas.height = previewEngine.height;
                    }
                }
            }
        }

        // ==========================================
        // 7.2 HEADER BAR
        // ==========================================
        function renderHeaderBar() {
            const projectName = state.project.name || 'New Project';
            const isSaved = state.project.id !== null;

            return `
                <div class="header-bar">
                    <div class="header-left">
                        <a href="/video-optimizer" class="back-link">
                            <span></span>
                            <span>Dashboard</span>
                        </a>
                        <div class="project-info" style="margin-left: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">${projectName}</span>
                            ${isSaved ? '<span style="color: #10b981; font-size: 0.7rem;">Saved</span>' : '<span style="color: #f59e0b; font-size: 0.7rem;">Unsaved</span>'}
                        </div>
                    </div>
                    <div class="header-right" style="display: flex; align-items: center; gap: 1rem;">
                        <button onclick="openProjectsModal()" class="header-btn" style="background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.5rem; padding: 0.4rem 0.75rem; color: white; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 0.3rem;">
                            <span></span>
                            <span>Projects</span>
                        </button>
                        <button onclick="saveProject(false)" class="header-btn" style="background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; padding: 0.4rem 0.75rem; color: white; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 0.3rem;">
                            <span></span>
                            <span>Save</span>
                        </button>
                        <div class="token-display">
                            <span class="token-icon"></span>
                            <span class="token-count">${state.tokens.balance}</span>
                            <span style="color: rgba(255,255,255,0.5)">tokens</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // ==========================================
        // 7.3 WIZARD HEADER
        // ==========================================
        function renderWizardHeader() {
            return `
                <div class="wizard-header">
                    <h1 class="wizard-title">Video Creation Wizard</h1>
                    <p class="wizard-subtitle">Create professional AI-generated videos from scratch</p>
                </div>
            `;
        }

        // ==========================================
        // 7.4 STEPPER
        // ==========================================
        function renderStepper() {
            let html = '<div class="wizard-stepper">';

            WIZARD_STEPS.forEach((step, index) => {
                const isActive = state.currentStep === step.num;
                const isCompleted = state.currentStep > step.num;
                const isReachable = step.num <= state.maxReachedStep + 1;

                html += `
                    <div class="wizard-step ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}"
                         onclick="${isReachable ? `goToStep(${step.num})` : ''}"
                         style="${!isReachable ? 'opacity: 0.4; cursor: not-allowed;' : ''}">
                        <div class="step-number">
                            ${isCompleted ? '' : step.num}
                        </div>
                        <span class="step-label">${step.label}</span>
                    </div>
                `;

                // Add connector between steps
                if (index < WIZARD_STEPS.length - 1) {
                    html += `<div class="step-connector ${isCompleted ? 'completed' : ''}"></div>`;
                }
            });

            html += '</div>';
            return html;
        }

        // ==========================================
        // 7.5 STEP 1: PLATFORM & FORMAT
        // ==========================================
        function renderStep1Platform() {
            // NEW WIZARD FLOW: Minimal Format + Production Type Selection
            const selectedFormat = state.production.format;
            const selectedType = state.production.type;
            const selectedSubType = state.production.subType;

            let html = '<div class="fade-in">';

            // ==========================================
            // PHASE 1: Minimal Format Selection
            // ==========================================
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Video Format</div>
                            <div class="content-card-subtitle">Choose your aspect ratio</div>
                        </div>
                    </div>

                    <div class="format-selector" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75rem;">
            `;

            Object.values(FORMAT_PRESETS).forEach(format => {
                const isSelected = selectedFormat === format.id;
                html += `
                    <div class="format-option ${isSelected ? 'selected' : ''}"
                         onclick="selectProductionFormat('${format.id}')"
                         style="cursor: pointer; padding: 1rem; border-radius: 0.75rem; background: ${isSelected ? 'rgba(139, 92, 246, 0.3)' : 'rgba(255,255,255,0.05)'}; border: 2px solid ${isSelected ? '#8b5cf6' : 'transparent'}; text-align: center; transition: all 0.2s;">
                        <div style="font-size: 1.75rem; margin-bottom: 0.5rem;">${format.icon}</div>
                        <div style="font-weight: 600; font-size: 0.9rem;">${format.name}</div>
                        <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">${format.aspectRatio}</div>
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">${format.description}</div>
                    </div>
                `;
            });

            html += '</div></div>';

            // ==========================================
            // PHASE 2: Production Type Selection
            // ==========================================
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">What are you creating?</div>
                            <div class="content-card-subtitle">Select your production type</div>
                        </div>
                    </div>

                    <div class="production-type-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem;">
            `;

            Object.values(PRODUCTION_TYPES).forEach(type => {
                const isSelected = selectedType === type.id;
                html += `
                    <div class="production-type-card ${isSelected ? 'selected' : ''}"
                         onclick="selectProductionType('${type.id}')"
                         style="cursor: pointer; padding: 1.25rem; border-radius: 0.75rem; background: ${isSelected ? 'rgba(139, 92, 246, 0.3)' : 'rgba(255,255,255,0.05)'}; border: 2px solid ${isSelected ? '#8b5cf6' : 'transparent'}; text-align: center; transition: all 0.2s;">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">${type.icon}</div>
                        <div style="font-weight: 600; font-size: 0.95rem;">${type.name}</div>
                        <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); margin-top: 0.25rem;">${type.description}</div>
                    </div>
                `;
            });

            html += '</div>';

            // Sub-type Selection (show when production type selected)
            if (selectedType && PRODUCTION_TYPES[selectedType]) {
                const productionType = PRODUCTION_TYPES[selectedType];
                const subTypes = productionType.subTypes;

                html += `
                    <div class="subtype-section" style="margin-top: 1.5rem;">
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.7); margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span>${productionType.icon}</span>
                            <span>Select ${productionType.name} Style:</span>
                        </div>
                        <div class="subtype-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 0.5rem;">
                `;

                Object.values(subTypes).forEach(subType => {
                    const isSubSelected = selectedSubType === subType.id;
                    html += `
                        <div class="subtype-card ${isSubSelected ? 'selected' : ''}"
                             onclick="selectProductionSubType('${subType.id}')"
                             style="cursor: pointer; padding: 0.75rem 1rem; border-radius: 0.5rem; background: ${isSubSelected ? 'rgba(139, 92, 246, 0.25)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${isSubSelected ? '#8b5cf6' : 'rgba(255,255,255,0.1)'}; transition: all 0.2s;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 1.1rem;">${subType.icon}</span>
                                <span style="font-weight: 500; font-size: 0.85rem;">${subType.name}</span>
                            </div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem; margin-left: 1.6rem;">${subType.description}</div>
                        </div>
                    `;
                });

                html += '</div></div>';

                // Show selected sub-type details
                if (selectedSubType && subTypes[selectedSubType]) {
                    const subTypeConfig = subTypes[selectedSubType];
                    html += `
                        <div class="subtype-details" style="margin-top: 1rem; padding: 1rem; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem; border: 1px solid rgba(139, 92, 246, 0.2);">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <span style="font-size: 1.25rem;">${subTypeConfig.icon}</span>
                                <span style="font-weight: 600;">${subTypeConfig.name}</span>
                            </div>
                            ${subTypeConfig.visualStyle ? `<div style="font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;"><span style="color: #8b5cf6;">Visual Style:</span> ${subTypeConfig.visualStyle}</div>` : ''}
                            ${subTypeConfig.references ? `<div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);"><span style="color: #8b5cf6;">Style References:</span> ${subTypeConfig.references.join(', ')}</div>` : ''}
                            ${subTypeConfig.characteristics ? `<div style="font-size: 0.75rem; color: rgba(255,255,255,0.4); margin-top: 0.5rem;">Characteristics: ${subTypeConfig.characteristics.join('  ')}</div>` : ''}
                        </div>
                    `;

                    // VISUAL_STYLE_DNA: Visual Rendering Style Selector (Step 1)
                    // This controls whether images are photorealistic, cinematic, 3D animated, etc.
                    const visualStyleModesStep1 = [
                        { id: 'photorealistic', name: 'Photorealistic', icon: '', description: 'Real photography, documentary realism, actual humans', color: '#10b981' },
                        { id: 'cinematic', name: 'Cinematic', icon: '', description: 'Hollywood blockbuster look, dramatic but grounded', color: '#8b5cf6' },
                        { id: 'stylized_3d', name: 'Stylized 3D', icon: '', description: 'Pixar/Disney quality 3D animation', color: '#f59e0b' },
                        { id: 'illustrated', name: 'Illustrated', icon: '', description: 'Concept art, painterly artistic style', color: '#ec4899' },
                        { id: 'anime', name: 'Anime', icon: '', description: 'High-quality Japanese animation style', color: '#06b6d4' },
                        { id: 'noir', name: 'Film Noir', icon: '', description: 'High contrast, dramatic shadows', color: '#6b7280' }
                    ];
                    const selectedVisualStyleStep1 = state.content.visualStyleMode || 'photorealistic';

                    // Build visual style cards HTML for Step 1
                    let visualStyleCardsHtmlStep1 = '';
                    visualStyleModesStep1.forEach(style => {
                        const isSelected = selectedVisualStyleStep1 === style.id;
                        visualStyleCardsHtmlStep1 += `
                            <div onclick="setVisualStyleMode('${style.id}')"
                                 style="padding: 0.6rem; border-radius: 0.5rem; border: 2px solid ${isSelected ? style.color : 'rgba(255,255,255,0.1)'}; background: ${isSelected ? style.color + '20' : 'rgba(255,255,255,0.03)'}; cursor: pointer; transition: all 0.2s; text-align: center;">
                                <div style="font-size: 1.2rem;">${style.icon}</div>
                                <div style="font-size: 0.7rem; color: ${isSelected ? style.color : 'white'}; font-weight: 600; margin-top: 0.25rem;">${style.name}</div>
                                <div style="font-size: 0.55rem; color: rgba(255,255,255,0.5); margin-top: 0.2rem; line-height: 1.3;">${style.description}</div>
                            </div>
                        `;
                    });

                    // Get selected style info for Step 1
                    const selectedStyleInfoStep1 = visualStyleModesStep1.find(s => s.id === selectedVisualStyleStep1);
                    const styleColorStep1 = selectedStyleInfoStep1?.color || '#10b981';
                    const bestForTextStep1 = {
                        'photorealistic': ' Best for: Real stories, documentaries, live-action films with actual people',
                        'cinematic': ' Best for: Hollywood-style dramatic films, blockbusters, music videos',
                        'stylized_3d': ' Best for: Family content, animation projects, stylized characters',
                        'illustrated': ' Best for: Artistic content, concept videos, unique visual narratives',
                        'anime': ' Best for: Anime-style content, manga adaptations, Japanese aesthetics',
                        'noir': ' Best for: Crime dramas, mysteries, dark atmospheric content'
                    }[selectedVisualStyleStep1] || '';

                    html += `
                        <div class="content-card" style="margin-top: 1rem;">
                            <div class="content-card-header">
                                <div class="content-card-icon"></div>
                                <div>
                                    <div class="content-card-title">Visual Rendering Style</div>
                                    <div class="content-card-subtitle">How your images will look - photorealistic, cinematic, 3D, etc.</div>
                                </div>
                                <span style="margin-left: auto; font-size: 0.55rem; padding: 0.15rem 0.4rem; background: linear-gradient(135deg, #10b981, #06b6d4); border-radius: 0.2rem; color: white; font-weight: 600;">CRITICAL</span>
                            </div>

                            <!-- Visual Style Grid -->
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
                                ${visualStyleCardsHtmlStep1}
                            </div>

                            <!-- Selected Style Info -->
                            ${selectedVisualStyleStep1 ? `
                                <div style="margin-top: 0.75rem; padding: 0.6rem; background: ${styleColorStep1}15; border-radius: 0.4rem; border: 1px solid ${styleColorStep1}40;">
                                    <div style="font-size: 0.7rem; color: ${styleColorStep1}; font-weight: 600;">
                                        ${bestForTextStep1}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            }

            html += '</div>';

            // Duration Selection (contextual based on production type)
            if (selectedType && selectedSubType) {
                const productionType = PRODUCTION_TYPES[selectedType];
                const subTypeConfig = productionType.subTypes[selectedSubType];
                const durationRange = subTypeConfig?.suggestedDuration || productionType.defaultDuration;

                html += `
                    <div class="content-card">
                        <div class="content-card-header">
                            <div class="content-card-icon"></div>
                            <div>
                                <div class="content-card-title">Target Duration</div>
                                <div class="content-card-subtitle">Recommended for ${subTypeConfig?.name || productionType.name}</div>
                            </div>
                        </div>

                        <div class="duration-container">
                            <div class="duration-header">
                                <span class="duration-label">Video Length</span>
                                <span class="duration-value">${formatDuration(state.production.targetDuration)}</span>
                            </div>
                            <input type="range"
                                   class="duration-slider"
                                   id="duration-slider"
                                   min="${durationRange.min}"
                                   max="${durationRange.max}"
                                   value="${state.production.targetDuration}"
                                   oninput="setProductionDuration(this.value)">
                            <div class="duration-presets">
                                <span class="duration-preset" onclick="setProductionDuration(${durationRange.min})">${formatDuration(durationRange.min)}</span>
                                <span class="duration-preset" onclick="setProductionDuration(${Math.floor((durationRange.min + durationRange.max) / 2)})">${formatDuration(Math.floor((durationRange.min + durationRange.max) / 2))}</span>
                                <span class="duration-preset" onclick="setProductionDuration(${durationRange.max})">${formatDuration(durationRange.max)}</span>
                            </div>
                        </div>
                    </div>
                `;

                // Cost Estimate
                const cost = estimateCostForProduction();
                html += `
                    <div class="cost-estimate">
                        <div class="cost-estimate-header">
                            <span class="cost-estimate-title">Estimated Cost</span>
                            <span class="cost-estimate-value">~${cost.total} tokens</span>
                        </div>
                        <div class="cost-estimate-breakdown">
                            ${cost.sceneCount} scenes  Script ${cost.breakdown.script}  Images ${cost.breakdown.images}  Voice ${cost.breakdown.voiceover}  Animation ${cost.breakdown.animation}  Export ${cost.breakdown.export}
                        </div>
                    </div>
                `;
            }

            // Navigation
            const canProceed = selectedFormat && selectedType && selectedSubType;
            html += renderNavButtons(null, canProceed ? 2 : null);

            html += '</div>';
            return html;
        }

        // Helper function for new production flow
        function selectProductionFormat(formatId) {
            const formatConfig = FORMAT_PRESETS[formatId];
            if (!formatConfig) {
                console.error(`[Step 1] Invalid format ID: ${formatId}`);
                showToast('Invalid format selected', 'error');
                return;
            }
            state.production.format = formatId;
            state.production.formatConfig = formatConfig;
            // Also update legacy platform state for compatibility
            state.platform.aspectRatio = formatConfig.aspectRatio;
            render();
        }

        function selectProductionType(typeId) {
            const typeConfig = PRODUCTION_TYPES[typeId];
            if (!typeConfig) {
                console.error(`[Step 1] Invalid production type ID: ${typeId}`);
                showToast('Invalid production type selected', 'error');
                return;
            }
            state.production.type = typeId;
            state.production.typeConfig = typeConfig;
            state.production.subType = null;
            state.production.subTypeConfig = null;
            // Set initial duration based on production type
            const typeDuration = typeConfig.defaultDuration?.min || 180;
            state.production.targetDuration = typeDuration;
            // CRITICAL: Sync to legacy state for script generation
            state.platform.targetDuration = typeDuration;
            render();
        }

        function selectProductionSubType(subTypeId) {
            if (!state.production.type) {
                console.error('[Step 1] Cannot select sub-type without selecting production type first');
                showToast('Please select a production type first', 'warning');
                return;
            }
            const typeConfig = PRODUCTION_TYPES[state.production.type];
            if (!typeConfig) {
                console.error(`[Step 1] Production type not found: ${state.production.type}`);
                showToast('Production type configuration error', 'error');
                return;
            }
            const subTypeConfig = typeConfig.subTypes?.[subTypeId];
            if (!subTypeConfig) {
                console.error(`[Step 1] Invalid sub-type ID: ${subTypeId} for type: ${state.production.type}`);
                showToast('Invalid sub-type selected', 'error');
                return;
            }
            state.production.subType = subTypeId;
            state.production.subTypeConfig = subTypeConfig;
            // Update duration to sub-type's suggested range
            if (subTypeConfig.suggestedDuration) {
                const subTypeDuration = subTypeConfig.suggestedDuration.min;
                state.production.targetDuration = subTypeDuration;
                // CRITICAL: Sync to legacy state for script generation
                state.platform.targetDuration = subTypeDuration;
            }
            render();
        }

        function setProductionDuration(value) {
            const duration = parseInt(value);
            if (isNaN(duration) || duration < 0) {
                console.error(`[Step 1] Invalid duration value: ${value}`);
                return;
            }
            // Enforce reasonable bounds (1 second to 60 minutes)
            const boundedDuration = Math.max(1, Math.min(duration, 3600));
            state.production.targetDuration = boundedDuration;
            // Also update legacy state for compatibility
            state.platform.targetDuration = boundedDuration;
            render();
        }

        function estimateCostForProduction() {
            const duration = state.production.targetDuration || 180;
            const sceneCount = Math.ceil(duration / 6); // ~6 seconds per scene
            const breakdown = {
                script: 5,
                images: sceneCount * 3,
                voiceover: Math.ceil(duration / 30) * 2,
                animation: sceneCount * 10,
                export: 5
            };
            return {
                sceneCount,
                total: breakdown.script + breakdown.images + breakdown.voiceover + breakdown.animation + breakdown.export,
                breakdown
            };
        }

        // ==========================================
        // 7.6 STEP 2: CONCEPT DEVELOPMENT (Replaces Niche & Style)
        // ==========================================
        // This is the critical step that generates UNIQUE concepts
        // and distinguishes between STYLE REFERENCES and SUBJECT MATTER
        // ==========================================
        function renderStep2NicheStyle() {
            const concept = state.concept;
            const production = state.production;
            const isGenerating = concept.status === 'generating';
            const hasIdeas = concept.ideas && concept.ideas.length > 0;
            const hasSelectedIdea = concept.selectedIdea !== null;

            let html = '<div class="fade-in">';

            // ==========================================
            // CONCEPT INPUT CARD
            // ==========================================
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Develop Your Concept</div>
                            <div class="content-card-subtitle">Tell us what you want to create - we'll generate unique ideas</div>
                        </div>
                    </div>

                    <!-- Production Context -->
                    ${production.type ? `
                    <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.75rem; padding: 0.75rem; margin-bottom: 1rem;">
                        <div style="font-size: 0.75rem; color: rgba(255,255,255,0.6); display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                            <span>Creating:</span>
                            <span style="background: rgba(139, 92, 246, 0.3); padding: 0.25rem 0.5rem; border-radius: 0.25rem;">
                                ${production.typeConfig?.icon || ''} ${production.typeConfig?.name || ''}
                            </span>
                            ${production.subTypeConfig ? `
                            <span></span>
                            <span style="background: rgba(139, 92, 246, 0.3); padding: 0.25rem 0.5rem; border-radius: 0.25rem;">
                                ${production.subTypeConfig.icon || ''} ${production.subTypeConfig.name || ''}
                            </span>
                            ` : ''}
                            <span style="margin-left: auto; color: #8b5cf6;">
                                ${formatDuration(production.targetDuration)}
                            </span>
                        </div>
                    </div>
                    ` : ''}

                    <!-- Concept Input Area -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                            What's your video about?
                        </label>
                        <textarea id="concept-input"
                                  placeholder="Describe your idea, theme, or story... Be creative! Examples:
 A mysterious figure discovers an ancient power
 The untold story of a small town's greatest secret
 A journey through impossible landscapes
 An entrepreneur's rise from nothing

 PRO TIP: You can write a rough idea mixing styles, references, and genres - then click 'Enhance with AI' to transform it into a genius concept!"
                                  style="width: 100%; min-height: 120px; padding: 0.75rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.85rem; resize: vertical;"
                                  onchange="updateConceptInput(this.value)"
                                  oninput="updateConceptInput(this.value)">${concept.rawInput || ''}</textarea>

                        <!-- IMPROVE IDEA BUTTON - AI Enhancement -->
                        <button onclick="improveConceptIdea()"
                                ${concept.isImproving ? 'disabled' : ''}
                                style="margin-top: 0.5rem; padding: 0.5rem 1rem; background: ${concept.isImproving ? 'rgba(139, 92, 246, 0.3)' : 'linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(236, 72, 153, 0.2))'}; border: 1px solid rgba(139, 92, 246, 0.5); border-radius: 0.5rem; color: ${concept.isImproving ? 'rgba(255,255,255,0.5)' : '#a78bfa'}; font-weight: 500; font-size: 0.8rem; cursor: ${concept.isImproving ? 'wait' : 'pointer'}; display: inline-flex; align-items: center; gap: 0.4rem; transition: all 0.2s;"
                                onmouseover="if(!this.disabled) this.style.background='linear-gradient(135deg, rgba(139, 92, 246, 0.4), rgba(236, 72, 153, 0.4))'"
                                onmouseout="if(!this.disabled) this.style.background='linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(236, 72, 153, 0.2))'">
                            ${concept.isImproving ? `
                                <span style="animation: spin 1s linear infinite;"></span>
                                <span>Enhancing your idea...</span>
                            ` : `
                                <span></span>
                                <span>Enhance with AI</span>
                            `}
                        </button>
                        <span style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-left: 0.5rem;">
                            Auto-extracts styles & fills all fields
                        </span>
                    </div>

                    ${concept.improvedData ? `
                    <!-- AI Enhancement Results Preview -->
                    <div style="margin-bottom: 1rem; padding: 0.75rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.05)); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.5rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="font-size: 0.9rem;"></span>
                            <span style="font-size: 0.75rem; font-weight: 600; color: #a78bfa;">AI Enhancement Applied</span>
                        </div>
                        ${concept.improvedData.hookLine ? `
                        <div style="font-size: 0.8rem; color: rgba(255,255,255,0.9); font-style: italic; margin-bottom: 0.5rem;">
                            "${concept.improvedData.hookLine}"
                        </div>
                        ` : ''}
                        ${concept.improvedData.genreFusion ? `
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">
                            <span style="color: #8b5cf6;">Genre:</span> ${concept.improvedData.genreFusion}
                        </div>
                        ` : ''}
                        ${concept.improvedData.visualSignature ? `
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.6); margin-top: 0.25rem;">
                            <span style="color: #ec4899;">Visual:</span> ${concept.improvedData.visualSignature}
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}

                    <!-- CRITICAL: Style Reference (NOT subject matter) -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.25rem;">
                            Style Inspiration (Optional)
                        </label>
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.5rem;">
                             This is for VISUAL STYLE only - your content will be 100% original
                        </div>
                        <input type="text"
                               id="style-reference-input"
                               placeholder="e.g., 'Breaking Bad cinematography', 'Wes Anderson color palette', 'documentary noir'"
                               value="${concept.styleReference || ''}"
                               style="width: 100%; padding: 0.65rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.85rem;"
                               onchange="updateStyleReference(this.value)">
                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">
                            We'll capture the visual FEEL without copying any content or characters
                        </div>
                    </div>

                    <!-- What to Avoid (explicitly prevent copyrighted content) -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.25rem;">
                            Things to Avoid (Optional)
                        </label>
                        <input type="text"
                               id="avoid-input"
                               placeholder="e.g., 'specific brand names', 'real people', 'trademarked characters'"
                               value="${(concept.avoidElements || []).join(', ')}"
                               style="width: 100%; padding: 0.65rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.85rem;"
                               onchange="updateAvoidElements(this.value)">
                    </div>

                    <!-- Generate Ideas Button -->
                    <button onclick="generateConceptIdeas()"
                            ${isGenerating ? 'disabled' : ''}
                            style="width: 100%; padding: 0.85rem; background: linear-gradient(135deg, #8b5cf6, #ec4899); border: none; border-radius: 0.5rem; color: white; font-weight: 600; font-size: 0.9rem; cursor: ${isGenerating ? 'wait' : 'pointer'}; display: flex; align-items: center; justify-content: center; gap: 0.5rem; opacity: ${isGenerating ? '0.7' : '1'};">
                        ${isGenerating ? `
                            <span style="animation: spin 1s linear infinite;"></span>
                            <span>Generating unique ideas...</span>
                        ` : `
                            <span></span>
                            <span>Generate Unique Ideas</span>
                        `}
                    </button>
                </div>
            `;

            // ==========================================
            // UNIFIED CONCEPT SECTION - Your Concept + Alternatives
            // Shows selected/primary concept with full details, with option to see alternatives
            // ==========================================
            if (hasIdeas) {
                const selectedIdea = hasSelectedIdea ? concept.ideas[concept.selectedIdea] : concept.ideas[0];
                const selectedIndex = hasSelectedIdea ? concept.selectedIdea : 0;

                // DEFENSIVE: Helper to safely render text (prevents corrupted data display)
                const safeText = (val, maxLen = 1000) => {
                    if (val === null || val === undefined) return '';
                    if (typeof val !== 'string') {
                        console.warn('[Concept Display] Non-string value detected:', typeof val, val);
                        return typeof val === 'object' ? '' : String(val).substring(0, maxLen);
                    }
                    // Check for corrupted data (high ratio of replacement characters)
                    const replacementChars = (val.match(/\uFFFD/g) || []).length;
                    if (replacementChars > val.length * 0.1) {
                        console.warn('[Concept Display] Corrupted data detected, skipping render');
                        return '[Data corrupted - please regenerate]';
                    }
                    return val.substring(0, maxLen);
                };

                // Auto-select first concept if none selected
                if (!hasSelectedIdea && concept.ideas.length > 0) {
                    // Don't auto-select here, just show first as preview
                }

                html += `
                    <div class="content-card">
                        <div class="content-card-header">
                            <div class="content-card-icon"></div>
                            <div>
                                <div class="content-card-title">Your Concept</div>
                                <div class="content-card-subtitle">${hasSelectedIdea ? 'Ready for script generation' : 'Select a concept direction below'}</div>
                            </div>
                        </div>

                        <!-- PRIMARY CONCEPT DISPLAY - Full Rich Data -->
                        <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(236, 72, 153, 0.1)); border: 2px solid ${hasSelectedIdea ? '#8b5cf6' : 'rgba(139, 92, 246, 0.3)'}; border-radius: 0.75rem; padding: 1.25rem; margin-bottom: 1rem;">
                            <!-- Title & Logline -->
                            <div style="font-weight: 700; font-size: 1.1rem; color: white; margin-bottom: 0.5rem;">
                                ${safeText(selectedIdea?.title, 100) || 'Untitled Concept'}
                            </div>
                            <div style="font-size: 0.9rem; color: rgba(255,255,255,0.85); line-height: 1.6; margin-bottom: 1rem;">
                                ${safeText(selectedIdea?.logline) || safeText(selectedIdea?.description) || ''}
                            </div>

                            <!-- Narrative Architecture Badges -->
                            <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem;">
                                ${selectedIdea?.narrativeStructure && typeof selectedIdea.narrativeStructure === 'string' ? `
                                <span style="font-size: 0.7rem; padding: 0.25rem 0.6rem; background: rgba(139, 92, 246, 0.3); border-radius: 0.35rem; color: #c4b5fd; font-weight: 500;">
                                     ${safeText(selectedIdea.narrativeStructure, 50).replace(/_/g, ' ')}
                                </span>
                                ` : ''}
                                ${selectedIdea?.storyEngine && typeof selectedIdea.storyEngine === 'string' ? `
                                <span style="font-size: 0.7rem; padding: 0.25rem 0.6rem; background: rgba(236, 72, 153, 0.3); border-radius: 0.35rem; color: #f9a8d4; font-weight: 500;">
                                     ${safeText(selectedIdea.storyEngine, 50).replace(/_/g, ' ')}
                                </span>
                                ` : ''}
                                ${selectedIdea?.protagonistCount ? `
                                <span style="font-size: 0.7rem; padding: 0.25rem 0.6rem; background: rgba(16, 185, 129, 0.3); border-radius: 0.35rem; color: #6ee7b7; font-weight: 500;">
                                     ${selectedIdea.protagonistCount} protagonist${selectedIdea.protagonistCount !== '1' && selectedIdea.protagonistCount !== 1 ? 's' : ''}
                                </span>
                                ` : ''}
                                ${selectedIdea?.mood ? `
                                <span style="font-size: 0.7rem; padding: 0.25rem 0.6rem; background: rgba(6, 182, 212, 0.3); border-radius: 0.35rem; color: #67e8f9; font-weight: 500;">
                                     ${selectedIdea.mood}
                                </span>
                                ` : ''}
                                ${selectedIdea?.tone ? `
                                <span style="font-size: 0.7rem; padding: 0.25rem 0.6rem; background: rgba(251, 191, 36, 0.3); border-radius: 0.35rem; color: #fcd34d; font-weight: 500;">
                                     ${selectedIdea.tone}
                                </span>
                                ` : ''}
                            </div>

                            <!-- Characters Preview -->
                            ${selectedIdea?.characters && selectedIdea.characters.length > 0 ? `
                            <div style="margin-bottom: 1rem;">
                                <div style="font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.5px;">Characters</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                    ${selectedIdea.characters.slice(0, 4).map(char => `
                                        <div style="background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.5rem; padding: 0.5rem 0.75rem;">
                                            <div style="font-size: 0.8rem; font-weight: 600; color: white;">${safeText(char?.name, 50) || 'Unknown'}</div>
                                            <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">${safeText(char?.archetype, 30) || safeText(char?.role, 30) || ''}</div>
                                        </div>
                                    `).join('')}
                                    ${selectedIdea.characters.length > 4 ? `<div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); align-self: center;">+${selectedIdea.characters.length - 4} more</div>` : ''}
                                </div>
                            </div>
                            ` : ''}

                            <!-- World Setting - DEFENSIVE: only render if worldSetting is an object -->
                            ${selectedIdea?.worldSetting && typeof selectedIdea.worldSetting === 'object' ? `
                            <div style="margin-bottom: 1rem;">
                                <div style="font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.6); margin-bottom: 0.35rem; text-transform: uppercase; letter-spacing: 0.5px;">World</div>
                                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.7);">
                                    ${safeText(selectedIdea.worldSetting.location, 200) || ''}${selectedIdea.worldSetting.atmosphere ? `  ${safeText(selectedIdea.worldSetting.atmosphere, 200)}` : ''}
                                </div>
                            </div>
                            ` : ''}

                            <!-- Theme - DEFENSIVE: only render if theme is a string -->
                            ${selectedIdea?.theme && typeof selectedIdea.theme === 'string' ? `
                            <div style="background: rgba(255,255,255,0.03); border-radius: 0.5rem; padding: 0.75rem; border-left: 3px solid #8b5cf6;">
                                <div style="font-size: 0.7rem; font-weight: 600; color: rgba(255,255,255,0.5); margin-bottom: 0.25rem;">DEEPER MEANING</div>
                                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.8); font-style: italic;">${safeText(selectedIdea.theme, 500)}</div>
                            </div>
                            ` : ''}

                            <!-- Visual Style - DEFENSIVE: validate string types -->
                            ${(concept.styleReference && typeof concept.styleReference === 'string') || (selectedIdea?.visualApproach && typeof selectedIdea.visualApproach === 'string') ? `
                            <div style="margin-top: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.6);">
                                <span style="color: #8b5cf6; font-weight: 500;">Visual Style:</span> ${safeText(concept.styleReference) || safeText(selectedIdea?.visualApproach) || ''}
                            </div>
                            ` : ''}
                        </div>

                        <!-- ALTERNATIVE CONCEPTS - Collapsible -->
                        ${concept.ideas.length > 1 ? `
                        <div style="margin-bottom: 1rem;">
                            <div style="font-size: 0.8rem; font-weight: 600; color: rgba(255,255,255,0.7); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                                <span>Alternative Directions</span>
                                <span style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">(click to switch)</span>
                            </div>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                ${concept.ideas.map((idea, index) => `
                                    <div onclick="selectConceptIdea(${index})"
                                         style="cursor: pointer; padding: 0.5rem 0.75rem; border-radius: 0.5rem; background: ${concept.selectedIdea === index ? 'rgba(139, 92, 246, 0.3)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${concept.selectedIdea === index ? '#8b5cf6' : 'rgba(255,255,255,0.1)'}; transition: all 0.2s; flex: 1; min-width: 150px; max-width: calc(33% - 0.5rem);">
                                        <div style="font-size: 0.75rem; font-weight: 600; color: ${concept.selectedIdea === index ? '#c4b5fd' : 'white'}; margin-bottom: 0.2rem; display: flex; align-items: center; gap: 0.35rem;">
                                            ${concept.selectedIdea === index ? '' : `${index + 1}.`} ${safeText(idea?.title, 50) || 'Concept ' + (index + 1)}
                                        </div>
                                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">
                                            ${idea?.narrativeStructure && typeof idea.narrativeStructure === 'string' ? safeText(idea.narrativeStructure, 30).replace(/_/g, ' ') : safeText(idea?.mood, 30) || ''}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}

                        <!-- Generate More Button -->
                        <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 1rem; margin-top: 0.5rem;">
                            <button onclick="generateConceptIdeas()"
                                    style="width: 100%; padding: 0.65rem; border-radius: 0.5rem; border: 1px dashed rgba(139, 92, 246, 0.5); background: transparent; color: #a78bfa; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; transition: all 0.2s;"
                                    onmouseover="this.style.background='rgba(139, 92, 246, 0.1)'; this.style.borderStyle='solid';"
                                    onmouseout="this.style.background='transparent'; this.style.borderStyle='dashed';">
                                <span></span>
                                <span>Generate Different Concepts</span>
                            </button>
                        </div>

                    </div>
                `;
            }

            // ==========================================
            // CHARACTER INTELLIGENCE PREVIEW (Phase 4)
            // ==========================================
            if (hasSelectedIdea && production.typeConfig) {
                const characterNeeds = production.typeConfig.characterNeeds || { min: 0, max: 5, suggested: 0 };
                const subTypeConfig = production.subTypeConfig;
                const defaultNarration = subTypeConfig?.defaultNarration || production.typeConfig.defaultNarration || 'voiceover';

                html += `
                    <div class="content-card">
                        <div class="content-card-header">
                            <div class="content-card-icon"></div>
                            <div>
                                <div class="content-card-title">Character Intelligence</div>
                                <div class="content-card-subtitle">AI-suggested based on your production type</div>
                            </div>
                            <span style="margin-left: auto; font-size: 0.6rem; padding: 0.15rem 0.4rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border-radius: 0.25rem; color: white;">AI</span>
                        </div>

                        <!-- Narration Mode -->
                        <div style="margin-bottom: 1rem;">
                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Narration Style</div>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                                ${['voiceover', 'dialogue', 'narrator', 'none'].map(mode => {
                                    const icons = { voiceover: '', dialogue: '', narrator: '', none: '' };
                                    const labels = { voiceover: 'Voiceover', dialogue: 'Dialogue', narrator: 'Narrator', none: 'No Voice' };
                                    const isDefault = mode === defaultNarration;
                                    const isSelected = (state.characterIntelligence.narrationMode === mode) ||
                                                      (state.characterIntelligence.narrationMode === 'auto' && isDefault);
                                    return `
                                        <div onclick="setNarrationMode('${mode}')"
                                             style="padding: 0.6rem; border-radius: 0.5rem; border: 2px solid ${isSelected ? '#8b5cf6' : 'rgba(255,255,255,0.1)'}; background: ${isSelected ? 'rgba(139, 92, 246, 0.15)' : 'transparent'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                                            <div style="font-size: 1.1rem;">${icons[mode]}</div>
                                            <div style="font-size: 0.7rem; color: ${isSelected ? '#a78bfa' : 'rgba(255,255,255,0.6)'}; margin-top: 0.25rem;">${labels[mode]}</div>
                                            ${isDefault ? '<div style="font-size: 0.55rem; color: rgba(255,255,255,0.4);">suggested</div>' : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Character Count -->
                        <div style="margin-bottom: 1rem;">
                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">
                                Character Count
                                <span style="color: #8b5cf6; margin-left: 0.5rem;">Suggested: ${characterNeeds.suggested}</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <input type="range"
                                       id="character-count-slider"
                                       min="${characterNeeds.min}"
                                       max="${characterNeeds.max}"
                                       value="${state.characterIntelligence.suggestedCount || characterNeeds.suggested}"
                                       oninput="setCharacterCount(this.value)"
                                       style="flex: 1;">
                                <span style="font-size: 1rem; font-weight: 600; color: #8b5cf6; min-width: 30px; text-align: center;">
                                    ${state.characterIntelligence.suggestedCount || characterNeeds.suggested}
                                </span>
                            </div>
                            <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">
                                ${characterNeeds.min === 0 ? 'No characters required for this format' : `Minimum ${characterNeeds.min} characters recommended`}
                            </div>
                        </div>

                        <!-- Character Type (for non-human support) -->
                        ${subTypeConfig?.allowedCharacterTypes ? `
                        <div style="margin-bottom: 0.5rem;">
                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Allowed Character Types</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.35rem;">
                                ${subTypeConfig.allowedCharacterTypes.map(type => {
                                    const typeIcons = {
                                        human: '', robot: '', alien: '', ai: '', cyborg: '',
                                        creature: '', 'magical-being': '', elf: '', dwarf: '', wizard: '',
                                        dragon: '', undead: '', demon: '', mecha: '', spirit: '',
                                        monster: '', animal: '', object: '', abstract: '', anything: '',
                                        any: '', clone: ''
                                    };
                                    return `
                                        <span style="font-size: 0.7rem; padding: 0.25rem 0.5rem; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.25rem; color: #a78bfa; display: flex; align-items: center; gap: 0.25rem;">
                                            <span>${typeIcons[type] || '?'}</span>
                                            <span style="text-transform: capitalize;">${type.replace('-', ' ')}</span>
                                        </span>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                `;
            }

            // ==========================================
            // LEGACY: Niche Selection (for backwards compatibility)
            // Show only if production type wasn't selected
            // ==========================================
            if (!production.type) {
                const selectedNiche = state.content.niche;
                const selectedSubniche = state.content.subniche;
                const selectedStyle = state.content.style;

                html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Select Your Niche</div>
                            <div class="content-card-subtitle">What category best describes your content?</div>
                        </div>
                    </div>

                    <div class="niche-grid">
            `;

            Object.values(VIDEO_NICHES).forEach(niche => {
                const isSelected = selectedNiche === niche.id;
                html += `
                    <div class="niche-card ${isSelected ? 'selected' : ''}"
                         onclick="selectNiche('${niche.id}')">
                        <div class="niche-icon">${niche.icon}</div>
                        <div class="niche-name">${niche.name}</div>
                    </div>
                `;
            });

            html += '</div>';

            // Sub-niche chips (if niche selected)
            if (selectedNiche && VIDEO_NICHES[selectedNiche]) {
                const niche = VIDEO_NICHES[selectedNiche];
                html += `
                    <div class="subniche-container">
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.6); margin-bottom: 0.75rem;">
                            Refine your focus (optional):
                        </div>
                        <div class="subniche-chips">
                `;

                niche.subniches.forEach(sub => {
                    const isSelected = selectedSubniche === sub.id;
                    html += `
                        <div class="subniche-chip ${isSelected ? 'selected' : ''}"
                             onclick="selectSubniche('${sub.id}')">
                            ${sub.name}
                        </div>
                    `;
                });

                html += '</div></div>';
            }

            html += '</div>';

            // Style Selection Card
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Choose Visual Style</div>
                            <div class="content-card-subtitle">How should your video look and feel?</div>
                        </div>
                    </div>

                    <div class="style-grid">
            `;

            Object.values(VIDEO_STYLES).forEach(style => {
                const isSelected = selectedStyle === style.id;
                html += `
                    <div class="style-card ${isSelected ? 'selected' : ''}"
                         onclick="selectStyle('${style.id}')">
                        <div class="style-icon">${style.icon}</div>
                        <div class="style-name">${style.name}</div>
                        <div class="style-desc">${style.description}</div>
                    </div>
                `;
            });

            html += '</div></div>';

            // Pacing Control Card (NEW - Controls video timing)
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Video Pacing</div>
                            <div class="content-card-subtitle">How fast should your video flow?</div>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 0.5rem;">
                        <div onclick="setPacing('fast')"
                             style="padding: 1rem; border-radius: 0.75rem; border: 2px solid ${state.content.pacing === 'fast' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${state.content.pacing === 'fast' ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;"></div>
                            <div style="font-weight: 600; color: white; margin-bottom: 0.25rem;">Fast</div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Quick cuts, dense narration<br>~6s per scene</div>
                        </div>
                        <div onclick="setPacing('balanced')"
                             style="padding: 1rem; border-radius: 0.75rem; border: 2px solid ${state.content.pacing === 'balanced' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${state.content.pacing === 'balanced' ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;"></div>
                            <div style="font-weight: 600; color: white; margin-bottom: 0.25rem;">Balanced</div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Natural flow<br>~6-10s per scene</div>
                        </div>
                        <div onclick="setPacing('contemplative')"
                             style="padding: 1rem; border-radius: 0.75rem; border: 2px solid ${state.content.pacing === 'contemplative' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${state.content.pacing === 'contemplative' ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;"></div>
                            <div style="font-weight: 600; color: white; margin-bottom: 0.25rem;">Contemplative</div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Visual breathing room<br>~10s per scene</div>
                        </div>
                    </div>

                    <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem; border: 1px solid rgba(139, 92, 246, 0.2);">
                        <div style="font-size: 0.75rem; color: #a78bfa;">
                             For your ${formatDuration(state.platform.targetDuration)} video:
                            <strong>${Math.round(state.platform.targetDuration / (state.content.pacing === 'fast' ? 6 : state.content.pacing === 'contemplative' ? 10 : 8))} scenes</strong>
                            with <strong>${state.content.pacing === 'fast' ? '85%' : state.content.pacing === 'contemplative' ? '50%' : '70%'}</strong> narration coverage
                        </div>
                    </div>
                </div>
            `;

            // Hollywood Production Mode Card
            const productionMode = state.content.productionMode || 'standard';
            const productionModes = {
                standard: { icon: '', name: 'Standard', desc: 'Clean, professional content', color: '#9ca3af' },
                documentary: { icon: '', name: 'Documentary', desc: 'Ken Burns style, educational', color: '#3b82f6' },
                thriller: { icon: '', name: 'Thriller', desc: 'Suspenseful, mystery-driven', color: '#ef4444' },
                inspirational: { icon: '', name: 'Inspirational', desc: 'Uplifting, motivational', color: '#f59e0b' },
                story: { icon: '', name: 'Story', desc: 'Character-driven narrative', color: '#10b981' },
                cinematic: { icon: '', name: 'Cinematic', desc: 'Film-quality production', color: '#8b5cf6' }
            };
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Production Mode</div>
                            <div class="content-card-subtitle">Hollywood-style storytelling approach</div>
                        </div>
                        <span style="margin-left: auto; font-size: 0.65rem; padding: 0.2rem 0.5rem; background: linear-gradient(135deg, #8b5cf6, #ec4899); border-radius: 1rem; color: white; font-weight: 600;">NEW</span>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.6rem; margin-top: 0.5rem;">
                        ${Object.entries(productionModes).map(([id, mode]) => `
                            <div onclick="setProductionMode('${id}')"
                                 style="padding: 0.75rem 0.5rem; border-radius: 0.75rem; border: 2px solid ${productionMode === id ? mode.color : 'rgba(255,255,255,0.12)'}; background: ${productionMode === id ? mode.color + '20' : 'rgba(255,255,255,0.03)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                                <div style="font-size: 1.25rem; margin-bottom: 0.3rem;">${mode.icon}</div>
                                <div style="font-weight: 600; color: ${productionMode === id ? mode.color : 'white'}; font-size: 0.75rem;">${mode.name}</div>
                                <div style="font-size: 0.55rem; color: rgba(255,255,255,0.45); margin-top: 0.15rem; line-height: 1.3;">${mode.desc}</div>
                            </div>
                        `).join('')}
                    </div>

                    ${productionMode !== 'standard' ? `
                    <div style="margin-top: 0.75rem; padding: 0.6rem 0.75rem; background: ${productionModes[productionMode].color}15; border-radius: 0.5rem; border: 1px solid ${productionModes[productionMode].color}30;">
                        <div style="font-size: 0.7rem; color: ${productionModes[productionMode].color};">
                            ${productionMode === 'documentary' ? ' Your script will include: authoritative narration, Ken Burns visual style, moments of wonder and discovery' :
                              productionMode === 'thriller' ? ' Your script will include: tension-building narration, dramatic reveals, mystery-driven structure' :
                              productionMode === 'inspirational' ? ' Your script will include: motivational arc, transformation story, empowering conclusion' :
                              productionMode === 'story' ? ' Your script will include: character development, three-act structure, emotional climax' :
                              ' Your script will include: sparse poetic narration, cinematic visuals, iconic framing'}
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;

            // Phase 3A: Genre Reference Card
            const selectedGenre = state.content.genre;
            const selectedFormat = state.content.contentFormat || 'medium-form';
            const genreLibrary = {
                // Documentary
                'documentary-nature': { icon: '', name: 'Nature Doc', category: 'documentary', refs: 'Planet Earth, Our Planet', color: '#10b981' },
                'documentary-true-crime': { icon: '', name: 'True Crime', category: 'documentary', refs: 'Making a Murderer, The Jinx', color: '#ef4444' },
                'documentary-social': { icon: '', name: 'Social Doc', category: 'documentary', refs: 'The Social Dilemma', color: '#3b82f6' },
                'documentary-historical': { icon: '', name: 'Historical', category: 'documentary', refs: 'Ken Burns, Apollo 11', color: '#f59e0b' },
                // Educational
                'educational-explainer': { icon: '', name: 'Explainer', category: 'educational', refs: 'Kurzgesagt, Vox', color: '#8b5cf6' },
                'educational-tutorial': { icon: '', name: 'Tutorial', category: 'educational', refs: 'Mark Rober, Babish', color: '#06b6d4' },
                'educational-science': { icon: '', name: 'Science', category: 'educational', refs: 'Veritasium, Vsauce', color: '#10b981' },
                // Entertainment
                'entertainment-comedy': { icon: '', name: 'Comedy', category: 'entertainment', refs: 'The Office, Key & Peele', color: '#f59e0b' },
                'entertainment-drama': { icon: '', name: 'Drama', category: 'entertainment', refs: 'Breaking Bad, Succession', color: '#ef4444' },
                'entertainment-horror': { icon: '', name: 'Horror', category: 'entertainment', refs: 'Black Mirror, Get Out', color: '#6366f1' },
                // Business
                'business-brand': { icon: '', name: 'Brand Story', category: 'business', refs: 'Apple, Nike', color: '#ec4899' },
                'business-product': { icon: '', name: 'Product', category: 'business', refs: 'Apple reveals, MKBHD', color: '#8b5cf6' },
                'business-testimonial': { icon: '', name: 'Testimonial', category: 'business', refs: 'Shot on iPhone', color: '#10b981' },
                // Social
                'social-viral': { icon: '', name: 'Viral', category: 'social', refs: 'MrBeast, TikTok', color: '#ef4444' },
                'social-storytime': { icon: '', name: 'Storytime', category: 'social', refs: 'Reddit stories', color: '#f59e0b' },
                // Series
                'series-docuseries': { icon: '', name: 'Docuseries', category: 'series', refs: 'Drive to Survive', color: '#3b82f6' }
            };
            const formatOptions = {
                'short-form': { icon: '', name: 'Short', desc: '< 60s' },
                'medium-form': { icon: '', name: 'Medium', desc: '1-5 min' },
                'long-form': { icon: '', name: 'Long', desc: '5-10 min' },
                'extended-form': { icon: '', name: 'Extended', desc: '10-20 min' },
                'episodic': { icon: '', name: 'Series', desc: 'Episodes' }
            };
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Genre Reference</div>
                            <div class="content-card-subtitle">Learn from the best productions ever made</div>
                        </div>
                        <span style="margin-left: auto; font-size: 0.6rem; padding: 0.2rem 0.5rem; background: linear-gradient(135deg, #f59e0b, #ef4444); border-radius: 1rem; color: white; font-weight: 600;">PRO</span>
                    </div>

                    <!-- Content Format Selection -->
                    <div style="margin-bottom: 0.75rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Content Format</div>
                        <div style="display: flex; gap: 0.5rem;">
                            ${Object.entries(formatOptions).map(([id, fmt]) => `
                                <div onclick="setContentFormat('${id}')"
                                     style="flex: 1; padding: 0.5rem; border-radius: 0.5rem; border: 2px solid ${selectedFormat === id ? '#06b6d4' : 'rgba(255,255,255,0.12)'}; background: ${selectedFormat === id ? 'rgba(6,182,212,0.15)' : 'transparent'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                                    <div style="font-size: 1rem;">${fmt.icon}</div>
                                    <div style="font-size: 0.7rem; font-weight: 600; color: ${selectedFormat === id ? '#06b6d4' : 'white'};">${fmt.name}</div>
                                    <div style="font-size: 0.55rem; color: rgba(255,255,255,0.4);">${fmt.desc}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Genre Selection -->
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Genre Style (Optional)</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.4rem; max-height: 180px; overflow-y: auto; padding: 0.25rem;">
                        <div onclick="setGenre(null)"
                             style="padding: 0.4rem 0.6rem; border-radius: 0.4rem; border: 1px solid ${!selectedGenre ? '#9ca3af' : 'rgba(255,255,255,0.1)'}; background: ${!selectedGenre ? 'rgba(156,163,175,0.2)' : 'transparent'}; cursor: pointer; display: flex; align-items: center; gap: 0.3rem; transition: all 0.15s;">
                            <span style="font-size: 0.75rem;"></span>
                            <span style="font-size: 0.65rem; color: ${!selectedGenre ? 'white' : 'rgba(255,255,255,0.6)'};">Auto</span>
                        </div>
                        ${Object.entries(genreLibrary).map(([id, genre]) => `
                            <div onclick="setGenre('${id}')"
                                 style="padding: 0.4rem 0.6rem; border-radius: 0.4rem; border: 1px solid ${selectedGenre === id ? genre.color : 'rgba(255,255,255,0.1)'}; background: ${selectedGenre === id ? genre.color + '25' : 'transparent'}; cursor: pointer; display: flex; align-items: center; gap: 0.3rem; transition: all 0.15s;">
                                <span style="font-size: 0.75rem;">${genre.icon}</span>
                                <span style="font-size: 0.65rem; color: ${selectedGenre === id ? genre.color : 'rgba(255,255,255,0.6)'};">${genre.name}</span>
                            </div>
                        `).join('')}
                    </div>

                    ${selectedGenre && genreLibrary[selectedGenre] ? `
                    <div style="margin-top: 0.6rem; padding: 0.5rem 0.65rem; background: ${genreLibrary[selectedGenre].color}15; border-radius: 0.4rem; border: 1px solid ${genreLibrary[selectedGenre].color}30;">
                        <div style="font-size: 0.65rem; color: ${genreLibrary[selectedGenre].color};">
                             References: ${genreLibrary[selectedGenre].refs}
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;

            // VISUAL_STYLE_DNA: Visual Rendering Style Selector
            // NOTE: Moved to Step 1 (after movie subtype selection) - removed duplicate from Step 2

            // Phase 3F: Narrative Structure Intelligence Card
            const narrativePreset = state.content.narrativePreset || '';
            const storyArc = state.content.storyArc || '';
            const emotionalJourney = state.content.emotionalJourney || '';
            const tensionCurve = state.content.tensionCurve || '';
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Narrative Structure</div>
                            <div class="content-card-subtitle">Professional story architecture for your content</div>
                        </div>
                        <span style="margin-left: auto; font-size: 0.55rem; padding: 0.15rem 0.4rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border-radius: 0.2rem; color: white; font-weight: 600;">AI</span>
                    </div>

                    <!-- Narrative Preset -->
                    <div style="margin-bottom: 0.75rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Narrative Preset</div>
                        <select onchange="setNarrativePreset(this.value)" style="width: 100%; padding: 0.6rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.8rem; cursor: pointer;">
                            <option value="">Auto (from genre)</option>
                            <option value="youtube-standard" ${narrativePreset === 'youtube-standard' ? 'selected' : ''}> YouTube Standard</option>
                            <option value="tiktok-viral" ${narrativePreset === 'tiktok-viral' ? 'selected' : ''}> TikTok Viral</option>
                            <option value="cinematic-short" ${narrativePreset === 'cinematic-short' ? 'selected' : ''}> Cinematic Short</option>
                            <option value="documentary-feature" ${narrativePreset === 'documentary-feature' ? 'selected' : ''}> Documentary</option>
                            <option value="series-episode" ${narrativePreset === 'series-episode' ? 'selected' : ''}> Series Episode</option>
                            <option value="commercial-spot" ${narrativePreset === 'commercial-spot' ? 'selected' : ''}> Commercial/Ad</option>
                            <option value="music-video-narrative" ${narrativePreset === 'music-video-narrative' ? 'selected' : ''}> Music Video</option>
                            <option value="thriller-short" ${narrativePreset === 'thriller-short' ? 'selected' : ''}> Thriller</option>
                            <option value="horror-short" ${narrativePreset === 'horror-short' ? 'selected' : ''}> Horror</option>
                            <option value="inspirational" ${narrativePreset === 'inspirational' ? 'selected' : ''}> Inspirational</option>
                        </select>
                    </div>

                    <!-- Story Arc -->
                    <div style="margin-bottom: 0.75rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Story Arc</div>
                        <select onchange="setStoryArc(this.value)" style="width: 100%; padding: 0.6rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.8rem; cursor: pointer;">
                            <option value="">Auto (from preset)</option>
                            <option value="three-act" ${storyArc === 'three-act' ? 'selected' : ''}> Three-Act (Hollywood)</option>
                            <option value="five-act" ${storyArc === 'five-act' ? 'selected' : ''}> Five-Act (Shakespeare)</option>
                            <option value="heros-journey" ${storyArc === 'heros-journey' ? 'selected' : ''}> Hero's Journey</option>
                            <option value="dan-harmon-circle" ${storyArc === 'dan-harmon-circle' ? 'selected' : ''}> Story Circle (Dan Harmon)</option>
                            <option value="freytags-pyramid" ${storyArc === 'freytags-pyramid' ? 'selected' : ''}> Freytag's Pyramid</option>
                            <option value="kishotenketsu" ${storyArc === 'kishotenketsu' ? 'selected' : ''}> Kishotenketsu (East Asian)</option>
                            <option value="youtube-retention" ${storyArc === 'youtube-retention' ? 'selected' : ''}> YouTube Retention</option>
                            <option value="tiktok-viral" ${storyArc === 'tiktok-viral' ? 'selected' : ''}> TikTok Viral</option>
                            <option value="problem-solution" ${storyArc === 'problem-solution' ? 'selected' : ''}> Problem-Solution</option>
                            <option value="before-after-bridge" ${storyArc === 'before-after-bridge' ? 'selected' : ''}> Before-After-Bridge</option>
                            <option value="inverted-pyramid" ${storyArc === 'inverted-pyramid' ? 'selected' : ''}> Inverted Pyramid (News)</option>
                            <option value="documentary-observational" ${storyArc === 'documentary-observational' ? 'selected' : ''}> Documentary Observational</option>
                        </select>
                    </div>

                    <!-- Emotional Journey & Tension (side by side) -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                        <div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Emotional Arc</div>
                            <select onchange="setEmotionalJourney(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem; cursor: pointer;">
                                <option value="">Auto</option>
                                <option value="triumph" ${emotionalJourney === 'triumph' ? 'selected' : ''}> Triumph</option>
                                <option value="redemption" ${emotionalJourney === 'redemption' ? 'selected' : ''}> Redemption</option>
                                <option value="cinderella" ${emotionalJourney === 'cinderella' ? 'selected' : ''}> Cinderella</option>
                                <option value="tragedy" ${emotionalJourney === 'tragedy' ? 'selected' : ''}> Tragedy</option>
                                <option value="thriller" ${emotionalJourney === 'thriller' ? 'selected' : ''}> Thriller</option>
                                <option value="mystery" ${emotionalJourney === 'mystery' ? 'selected' : ''}> Mystery</option>
                                <option value="comedy" ${emotionalJourney === 'comedy' ? 'selected' : ''}> Comedy</option>
                                <option value="horror" ${emotionalJourney === 'horror' ? 'selected' : ''}> Horror</option>
                                <option value="educational" ${emotionalJourney === 'educational' ? 'selected' : ''}> Educational</option>
                                <option value="meditative" ${emotionalJourney === 'meditative' ? 'selected' : ''}> Meditative</option>
                            </select>
                        </div>
                        <div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Tension Style</div>
                            <select onchange="setTensionCurve(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem; cursor: pointer;">
                                <option value="">Auto</option>
                                <option value="steady-build" ${tensionCurve === 'steady-build' ? 'selected' : ''}> Steady Build</option>
                                <option value="waves" ${tensionCurve === 'waves' ? 'selected' : ''}> Waves</option>
                                <option value="slow-burn" ${tensionCurve === 'slow-burn' ? 'selected' : ''}> Slow Burn</option>
                                <option value="flat-with-spikes" ${tensionCurve === 'flat-with-spikes' ? 'selected' : ''}> Spikes</option>
                                <option value="escalating-steps" ${tensionCurve === 'escalating-steps' ? 'selected' : ''}> Steps</option>
                                <option value="rollercoaster" ${tensionCurve === 'rollercoaster' ? 'selected' : ''}> Rollercoaster</option>
                                <option value="double-peak" ${tensionCurve === 'double-peak' ? 'selected' : ''}> Double Peak</option>
                            </select>
                        </div>
                    </div>

                    ${narrativePreset ? `
                    <div style="margin-top: 0.75rem; padding: 0.6rem; background: rgba(139,92,246,0.1); border-radius: 0.5rem; border: 1px solid rgba(139,92,246,0.2);">
                        <div style="font-size: 0.65rem; color: #a78bfa;">
                            ${narrativePreset === 'youtube-standard' ? ' Hook in 5s, pattern breaks every 45-60s, strong CTA ending' :
                              narrativePreset === 'tiktok-viral' ? ' Stop the scroll immediately, build to payoff at 80%, loop-worthy ending' :
                              narrativePreset === 'cinematic-short' ? ' Character development focus, slow-burn tension, emotional resolution' :
                              narrativePreset === 'documentary-feature' ? ' Evidence-based reveals, interview integration, reflective ending' :
                              narrativePreset === 'series-episode' ? ' Cliffhanger ending, serial elements, double-peak tension' :
                              narrativePreset === 'commercial-spot' ? ' Brand reveal at 80%, problem-solution arc, strong CTA' :
                              narrativePreset === 'thriller-short' ? ' Twist at 75%, ratcheting tension, revelation climax' :
                              narrativePreset === 'horror-short' ? ' Scares every 45s, flat-with-spikes tension, ambiguous ending' :
                              narrativePreset === 'inspirational' ? ' Transformation arc, escalating emotional peaks, uplifting ending' :
                              ' Optimized narrative structure applied'}
                        </div>
                    </div>
                    ` : ''}

                    <button onclick="analyzeNarrativePacing()" style="width: 100%; margin-top: 0.75rem; padding: 0.65rem; background: linear-gradient(135deg, rgba(139,92,246,0.2), rgba(6,182,212,0.2)); border: 1px solid rgba(139,92,246,0.4); border-radius: 0.5rem; color: white; font-size: 0.75rem; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 0.5rem;"
                            onmouseenter="this.style.background='linear-gradient(135deg, rgba(139,92,246,0.3), rgba(6,182,212,0.3))'"
                            onmouseleave="this.style.background='linear-gradient(135deg, rgba(139,92,246,0.2), rgba(6,182,212,0.2))'">
                        <span></span> Analyze & Optimize Narrative
                    </button>
                </div>
            `;

            // AI Video Model Selection Card
            // MiniMax-Hailuo-2.3 supports both 6s and 10s durations
            const videoModel = state.content.videoModel || { model: 'hailuo-2.3', duration: '10s', resolution: '768p', mode: 'quality' };
            const canUse1080p = videoModel.duration === '6s'; // 1080p only available for 6s
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">AI Video Model</div>
                            <div class="content-card-subtitle">Choose your video generation engine</div>
                        </div>
                    </div>

                    <!-- Model Mode Selection -->
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; margin-top: 0.5rem;">
                        <div onclick="setVideoModelMode('quality')"
                             style="padding: 0.85rem; border-radius: 0.75rem; border: 2px solid ${videoModel.mode === 'quality' ? '#10b981' : 'rgba(255,255,255,0.15)'}; background: ${videoModel.mode === 'quality' ? 'rgba(16, 185, 129, 0.15)' : 'rgba(255,255,255,0.05)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <div style="font-size: 1.25rem; margin-bottom: 0.4rem;"></div>
                            <div style="font-weight: 600; color: ${videoModel.mode === 'quality' ? '#10b981' : 'white'}; font-size: 0.85rem;">Quality</div>
                            <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">Hailuo 2.3<br>Best visuals</div>
                        </div>
                        <div onclick="setVideoModelMode('fast')"
                             style="padding: 0.85rem; border-radius: 0.75rem; border: 2px solid ${videoModel.mode === 'fast' ? '#f59e0b' : 'rgba(255,255,255,0.15)'}; background: ${videoModel.mode === 'fast' ? 'rgba(245, 158, 11, 0.15)' : 'rgba(255,255,255,0.05)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <div style="font-size: 1.25rem; margin-bottom: 0.4rem;"></div>
                            <div style="font-weight: 600; color: ${videoModel.mode === 'fast' ? '#f59e0b' : 'white'}; font-size: 0.85rem;">Fast</div>
                            <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">Hailuo 2.3 Fast<br>50% cheaper</div>
                        </div>
                        <div onclick="setVideoModelMode('continuity')"
                             style="padding: 0.85rem; border-radius: 0.75rem; border: 2px solid ${videoModel.mode === 'continuity' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${videoModel.mode === 'continuity' ? 'rgba(139, 92, 246, 0.15)' : 'rgba(255,255,255,0.05)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <div style="font-size: 1.25rem; margin-bottom: 0.4rem;"></div>
                            <div style="font-weight: 600; color: ${videoModel.mode === 'continuity' ? '#a78bfa' : 'white'}; font-size: 0.85rem;">Continuity</div>
                            <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">Hailuo 02<br>Seamless scenes</div>
                        </div>
                    </div>

                    <!-- Duration & Resolution -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                        <!-- Duration -->
                        <div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Clip Duration</div>
                            <div style="display: flex; gap: 0.5rem;">
                                <div onclick="setVideoModelDuration('6s')"
                                     style="flex: 1; padding: 0.6rem; border-radius: 0.5rem; border: 2px solid ${videoModel.duration === '6s' ? '#06b6d4' : 'rgba(255,255,255,0.15)'}; background: ${videoModel.duration === '6s' ? 'rgba(6, 182, 212, 0.15)' : 'transparent'}; cursor: pointer; text-align: center;">
                                    <div style="font-weight: 600; color: ${videoModel.duration === '6s' ? '#06b6d4' : 'white'}; font-size: 0.9rem;">6s</div>
                                </div>
                                <div onclick="setVideoModelDuration('10s')"
                                     style="flex: 1; padding: 0.6rem; border-radius: 0.5rem; border: 2px solid ${videoModel.duration === '10s' ? '#06b6d4' : 'rgba(255,255,255,0.15)'}; background: ${videoModel.duration === '10s' ? 'rgba(6, 182, 212, 0.15)' : 'transparent'}; cursor: pointer; text-align: center;">
                                    <div style="font-weight: 600; color: ${videoModel.duration === '10s' ? '#06b6d4' : 'white'}; font-size: 0.9rem;">10s</div>
                                </div>
                            </div>
                        </div>

                        <!-- Resolution -->
                        <div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px;">Resolution</div>
                            <div style="display: flex; gap: 0.5rem;">
                                <div onclick="setVideoModelResolution('768p')"
                                     style="flex: 1; padding: 0.6rem; border-radius: 0.5rem; border: 2px solid ${videoModel.resolution === '768p' ? '#06b6d4' : 'rgba(255,255,255,0.15)'}; background: ${videoModel.resolution === '768p' ? 'rgba(6, 182, 212, 0.15)' : 'transparent'}; cursor: pointer; text-align: center;">
                                    <div style="font-weight: 600; color: ${videoModel.resolution === '768p' ? '#06b6d4' : 'white'}; font-size: 0.9rem;">768p</div>
                                </div>
                                <div onclick="setVideoModelResolution('1080p')"
                                     style="flex: 1; padding: 0.6rem; border-radius: 0.5rem; border: 2px solid ${videoModel.resolution === '1080p' && canUse1080p ? '#06b6d4' : 'rgba(255,255,255,0.15)'}; background: ${videoModel.resolution === '1080p' && canUse1080p ? 'rgba(6, 182, 212, 0.15)' : 'transparent'}; cursor: ${canUse1080p ? 'pointer' : 'not-allowed'}; text-align: center; opacity: ${canUse1080p ? '1' : '0.4'};">
                                    <div style="font-weight: 600; color: ${videoModel.resolution === '1080p' && canUse1080p ? '#06b6d4' : 'white'}; font-size: 0.9rem;">1080p</div>
                                    ${!canUse1080p ? '<div style="font-size: 0.55rem; color: rgba(255,255,255,0.4);">6s only</div>' : ''}
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Model Info -->
                    <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(6, 182, 212, 0.1); border-radius: 0.5rem; border: 1px solid rgba(6, 182, 212, 0.2);">
                        <div style="font-size: 0.75rem; color: #06b6d4; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span>
                            <span>
                                <strong>${videoModel.mode === 'quality' ? 'Hailuo 2.3' : videoModel.mode === 'fast' ? 'Hailuo 2.3 Fast' : 'Hailuo 02'}</strong>
                                 ${videoModel.duration} clips @ ${canUse1080p ? videoModel.resolution : '768p'}
                                 ~$${videoModel.mode === 'fast' ? '0.14-0.25' : '0.28-0.49'}/clip
                            </span>
                        </div>
                    </div>
                </div>
            `;

            // Topic Input Card
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Video Topic (Optional)</div>
                            <div class="content-card-subtitle">Describe what your video should be about</div>
                        </div>
                    </div>

                    <div class="topic-input-container">
                        <input type="text"
                               class="topic-input"
                               id="topic-input"
                               placeholder="e.g., 5 habits of successful entrepreneurs"
                               value="${state.content.topic}"
                               onchange="setTopic(this.value)">
            `;

            // Topic suggestions based on niche
            if (selectedNiche && TOPIC_SUGGESTIONS[selectedNiche]) {
                html += '<div class="topic-suggestions">';
                TOPIC_SUGGESTIONS[selectedNiche].forEach(suggestion => {
                    html += `
                        <div class="topic-suggestion" onclick="applyTopicSuggestion('${suggestion}')">
                            ${suggestion}
                        </div>
                    `;
                });
                html += '</div>';
            }

            html += '</div></div>';

            } // End of if (!production.type) - legacy flow

            // Navigation
            html += renderNavButtons(1, isStepComplete(2) ? 3 : null);

            html += '</div>';
            return html;
        }

        // ==========================================
        // 7.7 STEP 3: SCRIPT GENERATION
        // ==========================================
        function renderStep3Script() {
            const hasScript = state.script.scenes && state.script.scenes.length > 0;
            const isGenerating = state.script.status === 'generating';
            const hasError = state.script.status === 'error';

            let html = '<div class="fade-in">';

            // Show error message if generation failed
            if (hasError && state.script.error) {
                html += `
                    <div class="content-card" style="border: 1px solid rgba(239, 68, 68, 0.3); background: rgba(239, 68, 68, 0.1);">
                        <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
                            <div style="font-size: 1.5rem;"></div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: #ef4444; margin-bottom: 0.25rem;">Script Generation Failed</div>
                                <div style="color: rgba(255,255,255,0.7); font-size: 0.9rem;">${state.script.error}</div>
                                <button onclick="state.script.status = 'idle'; state.script.error = null; render();"
                                    style="margin-top: 0.75rem; padding: 0.5rem 1rem; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.5); color: #ef4444; border-radius: 0.5rem; cursor: pointer;">
                                    Try Again
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            // If no script yet (or error), show generation form
            if (!hasScript && !isGenerating) {
                html += renderScriptGenerationForm();
            }
            // If generating, show progress
            else if (isGenerating) {
                html += renderScriptGeneratingState();
            }
            // If script exists, show editor
            else {
                html += renderScriptEditor();
            }

            // Navigation
            html += renderNavButtons(2, hasScript ? 4 : null);

            html += '</div>';
            return html;
        }

        function renderScriptGenerationForm() {
            const niche = VIDEO_NICHES[state.content.niche];
            const style = VIDEO_STYLES[state.content.style];
            const production = state.production;
            const concept = state.concept;
            const selectedConcept = concept?.refinedConcept;
            const improvedData = concept?.improvedData;
            const characterIntel = state.characterIntelligence;

            // Determine if using new production flow
            // COMPREHENSIVE CHECK: Detect ANY concept data from previous steps
            // This includes: selected concept, improved concept, or raw input
            const hasSelectedConcept = selectedConcept && (selectedConcept.title || selectedConcept.logline);
            const hasImprovedConcept = improvedData && (improvedData.improvedConcept || improvedData.hookLine);
            const hasRawConcept = concept?.rawInput && concept.rawInput.length > 20;

            // ==========================================
            // PASS-THROUGH CONCEPT: Auto-create refinedConcept from rawInput
            // When user writes their own concept and clicks Continue directly
            // ==========================================
            if (hasRawConcept && !hasSelectedConcept && !hasImprovedConcept) {
                // Create a pass-through concept from raw input
                const rawInput = concept.rawInput;

                // Extract a title from the first line or first sentence
                const firstLine = rawInput.split('\n')[0].trim();
                const extractedTitle = firstLine.length > 5 && firstLine.length < 100
                    ? firstLine.replace(/[:.\-].*$/, '').trim()
                    : 'Your Direct Concept';

                // Create minimal refinedConcept for pass-through
                state.concept.refinedConcept = {
                    title: extractedTitle,
                    logline: rawInput,  // FULL text, not truncated
                    description: rawInput,
                    isPassThrough: true,  // Flag to indicate direct user input
                    mood: 'cinematic',
                    tone: 'engaging'
                };

                // Also set selectedIdea to 0 to indicate a concept is selected
                if (state.concept.selectedIdea === null) {
                    state.concept.selectedIdea = 0;
                    state.concept.ideas = [state.concept.refinedConcept];
                }

                console.log('[Step 3] Created pass-through concept from raw input:', extractedTitle);
            }

            // Re-check selectedConcept after potential pass-through creation
            const effectiveSelectedConcept = state.concept?.refinedConcept || selectedConcept;
            const effectiveHasSelectedConcept = effectiveSelectedConcept && (effectiveSelectedConcept.title || effectiveSelectedConcept.logline);

            // usingNewFlow = ONLY when we have a FULL selected concept (with title)
            // This ensures the new flow block can safely access selectedConcept properties
            const usingNewFlow = effectiveHasSelectedConcept;

            // hasAnyConcept = we have SOME concept data to show (even if not full)
            const hasAnyConcept = effectiveHasSelectedConcept || hasImprovedConcept || hasRawConcept;

            // AUTO-POPULATE TOPIC: Always derive from available data
            // This ensures the Script step is always connected to previous steps
            // CRITICAL: Use FULL text for pass-through concepts, not truncated
            if (!state.content.topic || state.content.topic.trim() === '') {
                if (effectiveSelectedConcept?.title) {
                    // Best: Use selected concept title + logline (full text for pass-through)
                    const logline = effectiveSelectedConcept.logline || effectiveSelectedConcept.description || '';
                    state.content.topic = effectiveSelectedConcept.isPassThrough
                        ? logline  // Pass-through: use FULL text
                        : effectiveSelectedConcept.title + ': ' + logline;
                } else if (improvedData?.improvedConcept) {
                    // Fallback: Use AI-improved concept text (full text)
                    state.content.topic = improvedData.improvedConcept;
                } else if (concept?.rawInput) {
                    // Last resort: Use raw user input (FULL text, no truncation!)
                    state.content.topic = concept.rawInput;
                }
            }

            // BUILD DISPLAY DATA: Compile all concept info for display
            // Even in legacy flow, show what we know
            const isPassThrough = effectiveSelectedConcept?.isPassThrough === true;
            const displayTitle = effectiveSelectedConcept?.title || (improvedData?.hookLine ? 'Your Concept' : (hasRawConcept ? 'Your Direct Concept' : null));
            const displayLogline = effectiveSelectedConcept?.logline || effectiveSelectedConcept?.description || improvedData?.improvedConcept || concept?.rawInput || '';
            const displayMood = effectiveSelectedConcept?.mood || improvedData?.suggestedMood || null;
            const displayTone = effectiveSelectedConcept?.tone || improvedData?.suggestedTone || null;

            return `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Generate Your Script</div>
                            <div class="content-card-subtitle">AI will create a professional ${usingNewFlow ? 'cinematic' : 'video'} script based on your settings</div>
                        </div>
                    </div>

                    ${usingNewFlow ? `
                    <!-- NEW FLOW: Selected Concept Summary (supports pass-through concepts) -->
                    <div style="background: linear-gradient(135deg, ${isPassThrough ? 'rgba(16, 185, 129, 0.15), rgba(6, 182, 212, 0.1)' : 'rgba(139, 92, 246, 0.15), rgba(6, 182, 212, 0.1)'}); border: 1px solid ${isPassThrough ? 'rgba(16, 185, 129, 0.4)' : 'rgba(139, 92, 246, 0.4)'}; border-radius: 0.75rem; padding: 1.25rem; margin-bottom: 1.5rem;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                            <div>
                                <div style="font-size: 0.7rem; color: ${isPassThrough ? 'rgba(16, 185, 129, 0.8)' : 'rgba(139, 92, 246, 0.8)'}; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">
                                    ${isPassThrough ? ' Your Direct Concept' : 'Selected Concept'}
                                </div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: white;">${effectiveSelectedConcept.title || 'Untitled Concept'}</div>
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                ${isPassThrough ? `<span style="font-size: 0.65rem; padding: 0.2rem 0.5rem; background: rgba(16, 185, 129, 0.3); border-radius: 0.25rem; color: #6ee7b7;"> Pass-through</span>` : ''}
                                ${production?.typeConfig ? `<span style="font-size: 0.65rem; padding: 0.2rem 0.5rem; background: rgba(139, 92, 246, 0.3); border-radius: 0.25rem; color: #a78bfa;">${production.typeConfig.icon || ''} ${production.typeConfig.name}</span>` : ''}
                                ${production?.subTypeConfig ? `<span style="font-size: 0.65rem; padding: 0.2rem 0.5rem; background: rgba(236, 72, 153, 0.3); border-radius: 0.25rem; color: #f472b6;">${production.subTypeConfig.name}</span>` : ''}
                            </div>
                        </div>
                        <!-- Concept content with expand/collapse for long text -->
                        <div id="concept-display-content" style="font-size: 0.85rem; color: rgba(255,255,255,0.8); line-height: 1.5; margin-bottom: 1rem; ${isPassThrough && displayLogline.length > 300 ? 'max-height: 150px; overflow: hidden; position: relative;' : ''}">
                            ${isPassThrough ? displayLogline.replace(/\n/g, '<br>') : (effectiveSelectedConcept.logline || effectiveSelectedConcept.description || '')}
                            ${isPassThrough && displayLogline.length > 300 ? `<div style="position: absolute; bottom: 0; left: 0; right: 0; height: 40px; background: linear-gradient(transparent, rgba(30,30,50,0.95));"></div>` : ''}
                        </div>
                        ${isPassThrough && displayLogline.length > 300 ? `
                        <button onclick="toggleConceptDisplay()" id="concept-toggle-btn" style="font-size: 0.75rem; padding: 0.35rem 0.75rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.35rem; color: #6ee7b7; cursor: pointer; margin-bottom: 0.75rem;">
                            Show Full Concept 
                        </button>
                        ` : ''}
                        ${effectiveSelectedConcept.uniqueElements?.length > 0 ? `
                        <div style="display: flex; flex-wrap: wrap; gap: 0.35rem; margin-bottom: 0.75rem;">
                            ${effectiveSelectedConcept.uniqueElements.map(elem => `
                                <span style="font-size: 0.65rem; padding: 0.2rem 0.5rem; background: rgba(6, 182, 212, 0.2); border: 1px solid rgba(6, 182, 212, 0.4); border-radius: 0.25rem; color: #67e8f9;">${elem}</span>
                            `).join('')}
                        </div>
                        ` : ''}
                        <div style="display: flex; gap: 1rem; font-size: 0.75rem; color: rgba(255,255,255,0.6);">
                            ${effectiveSelectedConcept.mood ? `<span>Mood: <span style="color: #a78bfa;">${effectiveSelectedConcept.mood}</span></span>` : ''}
                            ${effectiveSelectedConcept.tone ? `<span>Tone: <span style="color: #f472b6;">${effectiveSelectedConcept.tone}</span></span>` : ''}
                            ${formatDuration(production?.targetDuration || state.platform.targetDuration) ? `<span>Duration: <span style="color: #67e8f9;">${formatDuration(production?.targetDuration || state.platform.targetDuration)}</span></span>` : ''}
                            ${isPassThrough ? `<span style="margin-left: auto; color: rgba(16, 185, 129, 0.7);">${displayLogline.length} chars</span>` : ''}
                        </div>
                    </div>

                    ${improvedData ? `
                    <!-- AI Enhancement Details -->
                    <div style="background: rgba(236, 72, 153, 0.1); border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 0.75rem; padding: 1rem; margin-bottom: 1.5rem;">
                        <div style="font-size: 0.7rem; color: rgba(236, 72, 153, 0.8); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> AI Enhancement Applied
                        </div>
                        ${improvedData.hookLine ? `<div style="font-style: italic; color: rgba(255,255,255,0.9); margin-bottom: 0.5rem;">"${improvedData.hookLine}"</div>` : ''}
                        <div style="display: flex; flex-wrap: wrap; gap: 0.75rem; font-size: 0.7rem; color: rgba(255,255,255,0.7);">
                            ${improvedData.genreFusion ? `<span><span style="color: #f472b6;">Genre:</span> ${improvedData.genreFusion}</span>` : ''}
                            ${improvedData.visualSignature ? `<span><span style="color: #8b5cf6;">Visual:</span> ${improvedData.visualSignature.substring(0, 60)}...</span>` : ''}
                        </div>
                        ${improvedData.characters?.length > 0 ? `
                        <div style="margin-top: 0.75rem; font-size: 0.7rem;">
                            <span style="color: rgba(255,255,255,0.5);">Characters:</span>
                            <span style="color: rgba(255,255,255,0.8);"> ${improvedData.characters.map(c => c.archetype).join(', ')}</span>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}

                    ${characterIntel?.suggestedCount > 0 ? `
                    <!-- Character Intelligence Summary -->
                    <div style="background: rgba(6, 182, 212, 0.1); border: 1px solid rgba(6, 182, 212, 0.3); border-radius: 0.75rem; padding: 0.75rem 1rem; margin-bottom: 1.5rem; display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                            <span style="color: #67e8f9;"> Character Intelligence:</span>
                            ${characterIntel.suggestedCount} characters  ${characterIntel.narrationMode || 'voiceover'} mode
                        </div>
                        <button onclick="goToStep(2)" style="font-size: 0.65rem; padding: 0.25rem 0.5rem; background: rgba(6, 182, 212, 0.2); border: 1px solid rgba(6, 182, 212, 0.4); border-radius: 0.25rem; color: #67e8f9; cursor: pointer;">
                            Edit
                        </button>
                    </div>
                    ` : ''}
                    ` : `
                    <!-- FLOW: Show concept data if available, otherwise basic config -->
                    ${displayTitle || displayLogline ? `
                    <!-- We have SOME concept data - show it! -->
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.12), rgba(6, 182, 212, 0.08)); border: 1px solid rgba(139, 92, 246, 0.35); border-radius: 0.75rem; padding: 1.25rem; margin-bottom: 1.5rem;">
                        <div style="font-size: 0.7rem; color: rgba(139, 92, 246, 0.8); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">Your Concept</div>
                        ${displayTitle ? `<div style="font-size: 1.05rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">${displayTitle}</div>` : ''}
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.8); line-height: 1.5; margin-bottom: 0.75rem;">
                            ${displayLogline}
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.6);">
                            ${displayMood ? `<span>Mood: <span style="color: #a78bfa;">${displayMood}</span></span>` : ''}
                            ${displayTone ? `<span>Tone: <span style="color: #f472b6;">${displayTone}</span></span>` : ''}
                            ${state.platform.selected ? `<span>Platform: <span style="color: #67e8f9;">${state.platform.selected}</span></span>` : ''}
                            ${formatDuration(state.platform.targetDuration) ? `<span>Duration: <span style="color: #67e8f9;">${formatDuration(state.platform.targetDuration)}</span></span>` : ''}
                        </div>
                    </div>
                    ` : `
                    <!-- No concept data - show basic config -->
                    <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.75rem; padding: 1rem; margin-bottom: 1.5rem;">
                        <div style="font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Your video configuration:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            <span class="config-tag">${state.platform.selected || 'Platform'}</span>
                            <span class="config-tag">${state.platform.aspectRatio || '16:9'}</span>
                            <span class="config-tag">${formatDuration(state.platform.targetDuration)}</span>
                            <span class="config-tag">${niche?.icon || ''} ${niche?.name || 'Niche'}</span>
                            <span class="config-tag">${style?.icon || ''} ${style?.name || 'Style'}</span>
                        </div>
                    </div>
                    `}

                    <!-- Topic input - shows as readonly if we have concept data, editable otherwise -->
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                            Video Topic ${state.content.topic ? '<span style="font-size: 0.7rem; color: rgba(139, 92, 246, 0.7); font-weight: 400;">(from your concept)</span>' : ''}
                        </label>
                        <input type="text"
                               id="script-topic"
                               class="topic-input"
                               value="${state.content.topic || ''}"
                               placeholder="e.g., 5 Morning Habits That Changed My Life"
                               style="width: 100%; ${state.content.topic ? 'background: rgba(139, 92, 246, 0.1); border-color: rgba(139, 92, 246, 0.3);' : ''}">
                    </div>
                    `}

                    <!-- Hidden input to store topic for new flow (already populated from available concept data) -->
                    ${usingNewFlow ? `<input type="hidden" id="script-topic" value="${state.content.topic || ''}">` : ''}

                    <!-- Tone selector -->
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                            Script Tone
                        </label>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                            ${['engaging', 'professional', 'casual', 'inspirational'].map(tone => `
                                <button onclick="setScriptTone('${tone}')"
                                        class="tone-btn ${state.content.tone === tone ? 'selected' : ''}"
                                        style="padding: 0.6rem; border-radius: 0.5rem; border: 1px solid ${state.content.tone === tone ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.2)'}; background: ${state.content.tone === tone ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; color: white; cursor: pointer; font-size: 0.8rem; text-transform: capitalize;">
                                    ${tone}
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Content depth selector -->
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                            Content Depth
                            <span style="color: rgba(255,255,255,0.5); font-weight: 400; font-size: 0.8rem;">  How much detail in the narration</span>
                        </label>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                            ${[
                                { id: 'minimal', label: ' Quick', desc: 'Key points only' },
                                { id: 'standard', label: ' Standard', desc: 'Balanced content' },
                                { id: 'detailed', label: ' Detailed', desc: 'Examples & stats' },
                                { id: 'comprehensive', label: ' Deep Dive', desc: 'Full analysis' }
                            ].map(depth => `
                                <button onclick="setContentDepth('${depth.id}')"
                                        title="${depth.desc}"
                                        style="padding: 0.6rem 0.4rem; border-radius: 0.5rem; border: 1px solid ${state.content.contentDepth === depth.id ? 'rgba(6, 182, 212, 0.6)' : 'rgba(255,255,255,0.2)'}; background: ${state.content.contentDepth === depth.id ? 'rgba(6, 182, 212, 0.2)' : 'rgba(255,255,255,0.05)'}; color: white; cursor: pointer; font-size: 0.75rem; display: flex; flex-direction: column; align-items: center; gap: 0.2rem;">
                                    <span style="font-size: 0.85rem;">${depth.label}</span>
                                    <span style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">${depth.desc}</span>
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Additional instructions -->
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                            Additional Instructions <span style="color: rgba(255,255,255,0.5); font-weight: 400;">(optional)</span>
                        </label>
                        <textarea id="script-instructions"
                                  placeholder="Any specific requirements? e.g., Include a personal story, mention specific products, focus on beginners..."
                                  style="width: 100%; min-height: 80px; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem; resize: vertical;"></textarea>
                    </div>

                    <!-- Generate button -->
                    <button onclick="generateScript()"
                            class="generate-btn"
                            style="width: 100%; padding: 1rem; border-radius: 0.75rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-size: 1rem; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                        <span></span>
                        <span>Generate Script with AI</span>
                    </button>

                    <div style="text-align: center; margin-top: 1rem; color: rgba(255,255,255,0.5); font-size: 0.8rem;">
                        Estimated cost: ~5 tokens  Powered by GPT-4o
                    </div>
                </div>
            `;
        }

        function renderScriptGeneratingState() {
            return `
                <div class="content-card" style="text-align: center; padding: 4rem 2rem;">
                    <div class="animate-float" style="font-size: 4rem; margin-bottom: 1.5rem;"></div>
                    <div style="font-size: 1.25rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                        Generating Your Script...
                    </div>
                    <div style="color: rgba(255,255,255,0.6); margin-bottom: 2rem;">
                        AI is crafting an engaging script for your video
                    </div>
                    <div class="loading-bar" style="width: 200px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; margin: 0 auto; overflow: hidden;">
                        <div style="width: 30%; height: 100%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); border-radius: 2px; animation: shimmer 1.5s infinite;"></div>
                    </div>
                </div>
            `;
        }

        function renderScriptEditor() {
            const script = state.script;

            // Calculate timing breakdown
            const targetDuration = state.platform.targetDuration || 60;
            const totalVisualDuration = script.scenes.reduce((sum, s) => sum + (s.visualDuration || s.duration || 0), 0);
            const totalNarrationDuration = script.scenes.reduce((sum, s) => sum + (s.narrationDuration || Math.ceil((s.narration || '').split(/\s+/).length / 2.5) || 0), 0);
            const pacing = script.timing?.pacing || state.content.pacing || 'medium';

            let html = `
                <!-- Script Header -->
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div style="flex: 1;">
                            <input type="text"
                                   id="script-title-input"
                                   value="${script.title || ''}"
                                   onchange="updateScriptTitle(this.value)"
                                   style="background: none; border: none; color: white; font-size: 1.1rem; font-weight: 700; width: 100%; outline: none;">
                            <div class="content-card-subtitle">${script.scenes.length} scenes  Target: ${formatDuration(targetDuration)}</div>
                        </div>
                        <button onclick="openFullScriptModal()"
                                style="background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; padding: 0.5rem 1rem; color: white; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 0.3rem;">
                            <span></span> Full Script
                        </button>
                        <button onclick="regenerateFullScript()"
                                style="background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.5rem; padding: 0.5rem 1rem; color: white; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 0.3rem;">
                            <span></span> Regenerate
                        </button>
                    </div>

                    <!-- Timing Breakdown Banner -->
                    <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.5rem; padding: 0.75rem 1rem; margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
                        <div style="display: flex; gap: 1.5rem; flex-wrap: wrap;">
                            <div style="text-align: center;">
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); text-transform: uppercase;">Visual Time</div>
                                <div style="font-size: 1rem; font-weight: 700; color: #10b981;">${formatDuration(totalVisualDuration)}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); text-transform: uppercase;">Narration</div>
                                <div style="font-size: 1rem; font-weight: 700; color: #a78bfa;">${formatDuration(totalNarrationDuration)}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); text-transform: uppercase;">Per Scene</div>
                                <div style="font-size: 1rem; font-weight: 700; color: white;">~${Math.round(totalVisualDuration / script.scenes.length)}s</div>
                            </div>
                        </div>
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.6); display: flex; align-items: center; gap: 0.3rem;">
                            <span></span> ${pacing.charAt(0).toUpperCase() + pacing.slice(1)} pacing
                        </div>
                    </div>

                    <!-- Hook -->
                    <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.75rem; padding: 1rem; margin-bottom: 1rem;">
                        <div style="font-size: 0.75rem; color: #10b981; font-weight: 600; margin-bottom: 0.5rem;"> HOOK</div>
                        <input type="text"
                               value="${script.hook || ''}"
                               onchange="updateScriptHook(this.value)"
                               style="width: 100%; background: none; border: none; color: white; font-size: 0.95rem; outline: none;">
                    </div>

                    <!-- Metadata -->
                    ${script.metadata ? `
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; margin-bottom: 1rem;">
                            <div style="background: rgba(255,255,255,0.05); border-radius: 0.5rem; padding: 0.75rem;">
                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Target Audience</div>
                                <div style="font-size: 0.85rem; color: white;">${script.metadata.targetAudience || '-'}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.05); border-radius: 0.5rem; padding: 0.75rem;">
                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Key Message</div>
                                <div style="font-size: 0.85rem; color: white;">${script.metadata.keyMessage || '-'}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.05); border-radius: 0.5rem; padding: 0.75rem;">
                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Suggested Music</div>
                                <div style="font-size: 0.85rem; color: white;">${script.metadata.suggestedMusic || '-'}</div>
                            </div>
                        </div>
                    ` : ''}
                </div>

                <!-- PHASE 4: Voice & Dialogue Status Panel -->
                ${(() => {
                    const voiceAssignments = script.voiceAssignments || {};
                    const characters = script.characters || [];
                    const allScenes = script.scenes || [];

                    // Collect dialogue info from all scenes
                    const scenesWithDialogue = allScenes.filter(s => s.audioLayer?.dialogue?.length > 0);
                    const totalDialogueLines = allScenes.reduce((sum, s) => sum + (s.audioLayer?.dialogue?.length || 0), 0);
                    const uniqueSpeakers = [...new Set(allScenes.flatMap(s => s.audioLayer?.dialogue?.map(d => d.character) || []))];
                    const assignedVoices = uniqueSpeakers.filter(name => voiceAssignments[name]?.voiceProfileId);
                    const unassignedVoices = uniqueSpeakers.filter(name => !voiceAssignments[name]?.voiceProfileId);

                    // Skip if no dialogue in the script
                    if (totalDialogueLines === 0 && characters.length === 0) return '';

                    const allAssigned = unassignedVoices.length === 0 && uniqueSpeakers.length > 0;
                    const statusColor = allAssigned ? '#22c55e' : '#fbbf24';
                    const statusIcon = allAssigned ? '[OK]' : '[!]';
                    const statusText = allAssigned ? 'All voices assigned' : unassignedVoices.length + ' voice' + (unassignedVoices.length > 1 ? 's' : '') + ' pending';
                    const statusBgRgb = allAssigned ? '34, 197, 94' : '251, 191, 36';

                    const speakersHtml = uniqueSpeakers.map(name => {
                        const voice = voiceAssignments[name];
                        const hasVoice = voice?.voiceProfileId;
                        const bgRgb = hasVoice ? '34, 197, 94' : '251, 191, 36';
                        const iconColor = hasVoice ? '#22c55e' : '#fbbf24';
                        const voiceName = hasVoice ? (voice.voiceProfile?.name || voice.voiceProfileId) : '';
                        return '<div style="display: flex; align-items: center; gap: 0.3rem; padding: 0.3rem 0.6rem; background: rgba(' + bgRgb + ', 0.1); border: 1px solid rgba(' + bgRgb + ', 0.3); border-radius: 0.3rem;">' +
                            '<span style="font-size: 0.7rem; color: ' + iconColor + ';">' + (hasVoice ? '[OK]' : 'o') + '</span>' +
                            '<span style="font-size: 0.7rem; color: white; font-weight: 500;">' + name + '</span>' +
                            (hasVoice ? '<span style="font-size: 0.6rem; color: rgba(255,255,255,0.5);"> - ' + voiceName + '</span>' : '') +
                        '</div>';
                    }).join('');

                    const pendingHtml = !allAssigned && uniqueSpeakers.length > 0
                        ? '<div style="margin-top: 0.6rem; padding: 0.5rem 0.75rem; background: rgba(251, 191, 36, 0.08); border-radius: 0.4rem; font-size: 0.65rem; color: rgba(255,255,255,0.6);">Voices will be auto-assigned during shot decomposition based on character archetypes</div>'
                        : '';

                    return '<div class="content-card" style="background: rgba(139, 92, 246, 0.05); border: 1px solid rgba(139, 92, 246, 0.2);">' +
                        '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">' +
                            '<div style="display: flex; align-items: center; gap: 0.5rem;">' +
                                '<span style="font-size: 1.1rem;"></span>' +
                                '<span style="font-size: 0.9rem; font-weight: 600; color: white;">Voice & Dialogue Status</span>' +
                            '</div>' +
                            '<div style="display: flex; align-items: center; gap: 0.35rem; padding: 0.3rem 0.6rem; background: rgba(' + statusBgRgb + ', 0.15); border: 1px solid rgba(' + statusBgRgb + ', 0.3); border-radius: 0.4rem;">' +
                                '<span style="font-size: 0.75rem;">' + statusIcon + '</span>' +
                                '<span style="font-size: 0.7rem; color: ' + statusColor + '; font-weight: 500;">' + statusText + '</span>' +
                            '</div>' +
                        '</div>' +
                        '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-bottom: 0.75rem;">' +
                            '<div style="background: rgba(251, 191, 36, 0.1); padding: 0.6rem; border-radius: 0.5rem; text-align: center;">' +
                                '<div style="font-size: 1.2rem; font-weight: 700; color: #fbbf24;">' + totalDialogueLines + '</div>' +
                                '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">Dialogue Lines</div>' +
                            '</div>' +
                            '<div style="background: rgba(167, 139, 250, 0.1); padding: 0.6rem; border-radius: 0.5rem; text-align: center;">' +
                                '<div style="font-size: 1.2rem; font-weight: 700; color: #a78bfa;">' + uniqueSpeakers.length + '</div>' +
                                '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">Speakers</div>' +
                            '</div>' +
                            '<div style="background: rgba(34, 197, 94, 0.1); padding: 0.6rem; border-radius: 0.5rem; text-align: center;">' +
                                '<div style="font-size: 1.2rem; font-weight: 700; color: #22c55e;">' + assignedVoices.length + '</div>' +
                                '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">Voices Assigned</div>' +
                            '</div>' +
                            '<div style="background: rgba(59, 130, 246, 0.1); padding: 0.6rem; border-radius: 0.5rem; text-align: center;">' +
                                '<div style="font-size: 1.2rem; font-weight: 700; color: #3b82f6;">' + scenesWithDialogue.length + '</div>' +
                                '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">Scenes w/ Dialogue</div>' +
                            '</div>' +
                        '</div>' +
                        '<div style="display: flex; flex-wrap: wrap; gap: 0.4rem;">' + speakersHtml + '</div>' +
                        pendingHtml +
                    '</div>';
                })()}

                <!-- Scenes -->
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Scenes</div>
                            <div class="content-card-subtitle">Edit narration and visuals for each scene</div>
                        </div>
                        <button onclick="addNewScene()"
                                style="background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; padding: 0.5rem 1rem; color: white; cursor: pointer; font-size: 0.8rem;">
                            + Add Scene
                        </button>
                    </div>

                    <div class="scenes-list" style="display: flex; flex-direction: column; gap: 1rem;">
            `;

            // Render each scene
            script.scenes.forEach((scene, index) => {
                html += renderSceneCard(scene, index);
            });

            html += `
                    </div>
                </div>

                <!-- CTA -->
                <div class="content-card">
                    <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.75rem; padding: 1rem;">
                        <div style="font-size: 0.75rem; color: #ef4444; font-weight: 600; margin-bottom: 0.5rem;"> CALL TO ACTION</div>
                        <input type="text"
                               value="${script.cta || ''}"
                               onchange="updateScriptCTA(this.value)"
                               style="width: 100%; background: none; border: none; color: white; font-size: 0.95rem; outline: none;">
                    </div>
                </div>
            `;

            return html;
        }

        function renderSceneCard(scene, index) {
            const isExpanded = state.script.expandedScene === scene.id;
            const hasNarration = scene.hasNarration !== false && scene.narration && scene.narration.trim() !== '';
            const visualPrompt = scene.visualPrompt || scene.visual || '';
            // PHASE 1: Check for character dialogue from audioLayer
            const hasDialogue = scene.audioLayer?.dialogue?.length > 0;
            const dialogueCount = scene.audioLayer?.dialogue?.length || 0;
            const audioType = scene.audioLayer?.type || (hasNarration ? 'voiceover' : 'music_only');

            // PHASE 3: Get unique speakers and their voices
            const uniqueSpeakers = hasDialogue ?
                [...new Set(scene.audioLayer.dialogue.map(d => d.character))] : [];
            const speakerCount = uniqueSpeakers.length;

            // PHASE 4: Get voice assignments for speakers
            const voiceAssignments = state.script?.voiceAssignments || {};
            const speakerVoices = uniqueSpeakers.map(name => ({
                name,
                voice: voiceAssignments[name] || null
            }));

            // PHASE 2: Duration classification
            const durationClass = scene.duration <= 20 ? 'short' :
                                  scene.duration <= 40 ? 'medium' : 'long';
            const durationColor = durationClass === 'short' ? '#22c55e' :
                                  durationClass === 'medium' ? '#eab308' : '#f97316';

            // Check if scene has been decomposed into shots
            const decomposed = state.storyboard?.multiShotMode?.decomposedScenes?.[scene.id];
            const hasShots = decomposed?.status === 'ready' && decomposed?.shots?.length > 0;
            const shotCount = decomposed?.shots?.length || 0;

            return `
                <div class="scene-card" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.75rem; overflow: hidden;">
                    <!-- Scene Header -->
                    <div onclick="toggleSceneExpand(${scene.id})"
                         style="padding: 1rem; cursor: pointer; display: flex; align-items: center; gap: 1rem; border-bottom: ${isExpanded ? '1px solid rgba(255,255,255,0.1)' : 'none'};">
                        <!-- Scene Number with Audio Type Indicator -->
                        <div style="position: relative;">
                            <div style="width: 2rem; height: 2rem; background: linear-gradient(135deg, ${hasDialogue ? '#fbbf24, #f59e0b' : hasNarration ? '#8b5cf6, #06b6d4' : '#6b7280, #4b5563'}); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.85rem;">
                                ${index + 1}
                            </div>
                            ${hasDialogue ? `<div style="position: absolute; bottom: -2px; right: -2px; width: 12px; height: 12px; background: #fbbf24; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 7px; border: 2px solid #1a1a2e;"></div>` : ''}
                            ${hasShots ? `<div style="position: absolute; top: -2px; right: -2px; width: 12px; height: 12px; background: #22c55e; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 7px; border: 2px solid #1a1a2e; color: white;">${shotCount}</div>` : ''}
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="color: white; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${hasDialogue ?
                                    `<span style="color: #fbbf24;"> ${scene.audioLayer.dialogue[0].character}:</span> "${scene.audioLayer.dialogue[0].line?.substring(0, 40)}${scene.audioLayer.dialogue[0].line?.length > 40 ? '...' : ''}"` :
                                    hasNarration ?
                                        (scene.narration?.substring(0, 60) + (scene.narration?.length > 60 ? '...' : '')) :
                                        '<span style="color: rgba(255,255,255,0.4); font-style: italic;"> Music only (no voiceover)</span>'
                                }
                            </div>
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.75rem; display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                                <!-- Duration with color coding -->
                                <span style="color: ${durationColor};">${scene.duration}s</span>
                                <span> ${scene.transition || 'cut'}</span>
                                ${scene.mood ? `<span> ${scene.mood}</span>` : ''}
                                <!-- Dialogue count badge -->
                                ${hasDialogue ? `<span style="font-size: 0.6rem; padding: 0.1rem 0.35rem; background: rgba(251, 191, 36, 0.2); color: #fbbf24; border-radius: 0.2rem;">${dialogueCount} line${dialogueCount > 1 ? 's' : ''}</span>` : ''}
                                <!-- Speaker count badge (Phase 4) -->
                                ${speakerCount > 1 ? `<span style="font-size: 0.6rem; padding: 0.1rem 0.35rem; background: rgba(167, 139, 250, 0.2); color: #a78bfa; border-radius: 0.2rem;"> ${speakerCount} voices</span>` : ''}
                                <!-- Shot decomposition status -->
                                ${hasShots ? `<span style="font-size: 0.6rem; padding: 0.1rem 0.35rem; background: rgba(34, 197, 94, 0.2); color: #22c55e; border-radius: 0.2rem;"> ${shotCount} shots</span>` : ''}
                                <!-- Audio type indicator -->
                                ${scene.audioLayer ? `<span style="font-size: 0.55rem; color: rgba(255,255,255,0.3);">[${audioType}]</span>` : ''}
                            </div>
                            <!-- PHASE 4: Speaker Voice Badges (compact view) -->
                            ${speakerCount > 0 ? `
                                <div style="display: flex; gap: 0.25rem; margin-top: 0.3rem; flex-wrap: wrap;">
                                    ${speakerVoices.slice(0, 3).map(sv => `
                                        <span style="font-size: 0.5rem; padding: 0.1rem 0.25rem; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.3); color: #c4b5fd; border-radius: 0.15rem;">
                                            ${sv.name}${sv.voice?.voiceProfile?.name ? `  ${sv.voice.voiceProfile.name}` : ''}
                                        </span>
                                    `).join('')}
                                    ${speakerCount > 3 ? `<span style="font-size: 0.5rem; color: rgba(255,255,255,0.4);">+${speakerCount - 3} more</span>` : ''}
                                </div>
                            ` : ''}
                        </div>
                        <div style="color: rgba(255,255,255,0.5); transform: rotate(${isExpanded ? '180deg' : '0deg'}); transition: transform 0.2s;"></div>
                    </div>

                    ${isExpanded ? `
                        <!-- Expanded Content -->
                        <div style="padding: 1rem;">
                            <!-- Visual Prompt (What we SEE) -->
                            <div style="margin-bottom: 1rem;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <label style="font-size: 0.75rem; color: rgba(255,255,255,0.6);"> Visual Prompt</label>
                                    <span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(6,182,212,0.2); color: #06b6d4; border-radius: 0.25rem;">What we SEE</span>
                                </div>
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.4rem;">Describe the visual scene for AI video generation. Include camera movement, lighting, mood.</div>
                                <textarea id="scene-visual-${scene.id}"
                                          onchange="updateSceneVisual(${scene.id}, this.value)"
                                          placeholder="[Push in] A man stands at a rain-soaked window, his reflection fractured by droplets. Dim blue lighting, contemplative mood."
                                          style="width: 100%; min-height: 80px; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(6,182,212,0.3); background: rgba(6,182,212,0.05); color: white; font-size: 0.9rem; resize: vertical;">${visualPrompt}</textarea>
                            </div>

                            <!-- Narration Toggle + Text (What we HEAR) -->
                            <div style="margin-bottom: 1rem;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <label style="font-size: 0.75rem; color: rgba(255,255,255,0.6);"> Voiceover</label>
                                        <span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(139,92,246,0.2); color: #a78bfa; border-radius: 0.25rem;">What we HEAR</span>
                                    </div>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.7rem; color: rgba(255,255,255,0.5);">
                                        <input type="checkbox" ${hasNarration ? 'checked' : ''} onchange="toggleSceneNarration(${scene.id}, this.checked)" style="cursor: pointer;">
                                        Has voiceover
                                    </label>
                                </div>
                                ${hasNarration ? `
                                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.4rem;">What the narrator says. Should complement the visuals, NOT describe them literally.</div>
                                    <textarea id="scene-narration-${scene.id}"
                                              onchange="updateSceneNarration(${scene.id}, this.value)"
                                              placeholder="In moments like these, clarity emerges. When the noise fades, truth remains."
                                              style="width: 100%; min-height: 60px; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(139,92,246,0.3); background: rgba(139,92,246,0.05); color: white; font-size: 0.9rem; resize: vertical;">${scene.narration || ''}</textarea>
                                ` : `
                                    <div style="padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 0.5rem; border: 1px dashed rgba(255,255,255,0.2); text-align: center;">
                                        <div style="font-size: 0.8rem; color: rgba(255,255,255,0.4);"> Music/ambient only - no voiceover for this scene</div>
                                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.3); margin-top: 0.25rem;">Great for cinematic moments or letting visuals breathe</div>
                                    </div>
                                `}
                            </div>

                            <!-- PHASE 1 + PHASE 4: Character Dialogue Display with Voice Info -->
                            ${scene.audioLayer?.dialogue?.length > 0 ? `
                                <div style="margin-bottom: 1rem;">
                                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <label style="font-size: 0.75rem; color: rgba(255,255,255,0.6);"> Character Dialogue</label>
                                            <span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(251, 191, 36, 0.2); color: #fbbf24; border-radius: 0.25rem;">${scene.audioLayer.dialogue.length} line${scene.audioLayer.dialogue.length > 1 ? 's' : ''}</span>
                                            <span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(167, 139, 250, 0.2); color: #a78bfa; border-radius: 0.25rem;"> ${speakerCount} voice${speakerCount > 1 ? 's' : ''}</span>
                                        </div>
                                        <!-- Estimated dialogue duration -->
                                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">
                                            ~${Math.ceil(scene.audioLayer.dialogue.reduce((sum, d) => sum + (d.line?.split(' ').length || 0), 0) / 2.5)}s speaking time
                                        </span>
                                    </div>
                                    <div style="background: rgba(251, 191, 36, 0.05); border: 1px solid rgba(251, 191, 36, 0.2); border-radius: 0.5rem; padding: 0.75rem; max-height: 200px; overflow-y: auto;">
                                        ${scene.audioLayer.dialogue.map((d, dIdx) => {
                                            const charVoice = voiceAssignments[d.character];
                                            return `
                                            <div style="margin-bottom: ${dIdx < scene.audioLayer.dialogue.length - 1 ? '0.5rem' : '0'}; padding-bottom: ${dIdx < scene.audioLayer.dialogue.length - 1 ? '0.5rem' : '0'}; border-bottom: ${dIdx < scene.audioLayer.dialogue.length - 1 ? '1px solid rgba(255,255,255,0.1)' : 'none'};">
                                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.2rem; flex-wrap: wrap;">
                                                    <span style="font-size: 0.75rem; font-weight: 600; color: #fbbf24;">${d.character || 'Character'}</span>
                                                    ${charVoice?.voiceProfile?.name ? `<span style="font-size: 0.5rem; padding: 0.1rem 0.25rem; background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.3); color: #c4b5fd; border-radius: 0.15rem;">${charVoice.voiceProfile.name}</span>` : ''}
                                                    ${d.emotion ? `<span style="font-size: 0.55rem; padding: 0.1rem 0.3rem; background: rgba(255,255,255,0.1); border-radius: 0.2rem; color: rgba(255,255,255,0.5);">${d.emotion}</span>` : ''}
                                                    ${d.delivery ? `<span style="font-size: 0.55rem; padding: 0.1rem 0.3rem; background: rgba(6, 182, 212, 0.1); border-radius: 0.2rem; color: rgba(6, 182, 212, 0.7);">${d.delivery}</span>` : ''}
                                                </div>
                                                <div style="font-size: 0.85rem; color: rgba(255,255,255,0.8); font-style: italic; line-height: 1.4;">"${d.line || ''}"</div>
                                                <div style="font-size: 0.5rem; color: rgba(255,255,255,0.3); margin-top: 0.15rem;">
                                                    ~${Math.ceil((d.line?.split(' ').length || 0) / 2.5)}s
                                                </div>
                                            </div>
                                        `}).join('')}
                                    </div>
                                    <!-- PHASE 4: Voice Summary -->
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem; padding: 0.5rem; background: rgba(139, 92, 246, 0.05); border: 1px solid rgba(139, 92, 246, 0.15); border-radius: 0.4rem;">
                                        <div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">
                                             Voices: ${speakerVoices.map(sv => `<span style="color: #c4b5fd;">${sv.name}</span>`).join(', ')}
                                        </div>
                                        <div style="font-size: 0.55rem; color: rgba(255,255,255,0.4);">
                                            Use Multitalk for lip-sync
                                        </div>
                                    </div>
                                </div>
                            ` : ''}

                            <!-- Duration & Transition -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div>
                                    <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;"> Duration (seconds)</label>
                                    <input type="number"
                                           value="${scene.duration || 8}"
                                           min="3" max="30"
                                           onchange="updateSceneDuration(${scene.id}, this.value)"
                                           style="width: 100%; padding: 0.5rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white;">
                                </div>
                                <div>
                                    <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;"> Transition</label>
                                    <select onchange="updateSceneTransition(${scene.id}, this.value)"
                                            style="width: 100%; padding: 0.5rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(30,30,50,1); color: white;">
                                        ${['cut', 'fade', 'zoom', 'slide'].map(t => `
                                            <option value="${t}" ${scene.transition === t ? 'selected' : ''}>${t.charAt(0).toUpperCase() + t.slice(1)}</option>
                                        `).join('')}
                                    </select>
                                </div>
                            </div>

                            <!-- PHASE 2 & 3: Shot & Voice Summary Panel -->
                            ${(() => {
                                const sceneDecomp = state.storyboard?.multiShotMode?.decomposedScenes?.[scene.id];
                                const hasDecompShots = sceneDecomp?.status === 'ready' && sceneDecomp?.shots?.length > 0;
                                const shots = sceneDecomp?.shots || [];
                                const dialogueShots = shots.filter(s => s.hasDialogue);
                                const multiVoiceShots = shots.filter(s => s.isMultiVoice);
                                const totalShotDuration = shots.reduce((sum, s) => sum + (s.selectedDuration || s.calculatedDuration || s.duration || 10), 0);

                                if (!hasDecompShots && !hasDialogue) return '';

                                return `
                                <div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 0.5rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <span style="font-size: 0.75rem; color: #3b82f6; font-weight: 600;"> Scene Production Summary</span>
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.5rem;">
                                        ${hasDecompShots ? `
                                            <!-- Shot Statistics -->
                                            <div style="background: rgba(34, 197, 94, 0.1); padding: 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(34, 197, 94, 0.2);">
                                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">Total Shots</div>
                                                <div style="font-size: 1rem; color: #22c55e; font-weight: 700;">${shots.length}</div>
                                                <div style="font-size: 0.5rem; color: rgba(255,255,255,0.4);">${totalShotDuration}s total</div>
                                            </div>
                                            <div style="background: rgba(251, 191, 36, 0.1); padding: 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(251, 191, 36, 0.2);">
                                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">Dialogue Shots</div>
                                                <div style="font-size: 1rem; color: #fbbf24; font-weight: 700;">${dialogueShots.length}</div>
                                                <div style="font-size: 0.5rem; color: rgba(255,255,255,0.4);">${Math.round(dialogueShots.length / shots.length * 100)}% of scene</div>
                                            </div>
                                            <div style="background: rgba(167, 139, 250, 0.1); padding: 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(167, 139, 250, 0.2);">
                                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">Multi-Voice</div>
                                                <div style="font-size: 1rem; color: #a78bfa; font-weight: 700;">${multiVoiceShots.length}</div>
                                                <div style="font-size: 0.5rem; color: rgba(255,255,255,0.4);">needs Multitalk</div>
                                            </div>
                                        ` : ''}
                                        ${speakerCount > 0 ? `
                                            <!-- Voice Statistics -->
                                            <div style="background: rgba(139, 92, 246, 0.1); padding: 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(139, 92, 246, 0.2);">
                                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">Characters</div>
                                                <div style="font-size: 1rem; color: #c4b5fd; font-weight: 700;">${speakerCount}</div>
                                                <div style="font-size: 0.5rem; color: rgba(255,255,255,0.4);">${speakerVoices.filter(sv => sv.voice).length} voices assigned</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                    ${hasDecompShots && speakerCount > 0 ? `
                                        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                            <div style="font-size: 0.55rem; color: rgba(255,255,255,0.5);">
                                                 Production: ${shots.length} shots  ${speakerCount} voices = ${dialogueShots.length} dialogue animations via Multitalk
                                            </div>
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                            })()}

                            <!-- Scene Actions -->
                            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                <button onclick="regenerateScene(${scene.id})"
                                        style="flex: 1; padding: 0.5rem; border-radius: 0.5rem; border: 1px solid rgba(139, 92, 246, 0.4); background: rgba(139, 92, 246, 0.1); color: white; cursor: pointer; font-size: 0.8rem;">
                                     Regenerate
                                </button>
                                <button onclick="moveSceneUp(${scene.id})"
                                        ${index === 0 ? 'disabled' : ''}
                                        style="padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; opacity: ${index === 0 ? '0.5' : '1'};">
                                    
                                </button>
                                <button onclick="moveSceneDown(${scene.id})"
                                        ${index === state.script.scenes.length - 1 ? 'disabled' : ''}
                                        style="padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; opacity: ${index === state.script.scenes.length - 1 ? '0.5' : '1'};">
                                    
                                </button>
                                <button onclick="deleteScene(${scene.id})"
                                        style="padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(239, 68, 68, 0.4); background: rgba(239, 68, 68, 0.1); color: #ef4444; cursor: pointer;">
                                    
                                </button>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // ==========================================
        // 7.8 STEP 4: STORYBOARD
        // ==========================================
        function renderStep4Storyboard() {
            const scenes = state.script.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];

            // Check if we need to auto-generate
            if (scenes.length > 0 && storyboardScenes.length === 0 && state.storyboard.status !== 'generating') {
                // Trigger auto-generation on first visit
                setTimeout(() => generateInitialStoryboard(), 100);
            }

            let html = '<div class="fade-in">';

            // Header with Model Selector
            const currentModel = state.storyboard.imageModel || 'hidream';
            const modelConfig = IMAGE_MODELS[currentModel] || IMAGE_MODELS['hidream'];

            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div style="flex: 1;">
                            <div class="content-card-title">Storyboard</div>
                            <div class="content-card-subtitle">Visual preview of each scene  ${storyboardScenes.filter(s => s.imageUrl && s.status === 'ready').length}/${scenes.length} images ready</div>
                        </div>
                    </div>

                    <!-- AI Model Selector -->
                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="color: rgba(255,255,255,0.7); font-size: 0.75rem; margin-bottom: 0.5rem;"> AI Model for Image Generation:</div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            ${Object.entries(IMAGE_MODELS).map(([id, model]) => `
                                <button onclick="setImageModel('${id}')"
                                        style="padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid ${currentModel === id ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; background: ${currentModel === id ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; color: ${currentModel === id ? 'white' : 'rgba(255,255,255,0.7)'}; cursor: pointer; font-size: 0.75rem; display: flex; flex-direction: column; align-items: center; gap: 0.15rem; transition: all 0.2s;">
                                    <span style="font-weight: 600;">${model.name}</span>
                                    <span style="font-size: 0.65rem; color: ${currentModel === id ? 'rgba(255,255,255,0.7)' : 'rgba(255,255,255,0.5)'};">${model.tokenCost} token${model.tokenCost > 1 ? 's' : ''}</span>
                                </button>
                            `).join('')}
                        </div>
                        <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-top: 0.5rem;">
                            ${modelConfig.description}
                        </div>
                    </div>

                    <!-- Phase 3B: Visual Style Controls -->
                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                            <div style="color: rgba(255,255,255,0.7); font-size: 0.75rem;"> Visual Style</div>
                            <span style="font-size: 0.55rem; padding: 0.15rem 0.4rem; background: linear-gradient(135deg, #f59e0b, #ef4444); border-radius: 0.75rem; color: white; font-weight: 600;">PRO</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                            <!-- Mood Selector -->
                            <div>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-bottom: 0.25rem;">Mood</div>
                                <select onchange="setVisualStyle('mood', this.value)" style="width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.35rem; color: white; font-size: 0.7rem;">
                                    <option value="" ${!state.storyboard.visualStyle?.mood ? 'selected' : ''}>Auto</option>
                                    <option value="epic" ${state.storyboard.visualStyle?.mood === 'epic' ? 'selected' : ''}> Epic</option>
                                    <option value="intimate" ${state.storyboard.visualStyle?.mood === 'intimate' ? 'selected' : ''}> Intimate</option>
                                    <option value="mysterious" ${state.storyboard.visualStyle?.mood === 'mysterious' ? 'selected' : ''}> Mysterious</option>
                                    <option value="energetic" ${state.storyboard.visualStyle?.mood === 'energetic' ? 'selected' : ''}> Energetic</option>
                                    <option value="contemplative" ${state.storyboard.visualStyle?.mood === 'contemplative' ? 'selected' : ''}> Contemplative</option>
                                    <option value="tense" ${state.storyboard.visualStyle?.mood === 'tense' ? 'selected' : ''}> Tense</option>
                                    <option value="hopeful" ${state.storyboard.visualStyle?.mood === 'hopeful' ? 'selected' : ''}> Hopeful</option>
                                    <option value="professional" ${state.storyboard.visualStyle?.mood === 'professional' ? 'selected' : ''}> Professional</option>
                                    <option value="nostalgic" ${state.storyboard.visualStyle?.mood === 'nostalgic' ? 'selected' : ''}> Nostalgic</option>
                                    <option value="dark" ${state.storyboard.visualStyle?.mood === 'dark' ? 'selected' : ''}> Dark</option>
                                </select>
                            </div>
                            <!-- Lighting Selector -->
                            <div>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-bottom: 0.25rem;">Lighting</div>
                                <select onchange="setVisualStyle('lighting', this.value)" style="width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.35rem; color: white; font-size: 0.7rem;">
                                    <option value="" ${!state.storyboard.visualStyle?.lighting ? 'selected' : ''}>Auto</option>
                                    <option value="natural" ${state.storyboard.visualStyle?.lighting === 'natural' ? 'selected' : ''}> Natural</option>
                                    <option value="golden-hour" ${state.storyboard.visualStyle?.lighting === 'golden-hour' ? 'selected' : ''}> Golden Hour</option>
                                    <option value="blue-hour" ${state.storyboard.visualStyle?.lighting === 'blue-hour' ? 'selected' : ''}> Blue Hour</option>
                                    <option value="high-key" ${state.storyboard.visualStyle?.lighting === 'high-key' ? 'selected' : ''}> High Key</option>
                                    <option value="low-key" ${state.storyboard.visualStyle?.lighting === 'low-key' ? 'selected' : ''}> Low Key/Noir</option>
                                    <option value="neon" ${state.storyboard.visualStyle?.lighting === 'neon' ? 'selected' : ''}> Neon</option>
                                    <option value="silhouette" ${state.storyboard.visualStyle?.lighting === 'silhouette' ? 'selected' : ''}> Silhouette</option>
                                </select>
                            </div>
                            <!-- Color Palette Selector -->
                            <div>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-bottom: 0.25rem;">Colors</div>
                                <select onchange="setVisualStyle('colorPalette', this.value)" style="width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.35rem; color: white; font-size: 0.7rem;">
                                    <option value="" ${!state.storyboard.visualStyle?.colorPalette ? 'selected' : ''}>Auto</option>
                                    <option value="teal-orange" ${state.storyboard.visualStyle?.colorPalette === 'teal-orange' ? 'selected' : ''}> Teal/Orange</option>
                                    <option value="warm-tones" ${state.storyboard.visualStyle?.colorPalette === 'warm-tones' ? 'selected' : ''}> Warm</option>
                                    <option value="cool-tones" ${state.storyboard.visualStyle?.colorPalette === 'cool-tones' ? 'selected' : ''}> Cool</option>
                                    <option value="desaturated" ${state.storyboard.visualStyle?.colorPalette === 'desaturated' ? 'selected' : ''}> Desaturated</option>
                                    <option value="high-saturation" ${state.storyboard.visualStyle?.colorPalette === 'high-saturation' ? 'selected' : ''}> Vibrant</option>
                                    <option value="pastel" ${state.storyboard.visualStyle?.colorPalette === 'pastel' ? 'selected' : ''}> Pastel</option>
                                    <option value="earth-tones" ${state.storyboard.visualStyle?.colorPalette === 'earth-tones' ? 'selected' : ''}> Earth</option>
                                    <option value="noir-bw" ${state.storyboard.visualStyle?.colorPalette === 'noir-bw' ? 'selected' : ''}> B&W Noir</option>
                                </select>
                            </div>
                            <!-- Composition Selector -->
                            <div>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-bottom: 0.25rem;">Shot</div>
                                <select onchange="setVisualStyle('composition', this.value)" style="width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.35rem; color: white; font-size: 0.7rem;">
                                    <option value="" ${!state.storyboard.visualStyle?.composition ? 'selected' : ''}>Auto</option>
                                    <option value="wide-establishing" ${state.storyboard.visualStyle?.composition === 'wide-establishing' ? 'selected' : ''}> Wide</option>
                                    <option value="medium-shot" ${state.storyboard.visualStyle?.composition === 'medium-shot' ? 'selected' : ''}> Medium</option>
                                    <option value="close-up" ${state.storyboard.visualStyle?.composition === 'close-up' ? 'selected' : ''}> Close-up</option>
                                    <option value="extreme-close-up" ${state.storyboard.visualStyle?.composition === 'extreme-close-up' ? 'selected' : ''}> Extreme CU</option>
                                    <option value="low-angle" ${state.storyboard.visualStyle?.composition === 'low-angle' ? 'selected' : ''}> Low Angle</option>
                                    <option value="birds-eye" ${state.storyboard.visualStyle?.composition === 'birds-eye' ? 'selected' : ''}> Bird's Eye</option>
                                    <option value="dutch-angle" ${state.storyboard.visualStyle?.composition === 'dutch-angle' ? 'selected' : ''}> Dutch</option>
                                    <option value="symmetrical" ${state.storyboard.visualStyle?.composition === 'symmetrical' ? 'selected' : ''}> Symmetrical</option>
                                </select>
                            </div>
                        </div>
                        <div style="color: rgba(255,255,255,0.4); font-size: 0.6rem; margin-top: 0.4rem;">
                             "Auto" uses genre-appropriate defaults based on your content settings
                        </div>
                    </div>

                    <!-- Production Profile Indicator (Genre Intelligence) -->
                    ${state.content.genre ? `
                    <div style="margin-top: 1rem; padding: 0.75rem; background: linear-gradient(135deg, rgba(245,158,11,0.15), rgba(236,72,153,0.1)); border: 1px solid rgba(245,158,11,0.3); border-radius: 0.5rem;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.4rem;">
                                <span style="font-size: 0.85rem;"></span>
                                <span style="color: #fbbf24; font-size: 0.75rem; font-weight: 600;">Production Profile Active</span>
                            </div>
                            <button onclick="resyncWithGenre()" style="font-size: 0.55rem; padding: 0.2rem 0.4rem; border-radius: 0.25rem; border: 1px solid rgba(245,158,11,0.4); background: transparent; color: #f59e0b; cursor: pointer;"> Re-sync</button>
                        </div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 0.6rem; line-height: 1.4;">
                            Based on <strong style="color: #fbbf24;">${state.content.genre.replace(/-/g, ' ')}</strong> genre:
                            <div style="display: flex; flex-wrap: wrap; gap: 0.3rem; margin-top: 0.35rem;">
                                <span style="padding: 0.15rem 0.35rem; background: rgba(139,92,246,0.2); border-radius: 0.2rem; color: #a78bfa;"> Style Bible</span>
                                <span style="padding: 0.15rem 0.35rem; background: rgba(6,182,212,0.2); border-radius: 0.2rem; color: #22d3ee;"> ${state.animation.narratorVoice || 'nova'} voice</span>
                                <span style="padding: 0.15rem 0.35rem; background: rgba(245,158,11,0.2); border-radius: 0.2rem; color: #fbbf24;"> ${state.assembly.audioMood || 'auto'} mood</span>
                            </div>
                        </div>
                    </div>
                    ` : ''}

                    <!-- Phase 4: Scene Memory System -->
                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 0.9rem;"></span>
                                <span style="color: rgba(255,255,255,0.7); font-size: 0.75rem; font-weight: 600;">Scene Memory</span>
                            </div>
                            <span style="font-size: 0.55rem; padding: 0.15rem 0.4rem; background: linear-gradient(135deg, #06b6d4, #8b5cf6); border-radius: 0.75rem; color: white; font-weight: 600;">NEW</span>
                        </div>
                        <div style="color: rgba(255,255,255,0.4); font-size: 0.65rem; margin-bottom: 0.75rem;">
                            Visual consistency with Style, Character & Location Bibles
                        </div>

                        <!-- Bible Cards Row - Style, Character, Location side by side -->
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
                            <!-- Style Bible Card -->
                            <div style="flex: 1; min-width: 180px; background: ${state.storyboard.styleBible?.enabled ? 'rgba(139, 92, 246, 0.1)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${state.storyboard.styleBible?.enabled ? 'rgba(139, 92, 246, 0.3)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; padding: 0.6rem;">
                                <div style="display: flex; align-items: flex-start; justify-content: space-between; gap: 0.3rem;">
                                    <div style="display: flex; align-items: center; gap: 0.4rem; flex: 1; min-width: 0;">
                                        <span style="font-size: 0.8rem;"></span>
                                        <div style="min-width: 0;">
                                            <div style="color: white; font-size: 0.75rem; font-weight: 600;">Style Bible</div>
                                            <div style="color: rgba(255,255,255,0.4); font-size: 0.55rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${state.storyboard.styleBible?.enabled ? (state.storyboard.styleBible?.style ? 'Custom style defined' : 'Not configured') : 'Visual DNA'}</div>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 0.3rem; flex-shrink: 0;">
                                        <button onclick="openStyleBibleModal()" style="padding: 0.2rem 0.4rem; background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.25rem; color: white; font-size: 0.55rem; cursor: pointer;">
                                            Edit
                                        </button>
                                        <input type="checkbox" ${state.storyboard.styleBible?.enabled ? 'checked' : ''} onchange="toggleStyleBible(this.checked)" style="accent-color: #8b5cf6; width: 14px; height: 14px;">
                                    </div>
                                </div>
                                ${state.storyboard.styleBible?.enabled && state.storyboard.styleBible?.style ? `
                                    <div style="margin-top: 0.4rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <div style="color: rgba(255,255,255,0.5); font-size: 0.5rem; font-style: italic; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                            "${state.storyboard.styleBible.style}"
                                        </div>
                                    </div>
                                ` : ''}
                            </div>

                            <!-- Character Bible Card -->
                            <div style="flex: 1; min-width: 180px; background: ${state.storyboard.characterBible?.enabled ? 'rgba(6, 182, 212, 0.1)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${state.storyboard.characterBible?.enabled ? 'rgba(6, 182, 212, 0.3)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; padding: 0.6rem;">
                                <div style="display: flex; align-items: flex-start; justify-content: space-between; gap: 0.3rem;">
                                    <div style="display: flex; align-items: center; gap: 0.4rem; flex: 1; min-width: 0;">
                                        <span style="font-size: 0.8rem;"></span>
                                        <div style="min-width: 0;">
                                            <div style="color: white; font-size: 0.75rem; font-weight: 600;">Character Bible</div>
                                            <div style="color: rgba(255,255,255,0.4); font-size: 0.55rem;">${state.storyboard.characterBible?.enabled ? ((state.storyboard.characterBible?.characters?.length || 0) + ' character(s)') : 'Consistent faces'}</div>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 0.3rem; flex-shrink: 0;">
                                        <button onclick="openCharacterBibleModal()" style="padding: 0.2rem 0.4rem; background: rgba(6, 182, 212, 0.2); border: 1px solid rgba(6, 182, 212, 0.4); border-radius: 0.25rem; color: white; font-size: 0.55rem; cursor: pointer;">
                                            Edit
                                        </button>
                                        <input type="checkbox" ${state.storyboard.characterBible?.enabled ? 'checked' : ''} onchange="toggleCharacterBible(this.checked)" style="accent-color: #06b6d4; width: 14px; height: 14px;">
                                    </div>
                                </div>
                                ${state.storyboard.characterBible?.enabled && state.storyboard.characterBible?.characters?.length > 0 ? `
                                    <div style="margin-top: 0.4rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 0.2rem; flex-wrap: wrap;">
                                    ${state.storyboard.characterBible.characters.slice(0, 3).map(c => `
                                        <span style="background: rgba(6, 182, 212, 0.2); padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.6rem; color: rgba(255,255,255,0.7);">${c.name}</span>
                                    `).join('')}
                                    ${state.storyboard.characterBible.characters.length > 3 ? `<span style="color: rgba(255,255,255,0.4); font-size: 0.6rem;">+${state.storyboard.characterBible.characters.length - 3} more</span>` : ''}
                                </div>
                            ` : ''}
                            </div>

                            <!-- Location Bible Card -->
                            <div style="flex: 1; min-width: 180px; background: ${state.storyboard.locationBible?.enabled ? 'rgba(245, 158, 11, 0.1)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${state.storyboard.locationBible?.enabled ? 'rgba(245, 158, 11, 0.3)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; padding: 0.6rem;">
                                <div style="display: flex; align-items: flex-start; justify-content: space-between; gap: 0.3rem;">
                                    <div style="display: flex; align-items: center; gap: 0.4rem; flex: 1; min-width: 0;">
                                        <span style="font-size: 0.8rem;"></span>
                                        <div style="min-width: 0;">
                                            <div style="color: white; font-size: 0.75rem; font-weight: 600;">Location Bible</div>
                                            <div style="color: rgba(255,255,255,0.4); font-size: 0.55rem;">${state.storyboard.locationBible?.enabled ? ((state.storyboard.locationBible?.locations?.length || 0) + ' location(s)') : 'Consistent environments'}</div>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 0.3rem; flex-shrink: 0;">
                                        <button onclick="openLocationBibleModal()" style="padding: 0.2rem 0.4rem; background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 0.25rem; color: white; font-size: 0.55rem; cursor: pointer;">
                                            Edit
                                        </button>
                                        <input type="checkbox" ${state.storyboard.locationBible?.enabled ? 'checked' : ''} onchange="toggleLocationBible(this.checked)" style="accent-color: #f59e0b; width: 14px; height: 14px;">
                                    </div>
                                </div>
                                ${state.storyboard.locationBible?.enabled && state.storyboard.locationBible?.locations?.length > 0 ? `
                                    <div style="margin-top: 0.4rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 0.2rem; flex-wrap: wrap;">
                                    ${state.storyboard.locationBible.locations.slice(0, 3).map(loc => `
                                        <span style="background: rgba(245, 158, 11, 0.2); padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.5rem; color: rgba(255,255,255,0.7);">${loc.name}</span>
                                    `).join('')}
                                    ${state.storyboard.locationBible.locations.length > 3 ? `<span style="color: rgba(255,255,255,0.4); font-size: 0.5rem;">+${state.storyboard.locationBible.locations.length - 3} more</span>` : ''}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                        <!-- End Bible Cards Row -->

                        <!-- Technical Specs (Collapsed) -->
                        <div style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.5rem; padding: 0.5rem 0.75rem;">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.75rem;"></span>
                                    <span style="color: rgba(255,255,255,0.6); font-size: 0.7rem;">Technical Specs</span>
                                </div>
                                <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                                    <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">4K quality</span>
                                    <input type="checkbox" ${state.storyboard.technicalSpecs?.enabled !== false ? 'checked' : ''} onchange="toggleTechnicalSpecs(this.checked)" style="accent-color: #10b981;">
                                </label>
                            </div>
                        </div>

                        <!-- Phase 8-11: Prompt Chain Architecture -->
                        <div style="margin-top: 0.75rem; background: ${state.storyboard.promptChain?.status === 'ready' ? 'rgba(251, 191, 36, 0.1)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${state.storyboard.promptChain?.status === 'ready' ? 'rgba(251, 191, 36, 0.3)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; padding: 0.75rem;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.85rem;"></span>
                                    <div>
                                        <div style="color: white; font-size: 0.8rem; font-weight: 600;">Prompt Chain</div>
                                        <div style="color: rgba(255,255,255,0.4); font-size: 0.6rem;">
                                            ${state.storyboard.promptChain?.status === 'ready' ? 'Optimized prompts ready' :
                                              state.storyboard.promptChain?.status === 'processing' ? 'Processing...' :
                                              'Hollywood-grade scene blueprints'}
                                        </div>
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    ${state.storyboard.promptChain?.status === 'processing' ? `
                                        <span style="font-size: 0.65rem; color: rgba(251, 191, 36, 0.8);"> Processing...</span>
                                    ` : state.storyboard.promptChain?.status === 'ready' ? `
                                        <span style="font-size: 0.65rem; color: rgba(16, 185, 129, 0.9);"> Ready</span>
                                        <button onclick="processPromptChain()" style="padding: 0.25rem 0.5rem; background: rgba(251, 191, 36, 0.2); border: 1px solid rgba(251, 191, 36, 0.4); border-radius: 0.35rem; color: white; font-size: 0.6rem; cursor: pointer;">
                                            Refresh
                                        </button>
                                    ` : `
                                        <button onclick="processPromptChain()" style="padding: 0.3rem 0.6rem; background: linear-gradient(135deg, rgba(251, 191, 36, 0.3), rgba(245, 158, 11, 0.3)); border: 1px solid rgba(251, 191, 36, 0.5); border-radius: 0.35rem; color: white; font-size: 0.65rem; cursor: pointer; font-weight: 500;">
                                             Process Chain
                                        </button>
                                    `}
                                    <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                                        <input type="checkbox" ${state.storyboard.promptChain?.enabled !== false ? 'checked' : ''} onchange="togglePromptChain(this.checked)" style="accent-color: #fbbf24;">
                                    </label>
                                </div>
                            </div>
                            ${state.storyboard.promptChain?.status === 'ready' && state.storyboard.promptChain?.scenes?.length > 0 ? `
                                <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 0.5rem; margin-top: 0.25rem;">
                                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; font-size: 0.6rem;">
                                        <span style="background: rgba(139, 92, 246, 0.2); padding: 0.15rem 0.4rem; border-radius: 0.25rem; color: rgba(255,255,255,0.7);"> Image Prompts</span>
                                        <span style="background: rgba(6, 182, 212, 0.2); padding: 0.15rem 0.4rem; border-radius: 0.25rem; color: rgba(255,255,255,0.7);"> Video Prompts</span>
                                        <span style="background: rgba(16, 185, 129, 0.2); padding: 0.15rem 0.4rem; border-radius: 0.25rem; color: rgba(255,255,255,0.7);"> Transitions</span>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;

            // Style Bible Modal
            if (state.storyboard.showStyleBibleModal) {
                html += renderStyleBibleModal();
            }

            // Character Bible Modal
            if (state.storyboard.showCharacterBibleModal) {
                html += renderCharacterBibleModal();
            }

            // Location Bible Modal
            if (state.storyboard.showLocationBibleModal) {
                html += renderLocationBibleModal();
            }

            // Storyboard Grid
            html += `<div class="storyboard-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem; margin-top: 1rem;">`;

            scenes.forEach((scene, index) => {
                const storyboardScene = storyboardScenes.find(s => s.sceneId === scene.id) || {};
                html += renderStoryboardCard(scene, storyboardScene, index);
            });

            html += `</div>`;

            // Navigation
            const hasAllImages = storyboardScenes.filter(s => s.status === 'ready').length >= scenes.length;
            html += renderNavButtons(3, hasAllImages ? 5 : null);

            html += '</div>';

            // Modify Modal (rendered outside main flow)
            if (state.storyboard.modifyingScene) {
                html += renderModifyModal();
            }

            return html;
        }

        function renderStoryboardCard(scene, storyboardScene, index) {
            const status = storyboardScene.status || 'pending';
            const imageUrl = storyboardScene.imageUrl;

            // Phase 8-11: Check if scene has prompt chain data
            const chainData = getPromptChainForScene(scene.id);
            const hasChainData = !!chainData && state.storyboard.promptChain?.enabled;

            // Show the actual optimized prompt when chain is enabled, otherwise show stored/visual prompt
            let prompt;
            if (hasChainData && chainData.imagePrompt?.prompt) {
                // Use the chain-optimized image prompt
                prompt = chainData.imagePrompt.prompt;
            } else {
                // Fallback to stored prompt or scene visual
                prompt = storyboardScene.prompt || scene.visual || scene.visualPrompt || '';
            }
            // Defensive check: ensure prompt is always a string
            if (typeof prompt !== 'string') {
                prompt = typeof prompt === 'object' ? JSON.stringify(prompt) : String(prompt || '');
            }

            let cardContent = '';

            if (status === 'pending') {
                // Empty state - needs generation (show both AI and Stock options)
                cardContent = `
                    <div style="height: 160px; background: rgba(255,255,255,0.03); border: 2px dashed rgba(255,255,255,0.2); border-radius: 0.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem;">
                        <div style="color: rgba(255,255,255,0.6); font-size: 0.75rem; margin-bottom: 0.75rem;">Choose image source:</div>
                        <div style="display: flex; gap: 0.5rem; width: 100%;">
                            <button onclick="generateSingleSceneImage(${scene.id})"
                                    style="flex: 1; padding: 0.6rem 0.5rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(6, 182, 212, 0.3)); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.7rem; display: flex; flex-direction: column; align-items: center; gap: 0.25rem;">
                                <span style="font-size: 1.1rem;"></span>
                                <span>AI Generate</span>
                                <span style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">2 tokens</span>
                            </button>
                            <button onclick="openStockBrowser(${scene.id})"
                                    style="flex: 1; padding: 0.6rem 0.5rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.7rem; display: flex; flex-direction: column; align-items: center; gap: 0.25rem;">
                                <span style="font-size: 1.1rem;"></span>
                                <span>Stock Media</span>
                                <span style="font-size: 0.6rem; color: rgba(16, 185, 129, 0.8);">FREE</span>
                            </button>
                        </div>
                    </div>
                `;
            } else if (status === 'generating') {
                // Loading state
                cardContent = `
                    <div style="height: 160px; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                        <div class="animate-spin" style="width: 2rem; height: 2rem; border: 3px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%; margin-bottom: 0.75rem;"></div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 0.8rem;">Generating...</div>
                    </div>
                `;
            } else if (status === 'ready' && imageUrl) {
                // Image ready
                const isVideo = storyboardScene.source === 'stock-video';
                const sourceLabel = storyboardScene.source === 'stock' ? ' Stock' :
                                   isVideo ? ' Video' : ' AI';
                const sourceBgColor = storyboardScene.source === 'stock' ? 'rgba(16, 185, 129, 0.9)' :
                                     isVideo ? 'rgba(6, 182, 212, 0.9)' : 'rgba(139, 92, 246, 0.9)';
                // Get fallback thumbnail URL if available
                const fallbackUrl = storyboardScene.stockInfo?.thumbnailFallback || '';
                // Get clip duration for videos
                const clipDuration = storyboardScene.stockInfo?.clipDuration || storyboardScene.stockInfo?.duration;

                cardContent = `
                    <div style="height: 160px; border-radius: 0.5rem; overflow: hidden; position: relative; background: rgba(0,0,0,0.3);">
                        <img src="${imageUrl}"
                             alt="Scene ${index + 1}"
                             style="width: 100%; height: 100%; object-fit: cover;"
                             data-scene-id="${scene.id}"
                             data-retry-count="0"
                             onload="this.dataset.loaded='true';"
                             onerror="
                                this.onerror=null;
                                ${fallbackUrl ? `this.src='${fallbackUrl}';` : `
                                    // For AI images, retry a few times with cache-busting before showing placeholder
                                    const retryCount = parseInt(this.dataset.retryCount || '0');
                                    if (retryCount < 3) {
                                        this.dataset.retryCount = retryCount + 1;
                                        setTimeout(() => {
                                            const url = this.src.split('&t=')[0].split('?t=')[0];
                                            this.src = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();
                                            this.onerror = function() {
                                                this.style.display='none';
                                                this.parentElement.querySelector('.placeholder-retry').style.display='flex';
                                            };
                                        }, 2000);
                                    } else {
                                        this.style.display='none';
                                        this.parentElement.querySelector('.placeholder-retry').style.display='flex';
                                    }
                                `}">
                        <!-- Placeholder with retry option if image fails after retries -->
                        <div class="placeholder-retry" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); gap: 0.5rem;">
                            <span style="font-size: 1.5rem;">${isVideo ? '' : ''}</span>
                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.7);">Image not available</span>
                            <button onclick="regenerateSingleSceneImage(${scene.id})" style="padding: 0.3rem 0.6rem; border-radius: 0.3rem; border: 1px solid rgba(139,92,246,0.5); background: rgba(139,92,246,0.3); color: white; cursor: pointer; font-size: 0.65rem;">
                                 Regenerate
                            </button>
                        </div>
                        ${isVideo ? `
                            <!-- Video play icon overlay -->
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 36px; height: 36px; background: rgba(0,0,0,0.6); border-radius: 50%; display: flex; align-items: center; justify-content: center; pointer-events: none;">
                                <div style="width: 0; height: 0; border-left: 10px solid white; border-top: 6px solid transparent; border-bottom: 6px solid transparent; margin-left: 2px;"></div>
                            </div>
                            ${clipDuration ? `
                                <!-- Duration badge -->
                                <div style="position: absolute; bottom: 2.5rem; right: 0.4rem; background: rgba(0,0,0,0.8); color: white; padding: 0.15rem 0.35rem; border-radius: 0.2rem; font-size: 0.6rem;">
                                    ${formatDuration(clipDuration)}
                                </div>
                            ` : ''}
                        ` : ''}
                        <!-- Source badge -->
                        <div style="position: absolute; top: 0.5rem; right: 0.5rem; background: ${sourceBgColor}; color: white; padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.6rem;">
                            ${sourceLabel}
                        </div>
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 0.5rem; display: flex; gap: 0.3rem;">
                            <button onclick="openEditModal(${scene.id})" style="flex: 1; padding: 0.35rem; border-radius: 0.4rem; border: 1px solid rgba(236, 72, 153, 0.5); background: linear-gradient(135deg, rgba(236, 72, 153, 0.3), rgba(139, 92, 246, 0.3)); color: white; cursor: pointer; font-size: 0.65rem;" title="Edit with AI">
                                 Edit
                            </button>
                            <button onclick="openModifyModal(${scene.id})" style="padding: 0.35rem 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.3); background: rgba(0,0,0,0.5); color: white; cursor: pointer; font-size: 0.65rem;" title="Modify prompt">
                                
                            </button>
                            <button onclick="openStockBrowser(${scene.id})" style="padding: 0.35rem 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(16, 185, 129, 0.5); background: rgba(16, 185, 129, 0.2); color: white; cursor: pointer; font-size: 0.65rem;" title="Browse stock media">
                                
                            </button>
                            <button onclick="regenerateSingleSceneImage(${scene.id})" style="padding: 0.35rem 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.3); background: rgba(0,0,0,0.5); color: white; cursor: pointer; font-size: 0.65rem;" title="Regenerate with AI">
                                
                            </button>
                            <button onclick="upscaleSceneImage(${scene.id})" style="padding: 0.35rem 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(251, 191, 36, 0.5); background: rgba(251, 191, 36, 0.2); color: white; cursor: pointer; font-size: 0.65rem;" title="Upscale to HD/4K">
                                
                            </button>
                            <button onclick="openShotDecompositionModal(${scene.id})" style="padding: 0.35rem 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(139, 92, 246, 0.6); background: linear-gradient(135deg, rgba(139, 92, 246, 0.4), rgba(6, 182, 212, 0.3)); color: white; cursor: pointer; font-size: 0.65rem; font-weight: 600;" title="${state.storyboard.multiShotMode?.decomposedScenes?.[scene.id]?.shots?.length ? 'Manage shots' : 'Create multi-shot scene'}">
                                
                            </button>
                        </div>
                    </div>
                `;
            } else if (status === 'error') {
                // Error state - show both retry options
                const errorMsg = storyboardScene.error || 'Generation failed';
                cardContent = `
                    <div style="height: 160px; background: rgba(239, 68, 68, 0.05); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem;">
                        <div style="display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.75rem;">
                            <span style="font-size: 1rem;"></span>
                            <span style="color: #ef4444; font-size: 0.75rem;">${errorMsg.substring(0, 40)}${errorMsg.length > 40 ? '...' : ''}</span>
                        </div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 0.7rem; margin-bottom: 0.5rem;">Choose to retry:</div>
                        <div style="display: flex; gap: 0.5rem; width: 100%;">
                            <button onclick="generateSingleSceneImage(${scene.id})"
                                    style="flex: 1; padding: 0.5rem 0.4rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(6, 182, 212, 0.3)); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.7rem; display: flex; flex-direction: column; align-items: center; gap: 0.2rem;">
                                <span style="font-size: 1rem;"></span>
                                <span>Retry AI</span>
                            </button>
                            <button onclick="openStockBrowser(${scene.id})"
                                    style="flex: 1; padding: 0.5rem 0.4rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.7rem; display: flex; flex-direction: column; align-items: center; gap: 0.2rem;">
                                <span style="font-size: 1rem;"></span>
                                <span>Use Stock</span>
                            </button>
                        </div>
                    </div>
                `;
            }

            // Phase 12: Check for multi-shot mode and decomposed scene
            const multiShotEnabled = state.storyboard.multiShotMode?.enabled;
            const decomposed = state.storyboard.multiShotMode?.decomposedScenes?.[scene.id];
            const hasShots = decomposed && decomposed.shots && decomposed.shots.length > 0;

            // If multi-shot is enabled and scene is decomposed, show selected shot image
            let displayImageUrl = imageUrl;
            if (hasShots && decomposed.selectedShot !== undefined) {
                const selectedShot = decomposed.shots[decomposed.selectedShot];
                if (selectedShot && selectedShot.imageUrl && selectedShot.status === 'ready') {
                    displayImageUrl = selectedShot.imageUrl;
                }
            }

            return `
                <div class="storyboard-card" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.75rem; overflow: hidden;">
                    <!-- Scene number badge -->
                    <div style="position: relative;">
                        <div style="position: absolute; top: 0.5rem; left: 0.5rem; background: rgba(0,0,0,0.7); color: white; padding: 0.2rem 0.5rem; border-radius: 0.25rem; font-size: 0.7rem; font-weight: 600; z-index: 1;">
                            Scene ${index + 1}
                        </div>
                        ${hasChainData ? `
                            <div style="position: absolute; top: 0.5rem; right: 0.5rem; z-index: 1;">
                                <button onclick="previewPromptChainBlueprint(${scene.id})" style="background: rgba(251, 191, 36, 0.9); color: #1a1a2e; padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.55rem; font-weight: 600; border: none; cursor: pointer;" title="View Prompt Chain Blueprint">
                                     Chain
                                </button>
                            </div>
                        ` : ''}
                        ${hasShots ? `
                            <div style="position: absolute; top: 0.5rem; right: ${hasChainData ? '4rem' : '0.5rem'}; z-index: 1;">
                                <span style="background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.55rem; font-weight: 600;">
                                     ${decomposed.shots.length} shots
                                </span>
                            </div>
                        ` : ''}
                        ${cardContent}
                    </div>

                    <!-- Multi-Shot Timeline (only shown when shots exist) -->
                    ${hasShots ? `
                        <div style="padding: 0.5rem 0.75rem; border-top: 1px solid rgba(255,255,255,0.05);">
                            ${renderMultiShotTimeline(scene.id)}
                        </div>
                    ` : ''}

                    <!-- Prompt -->
                    <div style="padding: 0.75rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.25rem;">
                            ${hasChainData ? 'OPTIMIZED PROMPT ' : 'PROMPT'}
                        </div>
                        <div style="font-size: 0.8rem; color: rgba(255,255,255,0.8); line-height: 1.4; max-height: 3.6em; overflow: hidden; text-overflow: ellipsis;">
                            ${prompt.substring(0, 120)}${prompt.length > 120 ? '...' : ''}
                        </div>
                        ${hasChainData && chainData.transition ? `
                            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px dashed rgba(255,255,255,0.1);">
                                <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">
                                     ${chainData.transition.cutType?.type || 'cut'} transition
                                </span>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        // ==========================================
        // Phase 4: SCENE MEMORY MODALS
        // ==========================================

        function renderStyleBibleModal() {
            const bible = state.storyboard.styleBible || {};

            return `
                <div id="style-bible-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 1rem;" onclick="if(event.target.id === 'style-bible-modal') closeStyleBibleModal()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 700px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
                        <!-- Header -->
                        <div style="padding: 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: white;"> Style Bible</div>
                                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.5);">Define the visual DNA for ALL scenes</div>
                            </div>
                            <button onclick="closeStyleBibleModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Content -->
                        <div style="padding: 1.25rem; overflow-y: auto; flex: 1;">
                            <!-- Quick Templates -->
                            <div style="margin-bottom: 1.25rem;">
                                <div style="font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Quick Templates</div>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    <button onclick="applyStyleBibleTemplate('cinematic-thriller')" style="padding: 0.4rem 0.75rem; background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: pointer;"> Cinematic Thriller</button>
                                    <button onclick="applyStyleBibleTemplate('documentary-nature')" style="padding: 0.4rem 0.75rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: pointer;"> Documentary</button>
                                    <button onclick="applyStyleBibleTemplate('tech-explainer')" style="padding: 0.4rem 0.75rem; background: rgba(6, 182, 212, 0.2); border: 1px solid rgba(6, 182, 212, 0.4); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: pointer;"> Tech Explainer</button>
                                    <button onclick="applyStyleBibleTemplate('horror-suspense')" style="padding: 0.4rem 0.75rem; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: pointer;"> Horror</button>
                                    <button onclick="applyStyleBibleTemplate('inspirational')" style="padding: 0.4rem 0.75rem; background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: pointer;"> Inspirational</button>
                                </div>
                            </div>

                            <!-- Style Field -->
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.35rem;">Visual Style</label>
                                <textarea id="style-bible-style"
                                          placeholder="e.g., ultra-cinematic photoreal, noir thriller, high contrast"
                                          onchange="setStyleBibleField('style', this.value)"
                                          style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.5rem; color: white; font-size: 0.85rem; resize: none; height: 60px;">${bible.style || ''}</textarea>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">Overall artistic direction</div>
                            </div>

                            <!-- Color Grade Field -->
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.35rem;">Color Grade</label>
                                <textarea id="style-bible-colorgrade"
                                          placeholder="e.g., desaturated teal shadows, amber highlights, crushed blacks"
                                          onchange="setStyleBibleField('colorGrade', this.value)"
                                          style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.5rem; color: white; font-size: 0.85rem; resize: none; height: 60px;">${bible.colorGrade || ''}</textarea>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">Color palette and grading approach</div>
                            </div>

                            <!-- Lighting Field -->
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.35rem;">Lighting</label>
                                <textarea id="style-bible-lighting"
                                          placeholder="e.g., harsh single-source, dramatic rim lights, deep shadows"
                                          onchange="setStyleBibleField('lighting', this.value)"
                                          style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.5rem; color: white; font-size: 0.85rem; resize: none; height: 60px;">${bible.lighting || ''}</textarea>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">Lighting philosophy and setup</div>
                            </div>

                            <!-- Atmosphere Field -->
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.35rem;">Atmosphere</label>
                                <textarea id="style-bible-atmosphere"
                                          placeholder="e.g., smoke, rain reflections, wet surfaces, urban grit"
                                          onchange="setStyleBibleField('atmosphere', this.value)"
                                          style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.5rem; color: white; font-size: 0.85rem; resize: none; height: 60px;">${bible.atmosphere || ''}</textarea>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">Environmental elements and mood</div>
                            </div>

                            <!-- Camera Field -->
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.35rem;">Camera Language</label>
                                <textarea id="style-bible-camera"
                                          placeholder="e.g., slow dolly, low angles, stabilized gimbal, anamorphic lens feel"
                                          onchange="setStyleBibleField('camera', this.value)"
                                          style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.5rem; color: white; font-size: 0.85rem; resize: none; height: 60px;">${bible.camera || ''}</textarea>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">Camera movement and lens choices</div>
                            </div>
                        </div>

                        <!-- Footer -->
                        <div style="padding: 1rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">
                                ${bible.enabled ? ' Style Bible is active' : ' Enable toggle to apply'}
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="closeStyleBibleModal()" style="padding: 0.6rem 1.25rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.85rem; cursor: pointer;">Close</button>
                                <button onclick="toggleStyleBible(true); closeStyleBibleModal();" style="padding: 0.6rem 1.25rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border: none; border-radius: 0.5rem; color: white; font-size: 0.85rem; cursor: pointer; font-weight: 600;">Save & Enable</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCharacterBibleModal() {
            const bible = state.storyboard.characterBible || { characters: [] };
            const characters = bible.characters || [];
            const editingChar = characters.find(c => c.id === state.storyboard.editingCharacterId);
            const scenes = state.script.scenes || [];
            const isGeneratingPortrait = state.storyboard.generatingPortraitCharId === editingChar?.id;

            return `
                <div id="character-bible-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 1rem;" onclick="if(event.target.id === 'character-bible-modal') closeCharacterBibleModal()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 900px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
                        <!-- Header -->
                        <div style="padding: 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: white;"> Character Bible</div>
                                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.5);">Define consistent character appearances with reference images</div>
                            </div>
                            <button onclick="closeCharacterBibleModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Content -->
                        <div style="display: flex; flex: 1; overflow: hidden;">
                            <!-- Character List (Left Panel) - Now with thumbnails -->
                            <div style="width: 220px; border-right: 1px solid rgba(255,255,255,0.1); padding: 1rem; overflow-y: auto;">
                                <button onclick="addCharacter()" style="width: 100%; padding: 0.6rem; background: rgba(6, 182, 212, 0.2); border: 1px dashed rgba(6, 182, 212, 0.5); border-radius: 0.5rem; color: #06b6d4; font-size: 0.75rem; cursor: pointer; margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: center; gap: 0.35rem;">
                                    <span style="font-size: 1.2rem;">+</span> Add Character
                                </button>

                                <!-- Auto-extract characters from script -->
                                ${state.script.scenes && state.script.scenes.length > 0 ? `
                                <button onclick="reanalyzeScriptForCharacters()" style="width: 100%; padding: 0.5rem; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.5rem; color: #a78bfa; font-size: 0.7rem; cursor: pointer; margin-bottom: 0.75rem; display: flex; align-items: center; justify-content: center; gap: 0.35rem;">
                                    <span></span> Auto-detect from Script
                                </button>
                                ` : ''}

                                ${characters.length === 0 ? `
                                    <div style="text-align: center; color: rgba(255,255,255,0.4); font-size: 0.75rem; padding: 1rem;">
                                        ${state.script.scenes && state.script.scenes.length > 0 ?
                                            'No characters yet.<br>Click "Auto-detect" to analyze your script.' :
                                            'No characters yet.<br>Add one to get started.'}
                                    </div>
                                ` : characters.map(char => `
                                    <div onclick="editCharacter('${char.id}')"
                                         style="padding: 0.5rem; background: ${state.storyboard.editingCharacterId === char.id ? 'rgba(6, 182, 212, 0.2)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${state.storyboard.editingCharacterId === char.id ? 'rgba(6, 182, 212, 0.5)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; margin-bottom: 0.5rem; cursor: pointer; display: flex; align-items: center; gap: 0.5rem;">
                                        <!-- Character Thumbnail -->
                                        <div style="width: 45px; height: 55px; border-radius: 0.35rem; overflow: hidden; flex-shrink: 0; background: rgba(255,255,255,0.05); display: flex; align-items: center; justify-content: center;">
                                            ${char.referenceImageUrl && char.referenceImageStatus === 'ready' ?
                                                `<img src="${char.referenceImageUrl}" style="width: 100%; height: 100%; object-fit: cover;">` :
                                                char.referenceImageStatus === 'generating' ?
                                                `<div class="animate-spin" style="width: 1rem; height: 1rem; border: 2px solid rgba(6,182,212,0.3); border-top-color: #06b6d4; border-radius: 50%;"></div>` :
                                                `<span style="font-size: 1.5rem; color: rgba(255,255,255,0.3);"></span>`
                                            }
                                        </div>
                                        <div style="flex: 1; min-width: 0;">
                                            <div style="color: white; font-size: 0.75rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${char.name || 'Unnamed'}</div>
                                            <div style="color: rgba(255,255,255,0.4); font-size: 0.6rem;">${char.appliedToScenes?.length || 0 ? char.appliedToScenes.length + ' scenes' : 'All scenes'}</div>
                                            ${char.referenceImageStatus === 'ready' ? `<div style="color: #10b981; font-size: 0.55rem;"> Portrait</div>` : ''}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>

                            <!-- Character Editor (Right Panel) -->
                            <div style="flex: 1; padding: 1rem; overflow-y: auto;">
                                ${editingChar ? `
                                    <div style="display: flex; gap: 1.25rem;">
                                        <!-- Portrait Preview Column -->
                                        <div style="width: 180px; flex-shrink: 0;">
                                            <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Reference Portrait</label>
                                            <div style="width: 180px; height: 220px; border-radius: 0.5rem; overflow: hidden; background: rgba(255,255,255,0.05); border: 2px dashed rgba(255,255,255,0.2); display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative;">
                                                ${editingChar.referenceImageUrl && editingChar.referenceImageStatus === 'ready' ? `
                                                    <img src="${editingChar.referenceImageUrl}" style="width: 100%; height: 100%; object-fit: cover;">
                                                    <button onclick="event.stopPropagation(); removeCharacterPortrait('${editingChar.id}')"
                                                            style="position: absolute; top: 0.35rem; right: 0.35rem; width: 1.5rem; height: 1.5rem; background: rgba(239, 68, 68, 0.9); border: none; border-radius: 50%; color: white; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; justify-content: center;"></button>
                                                ` : isGeneratingPortrait ? `
                                                    <div class="animate-spin" style="width: 2rem; height: 2rem; border: 3px solid rgba(6,182,212,0.3); border-top-color: #06b6d4; border-radius: 50%; margin-bottom: 0.5rem;"></div>
                                                    <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Generating...</div>
                                                ` : `
                                                    <span style="font-size: 3rem; color: rgba(255,255,255,0.2); margin-bottom: 0.5rem;"></span>
                                                    <div style="color: rgba(255,255,255,0.4); font-size: 0.7rem; text-align: center; padding: 0 0.5rem;">No portrait yet</div>
                                                `}
                                            </div>
                                            <!-- Portrait Action Buttons -->
                                            <div style="display: flex; flex-direction: column; gap: 0.35rem; margin-top: 0.5rem;">
                                                <button onclick="generateCharacterPortrait('${editingChar.id}')"
                                                        ${isGeneratingPortrait ? 'disabled' : ''}
                                                        style="width: 100%; padding: 0.5rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(6, 182, 212, 0.3)); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: ${isGeneratingPortrait ? 'not-allowed' : 'pointer'}; opacity: ${isGeneratingPortrait ? '0.5' : '1'};">
                                                     ${editingChar.referenceImageUrl ? 'Regenerate' : 'Generate'} Portrait
                                                </button>
                                                <button onclick="uploadCharacterPortrait('${editingChar.id}')"
                                                        ${isGeneratingPortrait ? 'disabled' : ''}
                                                        style="width: 100%; padding: 0.5rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: ${isGeneratingPortrait ? 'not-allowed' : 'pointer'}; opacity: ${isGeneratingPortrait ? '0.5' : '1'};">
                                                     Upload Image
                                                </button>
                                            </div>
                                            <div style="font-size: 0.55rem; color: rgba(255,255,255,0.4); margin-top: 0.5rem; text-align: center;">
                                                Portrait is used as AI reference<br>for consistent appearance
                                            </div>
                                        </div>

                                        <!-- Character Details Column -->
                                        <div style="flex: 1;">
                                            <!-- Character Name -->
                                            <div style="margin-bottom: 0.75rem;">
                                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.35rem;">Character Name</label>
                                                <input type="text"
                                                       value="${editingChar.name || ''}"
                                                       onchange="updateCharacter('${editingChar.id}', 'name', this.value)"
                                                       style="width: 100%; padding: 0.6rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.5rem; color: white; font-size: 0.9rem;">
                                            </div>

                                            <!-- Quick Templates -->
                                            <div style="margin-bottom: 0.75rem;">
                                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.35rem;">Quick Templates</div>
                                                <div style="display: flex; gap: 0.35rem; flex-wrap: wrap;">
                                                    <button onclick="applyCharacterTemplate('${editingChar.id}', 'action-hero')" style="padding: 0.3rem 0.6rem; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 0.25rem; color: white; font-size: 0.65rem; cursor: pointer;">Action Hero</button>
                                                    <button onclick="applyCharacterTemplate('${editingChar.id}', 'tech-professional')" style="padding: 0.3rem 0.6rem; background: rgba(6, 182, 212, 0.2); border: 1px solid rgba(6, 182, 212, 0.4); border-radius: 0.25rem; color: white; font-size: 0.65rem; cursor: pointer;">Tech Pro</button>
                                                    <button onclick="applyCharacterTemplate('${editingChar.id}', 'mysterious-figure')" style="padding: 0.3rem 0.6rem; background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.25rem; color: white; font-size: 0.65rem; cursor: pointer;">Mysterious</button>
                                                    <button onclick="applyCharacterTemplate('${editingChar.id}', 'narrator')" style="padding: 0.3rem 0.6rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.25rem; color: white; font-size: 0.65rem; cursor: pointer;">Narrator</button>
                                                </div>
                                            </div>

                                            <!-- Character Description -->
                                            <div style="margin-bottom: 0.75rem;">
                                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.35rem;">Visual Description</label>
                                                <textarea id="char-description-${editingChar.id}"
                                                          placeholder="Describe physical appearance, clothing, distinguishing features..."
                                                          onchange="updateCharacter('${editingChar.id}', 'description', this.value)"
                                                          style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.5rem; color: white; font-size: 0.85rem; resize: none; height: 100px;">${editingChar.description || ''}</textarea>
                                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">Be specific: age, build, hair, eyes, clothing colors, accessories</div>
                                            </div>

                                            <!-- Scene Assignment -->
                                            <div style="margin-bottom: 0.75rem;">
                                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.35rem;">
                                                    <label style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Appears in Scenes</label>
                                                    <button onclick="applyCharacterToAllScenes('${editingChar.id}')" style="padding: 0.2rem 0.4rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.25rem; color: white; font-size: 0.55rem; cursor: pointer;">Apply to All</button>
                                                </div>
                                                <div style="display: flex; gap: 0.3rem; flex-wrap: wrap;">
                                                    ${scenes.map((scene, idx) => {
                                                        const isAssigned = !editingChar.appliedToScenes?.length || editingChar.appliedToScenes.includes(scene.id);
                                                        return `
                                                            <button onclick="toggleCharacterInScene('${editingChar.id}', ${scene.id})"
                                                                    style="padding: 0.3rem 0.5rem; background: ${isAssigned ? 'rgba(6, 182, 212, 0.3)' : 'rgba(255,255,255,0.05)'}; border: 1px solid ${isAssigned ? 'rgba(6, 182, 212, 0.5)' : 'rgba(255,255,255,0.15)'}; border-radius: 0.35rem; color: white; font-size: 0.65rem; cursor: pointer;">
                                                                ${idx + 1}
                                                            </button>
                                                        `;
                                                    }).join('')}
                                                </div>
                                                <div style="font-size: 0.55rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">${!editingChar.appliedToScenes?.length ? 'Appears in ALL scenes (default)' : 'Click scene numbers to toggle'}</div>
                                            </div>

                                            <!-- Delete Character -->
                                            <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 0.75rem; margin-top: 0.75rem;">
                                                <button onclick="if(confirm('Delete this character?')) deleteCharacter('${editingChar.id}')" style="padding: 0.4rem 0.8rem; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 0.5rem; color: #ef4444; font-size: 0.7rem; cursor: pointer;">Delete Character</button>
                                            </div>
                                        </div>
                                    </div>
                                ` : `
                                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: rgba(255,255,255,0.4);">
                                        <span style="font-size: 3rem; margin-bottom: 1rem;"></span>
                                        <div style="font-size: 0.9rem;">Select or add a character</div>
                                        <div style="font-size: 0.75rem; margin-top: 0.5rem;">to define their appearance</div>
                                    </div>
                                `}
                            </div>
                        </div>

                        <!-- Footer -->
                        <div style="padding: 1rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">
                                ${bible.enabled ? ' Character Bible is active' : ' Enable toggle to apply'}
                                ${characters.length > 0 ? '  ' + characters.length + ' character(s)' : ''}
                                ${characters.filter(c => c.referenceImageStatus === 'ready').length > 0 ? `  ${characters.filter(c => c.referenceImageStatus === 'ready').length} with portraits` : ''}
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="closeCharacterBibleModal()" style="padding: 0.6rem 1.25rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.85rem; cursor: pointer;">Close</button>
                                <button onclick="toggleCharacterBible(true); closeCharacterBibleModal();" style="padding: 0.6rem 1.25rem; background: linear-gradient(135deg, #06b6d4, #8b5cf6); border: none; border-radius: 0.5rem; color: white; font-size: 0.85rem; cursor: pointer; font-weight: 600;">Save & Enable</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderLocationBibleModal() {
            const bible = state.storyboard.locationBible || { locations: [] };
            const locations = bible.locations || [];
            const editingLoc = locations.find(l => l.id === state.storyboard.editingLocationId);
            const scenes = state.script.scenes || [];
            const isGeneratingRef = state.storyboard.generatingLocationRefId === editingLoc?.id;

            return `
                <div id="location-bible-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 1rem;" onclick="if(event.target.id === 'location-bible-modal') closeLocationBibleModal()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 950px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
                        <!-- Header -->
                        <div style="padding: 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: white;"> Location Bible</div>
                                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.5);">Define consistent environments with reference images</div>
                            </div>
                            <button onclick="closeLocationBibleModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Content -->
                        <div style="display: flex; flex: 1; overflow: hidden;">
                            <!-- Location List (Left Panel) -->
                            <div style="width: 220px; border-right: 1px solid rgba(255,255,255,0.1); padding: 1rem; overflow-y: auto;">
                                <button onclick="addLocation()" style="width: 100%; padding: 0.6rem; background: rgba(245, 158, 11, 0.2); border: 1px dashed rgba(245, 158, 11, 0.5); border-radius: 0.5rem; color: #f59e0b; font-size: 0.75rem; cursor: pointer; margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: center; gap: 0.35rem;">
                                    <span style="font-size: 1.2rem;">+</span> Add Location
                                </button>

                                <!-- Auto-extract locations from script -->
                                ${state.script.scenes && state.script.scenes.length > 0 ? `
                                <button onclick="extractLocationsFromScript()" style="width: 100%; padding: 0.5rem; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.5rem; color: #a78bfa; font-size: 0.7rem; cursor: pointer; margin-bottom: 0.75rem; display: flex; align-items: center; justify-content: center; gap: 0.35rem;">
                                    <span></span> Auto-detect from Script
                                </button>
                                ` : ''}

                                ${locations.length === 0 ? `
                                    <div style="text-align: center; color: rgba(255,255,255,0.4); font-size: 0.75rem; padding: 1rem;">
                                        ${state.script.scenes && state.script.scenes.length > 0 ?
                                            'No locations yet.<br>Click "Auto-detect" to analyze your script.' :
                                            'No locations yet.<br>Add one to get started.'}
                                    </div>
                                ` : locations.map(loc => `
                                    <div onclick="editLocation('${loc.id}')"
                                         style="padding: 0.5rem; background: ${state.storyboard.editingLocationId === loc.id ? 'rgba(245, 158, 11, 0.2)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${state.storyboard.editingLocationId === loc.id ? 'rgba(245, 158, 11, 0.5)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; margin-bottom: 0.5rem; cursor: pointer; display: flex; align-items: center; gap: 0.5rem;">
                                        <!-- Location Thumbnail -->
                                        <div style="width: 50px; height: 35px; border-radius: 0.35rem; overflow: hidden; flex-shrink: 0; background: rgba(255,255,255,0.05); display: flex; align-items: center; justify-content: center;">
                                            ${loc.referenceImageUrl && loc.referenceImageStatus === 'ready' ?
                                                `<img src="${loc.referenceImageUrl}" style="width: 100%; height: 100%; object-fit: cover;">` :
                                                loc.referenceImageStatus === 'generating' ?
                                                `<div class="animate-spin" style="width: 0.8rem; height: 0.8rem; border: 2px solid rgba(245,158,11,0.3); border-top-color: #f59e0b; border-radius: 50%;"></div>` :
                                                `<span style="font-size: 1rem; color: rgba(255,255,255,0.3);"></span>`
                                            }
                                        </div>
                                        <div style="flex: 1; min-width: 0;">
                                            <div style="color: white; font-size: 0.7rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${loc.name || 'Unnamed'}</div>
                                            <div style="color: rgba(255,255,255,0.4); font-size: 0.55rem;">${loc.type}  ${loc.timeOfDay}</div>
                                            ${loc.referenceImageStatus === 'ready' ? `<div style="color: #10b981; font-size: 0.5rem;"> Reference</div>` : ''}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>

                            <!-- Location Editor (Right Panel) -->
                            <div style="flex: 1; padding: 1rem; overflow-y: auto;">
                                ${editingLoc ? `
                                    <div style="display: flex; gap: 1.25rem;">
                                        <!-- Reference Image Column -->
                                        <div style="width: 200px; flex-shrink: 0;">
                                            <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Reference Image</label>
                                            <div style="width: 200px; height: 115px; border-radius: 0.5rem; overflow: hidden; background: rgba(255,255,255,0.05); border: 2px dashed rgba(255,255,255,0.2); display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative;">
                                                ${editingLoc.referenceImageUrl && editingLoc.referenceImageStatus === 'ready' ? `
                                                    <img src="${editingLoc.referenceImageUrl}" style="width: 100%; height: 100%; object-fit: cover;">
                                                    <button onclick="event.stopPropagation(); removeLocationReference('${editingLoc.id}')"
                                                            style="position: absolute; top: 0.35rem; right: 0.35rem; width: 1.5rem; height: 1.5rem; background: rgba(239, 68, 68, 0.9); border: none; border-radius: 50%; color: white; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; justify-content: center;"></button>
                                                ` : isGeneratingRef ? `
                                                    <div class="animate-spin" style="width: 2rem; height: 2rem; border: 3px solid rgba(245,158,11,0.3); border-top-color: #f59e0b; border-radius: 50%; margin-bottom: 0.5rem;"></div>
                                                    <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Generating...</div>
                                                ` : `
                                                    <span style="font-size: 2.5rem; color: rgba(255,255,255,0.2); margin-bottom: 0.25rem;"></span>
                                                    <div style="color: rgba(255,255,255,0.4); font-size: 0.65rem; text-align: center;">No reference yet</div>
                                                `}
                                            </div>
                                            <!-- Reference Action Buttons -->
                                            <div style="display: flex; flex-direction: column; gap: 0.35rem; margin-top: 0.5rem;">
                                                <button onclick="generateLocationReference('${editingLoc.id}')"
                                                        ${isGeneratingRef ? 'disabled' : ''}
                                                        style="width: 100%; padding: 0.5rem; background: linear-gradient(135deg, rgba(245, 158, 11, 0.3), rgba(234, 88, 12, 0.3)); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: ${isGeneratingRef ? 'not-allowed' : 'pointer'}; opacity: ${isGeneratingRef ? '0.5' : '1'};">
                                                     ${editingLoc.referenceImageUrl ? 'Regenerate' : 'Generate'} Reference
                                                </button>
                                                <button onclick="uploadLocationReference('${editingLoc.id}')"
                                                        ${isGeneratingRef ? 'disabled' : ''}
                                                        style="width: 100%; padding: 0.5rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: ${isGeneratingRef ? 'not-allowed' : 'pointer'}; opacity: ${isGeneratingRef ? '0.5' : '1'};">
                                                     Upload Image
                                                </button>
                                            </div>
                                            <div style="font-size: 0.55rem; color: rgba(255,255,255,0.4); margin-top: 0.5rem; text-align: center;">
                                                Reference provides consistent<br>backgrounds for scene generation
                                            </div>
                                        </div>

                                        <!-- Location Details Column -->
                                        <div style="flex: 1;">
                                            <!-- Location Name -->
                                            <div style="margin-bottom: 0.6rem;">
                                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.25rem;">Location Name</label>
                                                <input type="text"
                                                       value="${editingLoc.name || ''}"
                                                       onchange="updateLocation('${editingLoc.id}', 'name', this.value)"
                                                       style="width: 100%; padding: 0.5rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.4rem; color: white; font-size: 0.85rem;">
                                            </div>

                                            <!-- Quick Templates -->
                                            <div style="margin-bottom: 0.6rem;">
                                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.25rem;">Quick Templates</div>
                                                <div style="display: flex; gap: 0.25rem; flex-wrap: wrap;">
                                                    <button onclick="applyLocationTemplate('${editingLoc.id}', 'urban-night')" style="padding: 0.2rem 0.4rem; background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.2rem; color: white; font-size: 0.55rem; cursor: pointer;"> Urban Night</button>
                                                    <button onclick="applyLocationTemplate('${editingLoc.id}', 'forest-day')" style="padding: 0.2rem 0.4rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.2rem; color: white; font-size: 0.55rem; cursor: pointer;"> Forest</button>
                                                    <button onclick="applyLocationTemplate('${editingLoc.id}', 'tech-lab')" style="padding: 0.2rem 0.4rem; background: rgba(6, 182, 212, 0.2); border: 1px solid rgba(6, 182, 212, 0.4); border-radius: 0.2rem; color: white; font-size: 0.55rem; cursor: pointer;"> Tech Lab</button>
                                                    <button onclick="applyLocationTemplate('${editingLoc.id}', 'desert-sunset')" style="padding: 0.2rem 0.4rem; background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 0.2rem; color: white; font-size: 0.55rem; cursor: pointer;"> Desert</button>
                                                    <button onclick="applyLocationTemplate('${editingLoc.id}', 'industrial')" style="padding: 0.2rem 0.4rem; background: rgba(107, 114, 128, 0.3); border: 1px solid rgba(107, 114, 128, 0.5); border-radius: 0.2rem; color: white; font-size: 0.55rem; cursor: pointer;"> Industrial</button>
                                                    <button onclick="applyLocationTemplate('${editingLoc.id}', 'space-station')" style="padding: 0.2rem 0.4rem; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 0.2rem; color: white; font-size: 0.55rem; cursor: pointer;"> Space</button>
                                                </div>
                                            </div>

                                            <!-- Type, Time, Weather Row -->
                                            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.6rem;">
                                                <div style="flex: 1;">
                                                    <label style="display: block; font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem;">Type</label>
                                                    <select onchange="updateLocation('${editingLoc.id}', 'type', this.value)"
                                                            style="width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.35rem; color: white; font-size: 0.75rem;">
                                                        <option value="exterior" ${editingLoc.type === 'exterior' ? 'selected' : ''}>Exterior</option>
                                                        <option value="interior" ${editingLoc.type === 'interior' ? 'selected' : ''}>Interior</option>
                                                        <option value="abstract" ${editingLoc.type === 'abstract' ? 'selected' : ''}>Abstract</option>
                                                    </select>
                                                </div>
                                                <div style="flex: 1;">
                                                    <label style="display: block; font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem;">Time of Day</label>
                                                    <select onchange="updateLocation('${editingLoc.id}', 'timeOfDay', this.value)"
                                                            style="width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.35rem; color: white; font-size: 0.75rem;">
                                                        <option value="day" ${editingLoc.timeOfDay === 'day' ? 'selected' : ''}>Day</option>
                                                        <option value="night" ${editingLoc.timeOfDay === 'night' ? 'selected' : ''}>Night</option>
                                                        <option value="dawn" ${editingLoc.timeOfDay === 'dawn' ? 'selected' : ''}>Dawn</option>
                                                        <option value="dusk" ${editingLoc.timeOfDay === 'dusk' ? 'selected' : ''}>Dusk</option>
                                                        <option value="golden-hour" ${editingLoc.timeOfDay === 'golden-hour' ? 'selected' : ''}>Golden Hour</option>
                                                    </select>
                                                </div>
                                                <div style="flex: 1;">
                                                    <label style="display: block; font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem;">Weather</label>
                                                    <select onchange="updateLocation('${editingLoc.id}', 'weather', this.value)"
                                                            style="width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.35rem; color: white; font-size: 0.75rem;">
                                                        <option value="clear" ${editingLoc.weather === 'clear' ? 'selected' : ''}>Clear</option>
                                                        <option value="cloudy" ${editingLoc.weather === 'cloudy' ? 'selected' : ''}>Cloudy</option>
                                                        <option value="rainy" ${editingLoc.weather === 'rainy' ? 'selected' : ''}>Rainy</option>
                                                        <option value="foggy" ${editingLoc.weather === 'foggy' ? 'selected' : ''}>Foggy</option>
                                                        <option value="stormy" ${editingLoc.weather === 'stormy' ? 'selected' : ''}>Stormy</option>
                                                    </select>
                                                </div>
                                            </div>

                                            <!-- Mood -->
                                            <div style="margin-bottom: 0.6rem;">
                                                <label style="display: block; font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem;">Mood / Atmosphere</label>
                                                <select onchange="updateLocation('${editingLoc.id}', 'mood', this.value)"
                                                        style="width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.35rem; color: white; font-size: 0.75rem;">
                                                    <option value="neutral" ${editingLoc.mood === 'neutral' ? 'selected' : ''}>Neutral</option>
                                                    <option value="tense" ${editingLoc.mood === 'tense' ? 'selected' : ''}>Tense / Dramatic</option>
                                                    <option value="peaceful" ${editingLoc.mood === 'peaceful' ? 'selected' : ''}>Peaceful / Serene</option>
                                                    <option value="mysterious" ${editingLoc.mood === 'mysterious' ? 'selected' : ''}>Mysterious / Eerie</option>
                                                    <option value="energetic" ${editingLoc.mood === 'energetic' ? 'selected' : ''}>Energetic / Dynamic</option>
                                                </select>
                                            </div>

                                            <!-- Description -->
                                            <div style="margin-bottom: 0.6rem;">
                                                <label style="display: block; font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem;">Visual Description</label>
                                                <textarea id="loc-description-${editingLoc.id}"
                                                          placeholder="Describe the environment in detail: architecture, colors, textures, key elements..."
                                                          onchange="updateLocation('${editingLoc.id}', 'description', this.value)"
                                                          style="width: 100%; padding: 0.5rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.4rem; color: white; font-size: 0.8rem; resize: none; height: 60px;">${editingLoc.description || ''}</textarea>
                                            </div>

                                            <!-- Lighting Style -->
                                            <div style="margin-bottom: 0.6rem;">
                                                <label style="display: block; font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem;">Lighting Style (optional)</label>
                                                <input type="text"
                                                       value="${editingLoc.lightingStyle || ''}"
                                                       placeholder="e.g., Neon signs with wet surface reflections, dramatic rim lighting"
                                                       onchange="updateLocation('${editingLoc.id}', 'lightingStyle', this.value)"
                                                       style="width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.35rem; color: white; font-size: 0.75rem;">
                                            </div>

                                            <!-- Scene Assignment -->
                                            <div style="margin-bottom: 0.5rem;">
                                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                                    <label style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">Used in Scenes</label>
                                                    <button onclick="applyLocationToAllScenes('${editingLoc.id}')" style="padding: 0.15rem 0.3rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.2rem; color: white; font-size: 0.5rem; cursor: pointer;">Apply to All</button>
                                                </div>
                                                <div style="display: flex; gap: 0.25rem; flex-wrap: wrap;">
                                                    ${scenes.map((scene, idx) => {
                                                        const isAssigned = !editingLoc.appliedToScenes?.length || editingLoc.appliedToScenes.includes(scene.id);
                                                        return `
                                                            <button onclick="toggleLocationInScene('${editingLoc.id}', ${scene.id})"
                                                                    style="padding: 0.2rem 0.4rem; background: ${isAssigned ? 'rgba(245, 158, 11, 0.3)' : 'rgba(255,255,255,0.05)'}; border: 1px solid ${isAssigned ? 'rgba(245, 158, 11, 0.5)' : 'rgba(255,255,255,0.15)'}; border-radius: 0.25rem; color: white; font-size: 0.6rem; cursor: pointer;">
                                                                ${idx + 1}
                                                            </button>
                                                        `;
                                                    }).join('')}
                                                </div>
                                                <div style="font-size: 0.5rem; color: rgba(255,255,255,0.4); margin-top: 0.2rem;">
                                                    ${!editingLoc.appliedToScenes?.length ? 'Currently applies to ALL scenes' : `Applies to ${editingLoc.appliedToScenes.length} scene(s)`}
                                                </div>
                                            </div>

                                            <!-- Delete Button -->
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                                <button onclick="if(confirm('Delete this location?')) deleteLocation('${editingLoc.id}')"
                                                        style="padding: 0.4rem 0.75rem; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 0.35rem; color: #ef4444; font-size: 0.7rem; cursor: pointer;">
                                                     Delete Location
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                ` : `
                                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: rgba(255,255,255,0.4); text-align: center;">
                                        <span style="font-size: 3rem; margin-bottom: 1rem;"></span>
                                        <div style="font-size: 0.9rem; margin-bottom: 0.5rem;">Select a location to edit</div>
                                        <div style="font-size: 0.75rem;">or add a new one from the list</div>
                                    </div>
                                `}
                            </div>
                        </div>

                        <!-- Footer -->
                        <div style="padding: 1rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">
                                ${bible.enabled ? ' Location Bible is active' : ' Enable toggle to apply'}
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <label style="display: flex; align-items: center; gap: 0.4rem; cursor: pointer; font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                                    <input type="checkbox" ${bible.enabled ? 'checked' : ''} onchange="toggleLocationBible(this.checked)" style="accent-color: #f59e0b;">
                                    Enable
                                </label>
                                <button onclick="closeLocationBibleModal()" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #f59e0b, #d97706); border: none; border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer;">
                                    Done
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderModifyModal() {
            const sceneId = state.storyboard.modifyingScene;
            const scene = state.script.scenes.find(s => s.id === sceneId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId) || {};

            if (!scene) return '';

            const currentPrompt = state.storyboard.modifyPrompt || storyboardScene.prompt || scene.visual || '';

            return `
                <div id="modify-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 1rem;" onclick="if(event.target.id === 'modify-modal') closeModifyModal()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 700px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
                        <!-- Header -->
                        <div style="padding: 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: white;"> Modify Scene ${scene.id}</div>
                                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.5);">Customize the image generation</div>
                            </div>
                            <button onclick="closeModifyModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Content -->
                        <div style="padding: 1.25rem; overflow-y: auto; flex: 1;">
                            <!-- Current Image Preview -->
                            ${storyboardScene.imageUrl ? `
                                <div style="margin-bottom: 1.25rem;">
                                    <div style="font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Current Image</div>
                                    <img src="${storyboardScene.imageUrl}" alt="Current" style="width: 100%; max-height: 200px; object-fit: cover; border-radius: 0.5rem;">
                                </div>
                            ` : ''}

                            <!-- Prompt Editor -->
                            <div style="margin-bottom: 1.25rem;">
                                <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                                    Image Prompt
                                </label>
                                <textarea id="modify-prompt-input"
                                          style="width: 100%; min-height: 100px; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem; resize: vertical;"
                                          placeholder="Describe what you want to see...">${currentPrompt}</textarea>
                            </div>

                            <!-- Style Selector -->
                            <div style="margin-bottom: 1.25rem;">
                                <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                                    Style
                                </label>
                                <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                                    ${['cinematic', 'modern', 'retro', 'cartoon', 'dark'].map(styleOpt => `
                                        <button onclick="setModifyStyle('${styleOpt}')"
                                                style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid ${state.storyboard.modifyStyle === styleOpt ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.2)'}; background: ${state.storyboard.modifyStyle === styleOpt ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; color: white; cursor: pointer; font-size: 0.75rem; text-transform: capitalize;">
                                            ${styleOpt}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Camera/Composition -->
                            <div style="margin-bottom: 1.25rem;">
                                <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                                    Camera Shot
                                </label>
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                                    ${['wide shot', 'medium shot', 'close-up', 'aerial'].map(shot => `
                                        <button onclick="appendToModifyPrompt('${shot}')"
                                                style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-size: 0.75rem; text-transform: capitalize;">
                                            ${shot}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Lighting -->
                            <div style="margin-bottom: 1.25rem;">
                                <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                                    Lighting
                                </label>
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                                    ${['golden hour', 'dramatic', 'soft light', 'neon'].map(light => `
                                        <button onclick="appendToModifyPrompt('${light} lighting')"
                                                style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-size: 0.75rem; text-transform: capitalize;">
                                            ${light}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                        </div>

                        <!-- Footer -->
                        <div style="padding: 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 0.75rem;">
                            <button onclick="closeModifyModal()"
                                    style="flex: 1; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-weight: 600;">
                                Cancel
                            </button>
                            <button onclick="applyModifyAndGenerate()"
                                    style="flex: 2; padding: 0.75rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; cursor: pointer; font-weight: 700; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                <span></span>
                                <span>Generate New Image</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // ==========================================
        // 7.9 STEP 5: ANIMATION
        // ==========================================
        function renderStep5Animation() {
            const storyboardScenes = state.storyboard.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const scriptScenes = state.script.scenes || [];

            // Initialize animation scenes if needed
            if (animationScenes.length === 0 && storyboardScenes.length > 0) {
                initializeAnimationScenes();
            }

            // Set default selected scene if none selected
            if (!state.animation.selectedSceneId && scriptScenes.length > 0) {
                state.animation.selectedSceneId = scriptScenes[0].id;
            }

            // Calculate scene readiness stats
            const voiceoversReady = animationScenes.filter(s => s.voiceoverUrl).length;
            const animatedScenes = animationScenes.filter(s => s.videoUrl).length;
            const stockVideoScenes = storyboardScenes.filter(s => s.source === 'stock-video' && s.videoUrl).length;

            // A scene is ready if it has visual AND (voiceover OR doesn't need narration)
            const readyScenes = storyboardScenes.filter(sb => {
                const anim = animationScenes.find(a => a.sceneId === sb.sceneId);
                const script = scriptScenes.find(s => s.id === sb.sceneId);
                const hasVoiceover = anim && anim.voiceoverUrl;
                const hasVisual = (anim && anim.videoUrl) || (sb.source === 'stock-video' && sb.videoUrl) || sb.imageUrl;
                const hasNarrationText = script && script.narration && script.narration.trim() !== '';
                const requiresVoiceover = script && script.hasNarration !== false && hasNarrationText;
                return hasVisual && (hasVoiceover || !requiresVoiceover);
            }).length;

            // Check if all scenes are ready for assembly
            // Scenes are ready if they have visual content AND either:
            // 1. Have voiceover (for narrated scenes)
            // 2. Don't require voiceover (music-only/cinematic scenes with no narration)
            const allScenesReady = storyboardScenes.every(storyboardScene => {
                const animScene = animationScenes.find(a => a.sceneId === storyboardScene.sceneId) || {};
                const scriptScene = scriptScenes.find(s => s.id === storyboardScene.sceneId) || {};

                const hasVoiceover = !!animScene.voiceoverUrl;
                const hasAnimatedVideo = !!animScene.videoUrl;
                const hasStockVideo = storyboardScene.source === 'stock-video' && storyboardScene.videoUrl;
                const hasImage = !!storyboardScene.imageUrl;
                const hasVisual = hasAnimatedVideo || hasStockVideo || hasImage;

                // Check if scene requires narration
                const hasNarrationText = scriptScene.narration && scriptScene.narration.trim() !== '';
                const requiresVoiceover = scriptScene.hasNarration !== false && hasNarrationText;

                // Scene is ready if: has visual AND (has voiceover OR doesn't need one)
                return hasVisual && (hasVoiceover || !requiresVoiceover);
            });

            // FULL-SCREEN SPLIT-PANEL LAYOUT
            let html = '';
            html += '<div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #0a0a14 0%, #141428 100%); z-index: 100; display: flex; flex-direction: column; overflow: hidden;">';

            // TOP HEADER BAR
            html += '<div style="flex-shrink: 0; display: flex; align-items: center; gap: 1rem; padding: 0.6rem 1.25rem; background: rgba(15,15,28,0.98); border-bottom: 1px solid rgba(139,92,246,0.2); backdrop-filter: blur(10px);">';
            html += '<div style="display: flex; align-items: center; gap: 0.75rem;">';
            html += '<div style="width: 36px; height: 36px; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border-radius: 0.5rem; display: flex; align-items: center; justify-content: center;">';
            html += '<span style="font-size: 1.1rem;"></span>';
            html += '</div>';
            html += '<div>';
            html += '<div style="font-weight: 700; color: white; font-size: 1rem; letter-spacing: -0.02em;">Animation Studio Pro</div>';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Generate voiceovers  Create animations</div>';
            html += '</div>';
            html += '</div>';

            // Progress Pills
            html += '<div style="display: flex; gap: 0.5rem; margin-left: 1.5rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.4rem; padding: 0.35rem 0.7rem; background: ' + (voiceoversReady >= storyboardScenes.length ? 'rgba(16,185,129,0.15)' : 'rgba(139,92,246,0.15)') + '; border: 1px solid ' + (voiceoversReady >= storyboardScenes.length ? 'rgba(16,185,129,0.3)' : 'rgba(139,92,246,0.3)') + '; border-radius: 2rem; font-size: 0.7rem;">';
            html += '<span></span>';
            html += '<span style="color: ' + (voiceoversReady >= storyboardScenes.length ? '#10b981' : '#a78bfa') + '; font-weight: 600;">' + voiceoversReady + '/' + storyboardScenes.length + '</span>';
            html += '</div>';
            html += '<div style="display: flex; align-items: center; gap: 0.4rem; padding: 0.35rem 0.7rem; background: rgba(6,182,212,0.15); border: 1px solid rgba(6,182,212,0.3); border-radius: 2rem; font-size: 0.7rem;">';
            html += '<span></span>';
            html += '<span style="color: #06b6d4; font-weight: 600;">' + animatedScenes + ' animated</span>';
            html += '</div>';
            html += '<div style="display: flex; align-items: center; gap: 0.4rem; padding: 0.35rem 0.7rem; background: rgba(16,185,129,0.15); border: 1px solid rgba(16,185,129,0.3); border-radius: 2rem; font-size: 0.7rem;">';
            html += '<span></span>';
            html += '<span style="color: #10b981; font-weight: 600;">' + readyScenes + ' ready</span>';
            html += '</div>';
            html += '</div>';

            // Right side buttons
            html += '<div style="margin-left: auto; display: flex; align-items: center; gap: 0.75rem;">';
            html += '<button onclick="goToStep(4)" style="display: flex; align-items: center; gap: 0.4rem; padding: 0.5rem 0.85rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.15); background: transparent; color: rgba(255,255,255,0.7); font-size: 0.75rem; cursor: pointer; transition: all 0.2s;">';
            html += '<span></span> Back';
            html += '</button>';
            var continueDisabled = !allScenesReady;
            html += '<button onclick="' + (allScenesReady ? 'goToStep(6)' : '') + '" ' + (continueDisabled ? 'disabled' : '') + ' style="display: flex; align-items: center; gap: 0.4rem; padding: 0.5rem 1rem; border-radius: 0.5rem; border: none; background: ' + (allScenesReady ? 'linear-gradient(135deg, #10b981, #059669)' : 'rgba(255,255,255,0.1)') + '; color: ' + (allScenesReady ? 'white' : 'rgba(255,255,255,0.4)') + '; font-size: 0.75rem; font-weight: 600; cursor: ' + (allScenesReady ? 'pointer' : 'not-allowed') + '; transition: all 0.2s;">';
            html += 'Continue <span></span>';
            html += '</button>';
            html += '</div>';
            html += '</div>';

            // MAIN SPLIT-PANEL CONTENT
            html += '<div style="flex: 1; display: grid; grid-template-columns: 280px 1fr; gap: 0; overflow: hidden;">';

            // LEFT PANEL - Scene Grid
            html += renderAnimationSceneGrid(scriptScenes, storyboardScenes, animationScenes);

            // RIGHT PANEL - Detail View
            html += renderAnimationDetailPanel(scriptScenes, storyboardScenes, animationScenes);

            html += '</div>';

            // BOTTOM BATCH QUEUE
            html += renderAnimationBatchQueue(animationScenes, storyboardScenes);

            html += '</div>';

            // OVERLAYS
            // Keyboard Shortcuts Overlay
            if (state.animation.showKeyboardShortcuts) {
                html += renderKeyboardShortcutsOverlay();
            }

            // Cinema Mode Overlay
            if (state.animation.cinemaMode) {
                html += renderCinemaModeOverlay(scriptScenes, storyboardScenes, animationScenes);
            }

            // Queue Manager Panel
            if (state.animation.showQueueManager) {
                html += renderQueueManagerPanel(animationScenes, storyboardScenes);
            }

            // Device Preview Modal
            html += renderDevicePreviewModal();

            // Floating Preview (PiP mode)
            html += renderFloatingPreview();

            return html;
        }

        // Keyboard Shortcuts Overlay
        function renderKeyboardShortcutsOverlay() {
            var html = '';
            html += '<div onclick="toggleKeyboardShortcuts()" style="position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 1000; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(8px);">';
            html += '<div onclick="event.stopPropagation()" style="background: linear-gradient(135deg, #1a1a2e, #16213e); border: 1px solid rgba(139,92,246,0.3); border-radius: 1rem; padding: 2rem; max-width: 600px; width: 90%; box-shadow: 0 25px 50px rgba(0,0,0,0.5);">';

            // Header
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.75rem;">';
            html += '<span style="font-size: 1.5rem;"></span>';
            html += '<span style="font-size: 1.25rem; font-weight: 700; color: white;">Keyboard Shortcuts</span>';
            html += '</div>';
            html += '<button onclick="toggleKeyboardShortcuts()" style="background: none; border: none; color: rgba(255,255,255,0.5); font-size: 1.5rem; cursor: pointer;"></button>';
            html += '</div>';

            // Shortcuts Grid
            html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">';

            var shortcuts = [
                { key: '/ or J/K', action: 'Navigate scenes' },
                { key: 'Space', action: 'Play/pause preview' },
                { key: 'V', action: 'Generate voiceover' },
                { key: 'Shift+V', action: 'Generate all voiceovers' },
                { key: 'A', action: 'Animate scene' },
                { key: 'Shift+A', action: 'Animate all scenes' },
                { key: '1-9', action: 'Jump to scene' },
                { key: 'C', action: 'Cinema mode' },
                { key: 'Q', action: 'Queue manager' },
                { key: 'B', action: 'A/B comparison' },
                { key: '?', action: 'Show shortcuts' },
                { key: 'ESC', action: 'Close overlays' }
            ];

            shortcuts.forEach(function(s) {
                html += '<div style="display: flex; align-items: center; gap: 0.75rem;">';
                html += '<kbd style="background: rgba(139,92,246,0.2); border: 1px solid rgba(139,92,246,0.4); padding: 0.35rem 0.6rem; border-radius: 0.35rem; font-family: monospace; font-size: 0.75rem; color: #a78bfa; min-width: 80px; text-align: center;">' + s.key + '</kbd>';
                html += '<span style="font-size: 0.85rem; color: rgba(255,255,255,0.7);">' + s.action + '</span>';
                html += '</div>';
            });

            html += '</div>';

            // Footer tip
            html += '<div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1); text-align: center;">';
            html += '<span style="font-size: 0.75rem; color: rgba(255,255,255,0.4);">Press <kbd style="background: rgba(255,255,255,0.1); padding: 0.2rem 0.4rem; border-radius: 0.25rem;">?</kbd> anytime to toggle this panel</span>';
            html += '</div>';

            html += '</div>';
            html += '</div>';
            return html;
        }

        // Cinema Mode Overlay
        function renderCinemaModeOverlay(scriptScenes, storyboardScenes, animationScenes) {
            var currentIdx = state.animation.cinemaModeSceneIndex;
            var scene = scriptScenes[currentIdx];
            var storyboardScene = storyboardScenes.find(function(s) { return s.sceneId === scene.id; }) || {};
            var animScene = animationScenes.find(function(s) { return s.sceneId === scene.id; }) || {};

            var html = '';
            html += '<div style="position: fixed; inset: 0; background: #000; z-index: 1000; display: flex; flex-direction: column;">';

            // Cinema Header
            html += '<div style="flex-shrink: 0; display: flex; align-items: center; justify-content: space-between; padding: 1rem 1.5rem; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);">';
            html += '<div style="display: flex; align-items: center; gap: 1rem;">';
            html += '<span style="font-size: 1.25rem;"></span>';
            html += '<span style="font-size: 1rem; font-weight: 600; color: white;">Cinema Preview</span>';
            html += '<span style="font-size: 0.85rem; color: rgba(255,255,255,0.5);">Scene ' + (currentIdx + 1) + ' of ' + scriptScenes.length + '</span>';
            html += '</div>';
            html += '<button onclick="exitCinemaMode()" style="background: rgba(255,255,255,0.1); border: none; color: white; padding: 0.5rem 1rem; border-radius: 0.5rem; cursor: pointer; font-size: 0.85rem;"> Exit (ESC)</button>';
            html += '</div>';

            // Main Preview Area
            html += '<div style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 2rem;">';
            html += '<div style="position: relative; max-width: 1200px; width: 100%; aspect-ratio: 16/9; background: #111; border-radius: 0.5rem; overflow: hidden;">';

            if (animScene.videoUrl) {
                html += '<video id="cinema-video" src="' + animScene.videoUrl + '" autoplay style="width: 100%; height: 100%; object-fit: contain;"></video>';
            } else if (storyboardScene.imageUrl) {
                html += '<img src="' + storyboardScene.imageUrl + '" style="width: 100%; height: 100%; object-fit: contain; animation: kenBurnsPreview 10s ease-in-out infinite alternate;">';
            }

            // Scene Info Overlay
            html += '<div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); padding: 3rem 2rem 1.5rem;">';
            html += '<div style="font-size: 1.1rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">Scene ' + (currentIdx + 1) + '</div>';
            html += '<div style="font-size: 0.9rem; color: rgba(255,255,255,0.7); line-height: 1.5;">"' + (scene.narration || '').substring(0, 150) + (scene.narration && scene.narration.length > 150 ? '...' : '') + '"</div>';
            html += '</div>';

            html += '</div>';
            html += '</div>';

            // Hidden audio element for voiceover
            if (animScene.voiceoverUrl) {
                html += '<audio id="cinema-audio" src="' + animScene.voiceoverUrl + '" autoplay></audio>';
            }

            // Bottom Controls
            html += '<div style="flex-shrink: 0; display: flex; align-items: center; justify-content: center; gap: 1rem; padding: 1.5rem; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);">';
            html += '<button onclick="cinemaModePrev()" ' + (currentIdx === 0 ? 'disabled' : '') + ' style="background: rgba(255,255,255,0.1); border: none; color: ' + (currentIdx === 0 ? 'rgba(255,255,255,0.3)' : 'white') + '; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: ' + (currentIdx === 0 ? 'not-allowed' : 'pointer') + '; font-size: 1rem;"> Previous</button>';
            html += '<button onclick="cinemaModePlayAll()" style="background: linear-gradient(135deg, #8b5cf6, #06b6d4); border: none; color: white; padding: 0.75rem 2rem; border-radius: 0.5rem; cursor: pointer; font-size: 1rem; font-weight: 600;"> Play All</button>';
            html += '<button onclick="cinemaModeNext()" ' + (currentIdx === scriptScenes.length - 1 ? 'disabled' : '') + ' style="background: rgba(255,255,255,0.1); border: none; color: ' + (currentIdx === scriptScenes.length - 1 ? 'rgba(255,255,255,0.3)' : 'white') + '; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: ' + (currentIdx === scriptScenes.length - 1 ? 'not-allowed' : 'pointer') + '; font-size: 1rem;">Next </button>';
            html += '</div>';

            // Scene Timeline
            html += '<div style="flex-shrink: 0; display: flex; align-items: center; gap: 0.5rem; padding: 0 2rem 1rem; overflow-x: auto;">';
            scriptScenes.forEach(function(s, idx) {
                var sb = storyboardScenes.find(function(x) { return x.sceneId === s.id; }) || {};
                var isActive = idx === currentIdx;
                html += '<div onclick="state.animation.cinemaModeSceneIndex=' + idx + ';render()" style="flex-shrink: 0; width: 80px; height: 45px; border-radius: 0.35rem; overflow: hidden; border: 2px solid ' + (isActive ? '#8b5cf6' : 'transparent') + '; cursor: pointer; opacity: ' + (isActive ? '1' : '0.5') + '; transition: all 0.2s;">';
                if (sb.imageUrl) {
                    html += '<img src="' + sb.imageUrl + '" style="width: 100%; height: 100%; object-fit: cover;">';
                } else {
                    html += '<div style="width: 100%; height: 100%; background: #333; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3);">' + (idx + 1) + '</div>';
                }
                html += '</div>';
            });
            html += '</div>';

            html += '</div>';
            return html;
        }

        // Queue Manager Panel
        function renderQueueManagerPanel(animationScenes, storyboardScenes) {
            var processing = animationScenes.filter(function(s) {
                return s.voiceoverStatus === 'generating' || s.animationStatus === 'generating';
            });
            var pending = animationScenes.filter(function(s) {
                return !s.voiceoverUrl && s.voiceoverStatus !== 'generating';
            });

            var html = '';
            html += '<div onclick="toggleQueueManager()" style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 1000; display: flex; align-items: center; justify-content: center;">';
            html += '<div onclick="event.stopPropagation()" style="background: linear-gradient(135deg, #1a1a2e, #16213e); border: 1px solid rgba(139,92,246,0.3); border-radius: 1rem; padding: 1.5rem; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">';

            // Header
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.75rem;">';
            html += '<span style="font-size: 1.25rem;"></span>';
            html += '<span style="font-size: 1.1rem; font-weight: 700; color: white;">Generation Queue</span>';
            html += '</div>';
            html += '<button onclick="toggleQueueManager()" style="background: none; border: none; color: rgba(255,255,255,0.5); font-size: 1.25rem; cursor: pointer;"></button>';
            html += '</div>';

            // Currently Processing
            if (processing.length > 0) {
                html += '<div style="margin-bottom: 1rem;">';
                html += '<div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">Currently Processing</div>';
                processing.forEach(function(scene) {
                    var sceneNum = storyboardScenes.findIndex(function(s) { return s.sceneId === scene.sceneId; }) + 1;
                    var type = scene.voiceoverStatus === 'generating' ? 'Voiceover' : 'Animation';
                    var icon = scene.voiceoverStatus === 'generating' ? '' : '';
                    html += '<div style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; background: rgba(139,92,246,0.15); border-radius: 0.5rem; margin-bottom: 0.5rem;">';
                    html += '<div class="animate-spin" style="width: 20px; height: 20px; border: 2px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%;"></div>';
                    html += '<span style="font-size: 1rem;">' + icon + '</span>';
                    html += '<span style="flex: 1; color: white; font-size: 0.85rem;">Scene ' + sceneNum + ' - ' + type + '</span>';
                    html += '</div>';
                });
                html += '</div>';
            }

            // Pending Queue
            if (pending.length > 0) {
                html += '<div>';
                html += '<div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">Pending (' + pending.length + ')</div>';
                pending.slice(0, 10).forEach(function(scene, idx) {
                    var sceneNum = storyboardScenes.findIndex(function(s) { return s.sceneId === scene.sceneId; }) + 1;
                    html += '<div style="display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; background: rgba(255,255,255,0.03); border-radius: 0.35rem; margin-bottom: 0.35rem;">';
                    html += '<span style="color: rgba(255,255,255,0.3); font-size: 0.75rem; width: 20px;">' + (idx + 1) + '</span>';
                    html += '<span style="flex: 1; color: rgba(255,255,255,0.7); font-size: 0.8rem;">Scene ' + sceneNum + '</span>';
                    html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.4);"> Voiceover</span>';
                    html += '</div>';
                });
                if (pending.length > 10) {
                    html += '<div style="text-align: center; font-size: 0.75rem; color: rgba(255,255,255,0.4); padding: 0.5rem;">+' + (pending.length - 10) + ' more</div>';
                }
                html += '</div>';
            }

            // Empty State
            if (processing.length === 0 && pending.length === 0) {
                html += '<div style="text-align: center; padding: 2rem; color: rgba(255,255,255,0.4);">';
                html += '<div style="font-size: 2rem; margin-bottom: 0.5rem;"></div>';
                html += '<div style="font-size: 0.9rem;">All generations complete!</div>';
                html += '</div>';
            }

            // Actions
            html += '<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 0.5rem;">';
            html += '<button onclick="generateAllVoiceovers(); toggleQueueManager();" style="flex: 1; padding: 0.6rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #8b5cf6, #a855f7); color: white; font-size: 0.8rem; font-weight: 600; cursor: pointer;"> Generate All</button>';
            html += '<button onclick="animateAllScenes(); toggleQueueManager();" style="flex: 1; padding: 0.6rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #06b6d4, #10b981); color: white; font-size: 0.8rem; font-weight: 600; cursor: pointer;"> Animate All</button>';
            html += '</div>';

            html += '</div>';
            html += '</div>';
            return html;
        }

        // LEFT PANEL - Compact Scene Grid with Progress Rings, Hover Actions, Multi-Select, Drag & Drop
        function renderAnimationSceneGrid(scriptScenes, storyboardScenes, animationScenes) {
            var html = '';
            var selectedIds = state.animation.selectedSceneIds || [];
            var hasMultiSelect = selectedIds.length > 1;

            html += '<div style="background: rgba(15,15,28,0.98); border-right: 1px solid rgba(255,255,255,0.08); display: flex; flex-direction: column; overflow: hidden;">';

            // Scene Grid Header
            html += '<div style="padding: 0.85rem 1rem; border-bottom: 1px solid rgba(255,255,255,0.08);">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.6rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 0.75rem; font-weight: 600; color: white; text-transform: uppercase; letter-spacing: 0.5px;">Scenes</span>';
            if (hasMultiSelect) {
                html += '<span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(139,92,246,0.3); color: #a78bfa; border-radius: 1rem;">' + selectedIds.length + ' selected</span>';
            }
            html += '</div>';
            html += '<div style="display: flex; align-items: center; gap: 0.35rem;">';
            html += '<button onclick="toggleKeyboardShortcuts()" title="Keyboard shortcuts (?)" style="width: 22px; height: 22px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.15); background: transparent; color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.65rem;"></button>';
            html += '<button onclick="enterCinemaMode()" title="Cinema mode (C)" style="width: 22px; height: 22px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.15); background: transparent; color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.65rem;"></button>';
            html += '<button onclick="toggleQueueManager()" title="Queue manager (Q)" style="width: 22px; height: 22px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.15); background: transparent; color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.65rem;"></button>';
            html += '</div>';
            html += '</div>';

            // Quick Actions - Different for multi-select vs normal
            if (hasMultiSelect) {
                html += '<div style="display: flex; gap: 0.4rem; margin-bottom: 0.5rem;">';
                html += '<button onclick="batchGenerateVoiceovers()" style="flex: 1; padding: 0.4rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #8b5cf6, #a855f7); color: white; font-size: 0.6rem; font-weight: 600; cursor: pointer;"> Voice (' + selectedIds.length + ')</button>';
                html += '<button onclick="batchAnimateScenes()" style="flex: 1; padding: 0.4rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #06b6d4, #10b981); color: white; font-size: 0.6rem; font-weight: 600; cursor: pointer;"> Anim (' + selectedIds.length + ')</button>';
                html += '</div>';
                html += '<button onclick="clearMultiSelection()" style="width: 100%; padding: 0.35rem; border-radius: 0.35rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: rgba(255,255,255,0.6); font-size: 0.6rem; cursor: pointer;"> Clear Selection</button>';
            } else {
                html += '<div style="display: flex; gap: 0.4rem;">';
                html += '<button onclick="generateAllVoiceovers()" style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 0.3rem; padding: 0.45rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #8b5cf6, #a855f7); color: white; font-size: 0.65rem; font-weight: 600; cursor: pointer;">';
                html += '<span></span> All Voices';
                html += '</button>';
                html += '<button onclick="animateAllScenes()" style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 0.3rem; padding: 0.45rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #06b6d4, #10b981); color: white; font-size: 0.65rem; font-weight: 600; cursor: pointer;">';
                html += '<span></span> All Anim';
                html += '</button>';
                html += '</div>';
            }
            html += '</div>';

            // Hint for multi-select
            html += '<div style="padding: 0.35rem 1rem; background: rgba(139,92,246,0.05); border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 0.55rem; color: rgba(255,255,255,0.35);"> Ctrl+Click to multi-select  Drag to reorder</div>';

            // Scrollable Scene List
            html += '<div style="flex: 1; overflow-y: auto; padding: 0.5rem;">';

            scriptScenes.forEach(function(scriptScene, index) {
                var storyboardScene = storyboardScenes.find(function(s) { return s.sceneId === scriptScene.id; }) || {};
                var animScene = animationScenes.find(function(s) { return s.sceneId === scriptScene.id; }) || {};
                var isSelected = state.animation.selectedSceneId === scriptScene.id;
                var isMultiSelected = selectedIds.indexOf(scriptScene.id) > -1;
                var hasVoiceover = !!animScene.voiceoverUrl;
                var hasAnimation = !!animScene.videoUrl;
                var isVoiceGenerating = animScene.voiceoverStatus === 'generating';
                var isAnimGenerating = animScene.animationStatus === 'generating';
                var isProcessing = isVoiceGenerating || isAnimGenerating;
                var imageUrl = storyboardScene.imageUrl || '';
                var isDropTarget = state.animation.dropTargetIndex === index;
                var isDragging = state.animation.draggedSceneId === scriptScene.id;

                // Calculate progress percentage for ring
                var progress = 0;
                if (hasVoiceover && hasAnimation) progress = 100;
                else if (hasVoiceover) progress = 50;
                else if (isProcessing) progress = 25;

                // Progress ring SVG
                var ringRadius = 26;
                var ringCircumference = 2 * Math.PI * ringRadius;
                var ringOffset = ringCircumference - (progress / 100) * ringCircumference;
                var ringColor = progress === 100 ? '#10b981' : progress >= 50 ? '#fbbf24' : isProcessing ? '#8b5cf6' : '#ef4444';

                // Drop target indicator
                if (isDropTarget && !isDragging) {
                    html += '<div style="height: 3px; background: linear-gradient(90deg, #8b5cf6, #06b6d4); border-radius: 2px; margin-bottom: 0.25rem;"></div>';
                }

                html += '<div class="scene-card-hover" draggable="true" ondragstart="handleSceneDragStart(' + scriptScene.id + ', event)" ondragend="handleSceneDragEnd(event)" ondragover="handleSceneDragOver(' + index + ', event)" ondrop="handleSceneDrop(' + index + ', event)" onclick="toggleSceneSelection(' + scriptScene.id + ', event)" style="position: relative; display: flex; gap: 0.6rem; padding: 0.5rem; margin-bottom: 0.4rem; background: ' + (isSelected || isMultiSelected ? 'rgba(139,92,246,0.2)' : 'rgba(255,255,255,0.03)') + '; border: 1px solid ' + (isSelected ? 'rgba(139,92,246,0.5)' : isMultiSelected ? 'rgba(139,92,246,0.3)' : 'rgba(255,255,255,0.06)') + '; border-radius: 0.5rem; cursor: grab; transition: all 0.15s; opacity: ' + (isDragging ? '0.5' : '1') + ';">';

                // Multi-select checkbox indicator
                if (hasMultiSelect || isMultiSelected) {
                    html += '<div style="position: absolute; top: -4px; left: -4px; width: 16px; height: 16px; background: ' + (isMultiSelected ? '#8b5cf6' : 'rgba(255,255,255,0.1)') + '; border: 2px solid ' + (isMultiSelected ? '#8b5cf6' : 'rgba(255,255,255,0.2)') + '; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: white; z-index: 1;">' + (isMultiSelected ? '' : '') + '</div>';
                }

                // Thumbnail with Progress Ring
                html += '<div style="position: relative; width: 60px; height: 60px; flex-shrink: 0;">';

                // SVG Progress Ring
                html += '<svg style="position: absolute; top: -2px; left: -2px; width: 64px; height: 64px; transform: rotate(-90deg);">';
                html += '<circle cx="32" cy="32" r="' + ringRadius + '" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="3"/>';
                if (isProcessing) {
                    html += '<circle cx="32" cy="32" r="' + ringRadius + '" fill="none" stroke="' + ringColor + '" stroke-width="3" stroke-linecap="round" stroke-dasharray="' + ringCircumference + '" stroke-dashoffset="' + (ringCircumference * 0.7) + '" class="animate-spin" style="transform-origin: center;"/>';
                } else {
                    html += '<circle cx="32" cy="32" r="' + ringRadius + '" fill="none" stroke="' + ringColor + '" stroke-width="3" stroke-linecap="round" stroke-dasharray="' + ringCircumference + '" stroke-dashoffset="' + ringOffset + '" style="transition: stroke-dashoffset 0.3s;"/>';
                }
                html += '</svg>';

                // Inner thumbnail
                html += '<div style="position: absolute; top: 4px; left: 4px; width: 52px; height: 52px; border-radius: 0.35rem; overflow: hidden; background: rgba(0,0,0,0.3);">';
                if (imageUrl) {
                    html += '<img src="' + imageUrl + '" style="width: 100%; height: 100%; object-fit: cover;">';
                } else {
                    html += '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3); font-size: 1.1rem;"></div>';
                }

                // Hover Quick Actions Overlay
                html += '<div class="hover-actions" style="position: absolute; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; gap: 0.2rem;">';
                html += '<button onclick="event.stopPropagation(); generateSceneVoiceover(' + scriptScene.id + ')" title="Generate voiceover" style="width: 22px; height: 22px; border-radius: 50%; border: none; background: rgba(139,92,246,0.9); color: white; cursor: pointer; font-size: 0.6rem; display: flex; align-items: center; justify-content: center;"></button>';
                html += '<button onclick="event.stopPropagation(); animateScene(' + scriptScene.id + ')" title="Animate" style="width: 22px; height: 22px; border-radius: 50%; border: none; background: rgba(6,182,212,0.9); color: white; cursor: pointer; font-size: 0.6rem; display: flex; align-items: center; justify-content: center;"></button>';
                html += '</div>';

                html += '</div>';

                // Scene number badge
                html += '<div style="position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.55rem; font-weight: 700; color: white; z-index: 2;">' + (index + 1) + '</div>';
                html += '</div>';

                // Scene Info
                html += '<div style="flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center;">';
                html += '<div style="font-size: 0.7rem; color: white; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 0.25rem;">Scene ' + (index + 1) + '</div>';

                // Progress indicator text
                html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-bottom: 0.2rem;">' + progress + '% complete</div>';

                // Status badges
                html += '<div style="display: flex; gap: 0.25rem; flex-wrap: wrap;">';
                if (hasVoiceover) {
                    html += '<span style="font-size: 0.55rem; padding: 0.1rem 0.3rem; background: rgba(139,92,246,0.3); color: #a78bfa; border-radius: 0.2rem;"></span>';
                }
                if (hasAnimation) {
                    html += '<span style="font-size: 0.55rem; padding: 0.1rem 0.3rem; background: rgba(6,182,212,0.3); color: #06b6d4; border-radius: 0.2rem;"></span>';
                }
                if (isVoiceGenerating) {
                    html += '<span style="font-size: 0.55rem; padding: 0.1rem 0.3rem; background: rgba(139,92,246,0.3); color: #a78bfa; border-radius: 0.2rem;" class="animate-pulse">...</span>';
                }
                if (isAnimGenerating) {
                    html += '<span style="font-size: 0.55rem; padding: 0.1rem 0.3rem; background: rgba(6,182,212,0.3); color: #06b6d4; border-radius: 0.2rem;" class="animate-pulse">...</span>';
                }
                html += '</div>';
                html += '</div>';

                html += '</div>';
            });

            html += '</div>';
            html += '</div>';
            return html;
        }

        // RIGHT PANEL - Detail View with Preview
        function renderAnimationDetailPanel(scriptScenes, storyboardScenes, animationScenes) {
            var selectedId = state.animation.selectedSceneId;
            var scriptScene = scriptScenes.find(function(s) { return s.id === selectedId; });
            var storyboardScene = storyboardScenes.find(function(s) { return s.sceneId === selectedId; }) || {};
            var animScene = animationScenes.find(function(s) { return s.sceneId === selectedId; }) || {};

            if (!scriptScene) {
                return '<div style="flex: 1; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.4);">Select a scene</div>';
            }

            var sceneIndex = scriptScenes.findIndex(function(s) { return s.id === selectedId; });
            var imageUrl = storyboardScene.imageUrl || '';
            var videoUrl = animScene.videoUrl || '';
            var voiceoverUrl = animScene.voiceoverUrl || '';
            var voiceoverStatus = animScene.voiceoverStatus || 'idle';
            var animationStatus = animScene.animationStatus || 'idle';
            var animationType = animScene.animationType || 'ken_burns';
            var narration = scriptScene.narration || '';  // Empty if no narration, not a default string

            var html = '';
            html += '<div style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(10,10,20,0.5);">';

            // Preview Section
            html += '<div style="flex: 1; display: flex; flex-direction: column; padding: 1.25rem; overflow-y: auto;">';

            // Preview Header
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; max-width: 640px; margin-left: auto; margin-right: auto; width: 100%;">';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 0.75rem; font-weight: 600; color: white; text-transform: uppercase; letter-spacing: 0.5px;"> Scene Preview</span>';
            if (videoUrl) {
                html += '<span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(16,185,129,0.2); color: #10b981; border-radius: 1rem; font-weight: 600;">Animated</span>';
            } else if (imageUrl) {
                html += '<span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(6,182,212,0.2); color: #06b6d4; border-radius: 1rem; font-weight: 600;">Ken Burns</span>';
            }
            html += '</div>';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            // PiP Toggle Button
            var isPipEnabled = state.animation.floatingPreview && state.animation.floatingPreview.enabled;
            html += '<button onclick="toggleFloatingPreview()" title="' + (isPipEnabled ? 'Exit Picture-in-Picture' : 'Picture-in-Picture mode') + '" style="display: flex; align-items: center; gap: 0.3rem; padding: 0.3rem 0.6rem; border-radius: 0.35rem; border: 1px solid ' + (isPipEnabled ? 'rgba(16,185,129,0.5)' : 'rgba(6,182,212,0.3)') + '; background: ' + (isPipEnabled ? 'rgba(16,185,129,0.2)' : 'rgba(6,182,212,0.1)') + '; color: ' + (isPipEnabled ? '#10b981' : '#06b6d4') + '; font-size: 0.65rem; cursor: pointer; transition: all 0.2s;">';
            html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2"/><rect x="11" y="9" width="10" height="8" rx="1" fill="currentColor" opacity="0.3"/></svg>';
            html += isPipEnabled ? 'Exit PiP' : 'PiP';
            html += '</button>';
            // Device Preview Button
            html += '<button onclick="openDevicePreview()" style="display: flex; align-items: center; gap: 0.3rem; padding: 0.3rem 0.6rem; border-radius: 0.35rem; border: 1px solid rgba(139,92,246,0.3); background: rgba(139,92,246,0.1); color: #a78bfa; font-size: 0.65rem; cursor: pointer; transition: all 0.2s;" onmouseenter="this.style.background=\'rgba(139,92,246,0.2)\'" onmouseleave="this.style.background=\'rgba(139,92,246,0.1)\'">';
            html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>';
            html += 'Preview';
            html += '</button>';
            html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">Scene ' + (sceneIndex + 1) + ' of ' + scriptScenes.length + '</div>';
            html += '</div>';
            html += '</div>';

            // Main Preview Container - Single Scene Display
            html += '<div style="position: relative; width: 100%; max-width: 640px; margin: 0 auto; aspect-ratio: 16/9; background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(20,20,40,0.6)); border-radius: 0.75rem; overflow: hidden; border: 2px solid rgba(139,92,246,0.3); box-shadow: 0 8px 32px rgba(0,0,0,0.4);">';

            if (videoUrl) {
                // Animated video preview
                html += '<video id="detail-preview-video" src="' + videoUrl + '" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;"></video>';
                html += '<div onclick="playDetailPreview()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); cursor: pointer; transition: background 0.2s;" onmouseenter="this.style.background=\'rgba(0,0,0,0.1)\'" onmouseleave="this.style.background=\'rgba(0,0,0,0.3)\'">';
                html += '<div style="width: 70px; height: 70px; background: rgba(16,185,129,0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(16,185,129,0.4);">';
                html += '<span style="font-size: 1.75rem; margin-left: 4px;"></span>';
                html += '</div>';
                html += '</div>';
                html += '<div style="position: absolute; top: 0.75rem; right: 0.75rem; background: rgba(16,185,129,0.9); padding: 0.35rem 0.7rem; border-radius: 0.35rem; font-size: 0.7rem; font-weight: 700; color: white; box-shadow: 0 2px 8px rgba(16,185,129,0.3);"> ANIMATED</div>';
            } else if (imageUrl) {
                // Static image with Ken Burns preview - SINGLE SCENE ONLY
                html += '<div id="ken-burns-preview" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden;">';
                html += '<img src="' + imageUrl + '" style="width: 115%; height: 115%; object-fit: cover; object-position: center; animation: kenBurnsPreview 8s ease-in-out infinite alternate; transform-origin: center center;">';
                html += '</div>';
                // Status overlay for generating
                if (animationStatus === 'generating') {
                    html += '<div style="position: absolute; inset: 0; background: rgba(0,0,0,0.75); display: flex; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(4px);">';
                    html += '<div class="animate-spin" style="width: 48px; height: 48px; border: 3px solid rgba(6,182,212,0.3); border-top-color: #06b6d4; border-radius: 50%; margin-bottom: 1rem;"></div>';
                    html += '<div style="color: white; font-size: 0.9rem; font-weight: 600;">Generating Animation...</div>';
                    html += '<div style="color: rgba(255,255,255,0.5); font-size: 0.75rem; margin-top: 0.25rem;">This may take a moment</div>';
                    html += '</div>';
                } else {
                    // Play hint overlay when not generating
                    html += '<div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s; background: rgba(0,0,0,0.2);" onmouseenter="this.style.opacity=1" onmouseleave="this.style.opacity=0">';
                    html += '<div style="padding: 0.5rem 1rem; background: rgba(0,0,0,0.7); border-radius: 0.5rem; backdrop-filter: blur(4px);">';
                    html += '<span style="color: white; font-size: 0.75rem;"> Ken Burns Effect Preview</span>';
                    html += '</div>';
                    html += '</div>';
                }
            } else {
                // No image placeholder
                html += '<div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3);">';
                html += '<div style="text-align: center;">';
                html += '<div style="font-size: 3.5rem; margin-bottom: 0.75rem;"></div>';
                html += '<div style="font-size: 0.9rem; font-weight: 500;">No storyboard image</div>';
                html += '<div style="font-size: 0.75rem; color: rgba(255,255,255,0.2); margin-top: 0.25rem;">Generate images in Step 4</div>';
                html += '</div>';
                html += '</div>';
            }

            // Scene info overlay at bottom
            html += '<div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.85), transparent); padding: 2rem 1rem 0.85rem;">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between;">';
            html += '<div>';
            html += '<div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.2rem;">Scene ' + (sceneIndex + 1) + '</div>';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">' + (scriptScene.duration || 8) + 's duration</div>';
            html += '</div>';
            // Quick action buttons
            html += '<div style="display: flex; gap: 0.4rem;">';
            if (!videoUrl && imageUrl) {
                html += '<button onclick="animateScene(' + scriptScene.id + ')" style="padding: 0.4rem 0.7rem; border-radius: 0.4rem; border: none; background: rgba(6,182,212,0.9); color: white; font-size: 0.7rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 0.3rem;"> Animate</button>';
            }
            html += '</div>';
            html += '</div>';
            html += '</div>';
            html += '</div>';

            // Mini Timeline Scrubber
            html += '<div style="margin-top: 0.75rem; max-width: 640px; margin-left: auto; margin-right: auto; width: 100%;">';
            html += renderMiniTimelineScrubber(scriptScenes, storyboardScenes, sceneIndex);
            html += '</div>';

            // Audio Waveform / Voiceover Section (Enhanced)
            html += '<div style="margin-top: 1rem; max-width: 640px; margin-left: auto; margin-right: auto; width: 100%;">';
            html += renderVoiceoverSectionPro(scriptScene, animScene, voiceoverUrl, voiceoverStatus, narration, storyboardScene);
            html += '</div>';

            // Animation Style Gallery with Smart Suggestions
            html += '<div style="margin-top: 1rem; max-width: 640px; margin-left: auto; margin-right: auto; width: 100%;">';
            html += renderAnimationStyleGalleryPro(scriptScene.id, animationType, !!voiceoverUrl, animationStatus, storyboardScene);
            html += '</div>';

            // Quick Audio Configuration Panel
            html += '<div style="margin-top: 1rem; max-width: 640px; margin-left: auto; margin-right: auto; width: 100%;">';
            html += renderQuickAudioPanel();
            html += '</div>';

            html += '</div>';
            html += '</div>';

            return html;
        }

        // Quick Audio Configuration Panel for Animation Studio Pro
        function renderQuickAudioPanel() {
            const genreProfile = state.assembly.genreProfile || {};
            const audioMood = state.assembly.audioMood || 'Not set';
            const musicEnabled = state.assembly.music?.enabled || false;
            const selectedTrackId = state.assembly.music?.trackId;
            const musicVolume = state.assembly.music?.volume || 30;
            const voiceVolume = state.assembly.audioMix?.voiceVolume || 100;
            const ducking = state.assembly.audioMix?.ducking !== false;
            const genreId = state.content.genre;

            // Get genre-specific music recommendations
            const profile = genreId ? GENRE_PRODUCTION_PROFILES[genreId] : null;
            const recommendedMoods = profile?.musicMood || [];
            const recommendedCategory = profile?.musicCategory || '';

            let html = '';
            html += '<div style="background: linear-gradient(135deg, rgba(245,158,11,0.1), rgba(236,72,153,0.1)); border: 1px solid rgba(245,158,11,0.25); border-radius: 0.75rem; padding: 1rem;">';

            // Header with AI badge
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 1rem;"></span>';
            html += '<span style="font-size: 0.85rem; font-weight: 600; color: white;">Audio & Music</span>';
            html += '<span style="font-size: 0.5rem; padding: 0.15rem 0.35rem; background: linear-gradient(135deg, #f59e0b, #ec4899); border-radius: 0.2rem; color: white; font-weight: 600;">AUTO</span>';
            html += '</div>';
            html += '<button onclick="goToStep(6)" style="font-size: 0.6rem; padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: rgba(255,255,255,0.6); cursor: pointer;">Full Editor </button>';
            html += '</div>';

            // Genre-based recommendation info
            if (profile) {
                html += '<div style="background: rgba(0,0,0,0.2); border-radius: 0.4rem; padding: 0.6rem; margin-bottom: 0.75rem;">';
                html += '<div style="display: flex; align-items: center; gap: 0.35rem; margin-bottom: 0.35rem;">';
                html += '<span style="font-size: 0.65rem; color: #f59e0b;"></span>';
                html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.7);">Based on your <strong style="color: #f59e0b;">' + genreId.replace(/-/g, ' ') + '</strong> genre:</span>';
                html += '</div>';
                html += '<div style="display: flex; flex-wrap: wrap; gap: 0.35rem;">';
                html += '<span style="font-size: 0.6rem; padding: 0.2rem 0.4rem; background: rgba(245,158,11,0.2); border-radius: 0.2rem; color: #fbbf24;"> ' + audioMood + ' mood</span>';
                html += '<span style="font-size: 0.6rem; padding: 0.2rem 0.4rem; background: rgba(139,92,246,0.2); border-radius: 0.2rem; color: #a78bfa;"> ' + recommendedCategory + '</span>';
                recommendedMoods.slice(0, 2).forEach(function(mood) {
                    html += '<span style="font-size: 0.6rem; padding: 0.2rem 0.4rem; background: rgba(6,182,212,0.2); border-radius: 0.2rem; color: #22d3ee;">' + mood + '</span>';
                });
                html += '</div>';
                html += '</div>';
            }

            // Quick Controls Grid
            html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">';

            // Music Toggle
            html += '<div style="background: rgba(0,0,0,0.15); border-radius: 0.4rem; padding: 0.6rem;">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.4rem;">';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.7);"> Music</span>';
            const musicToggleBg = musicEnabled ? '#8b5cf6' : 'rgba(255,255,255,0.2)';
            const musicTogglePos = musicEnabled ? '15px' : '2px';
            html += '<label style="position: relative; display: inline-block; width: 32px; height: 18px;">';
            html += '<input type="checkbox" ' + (musicEnabled ? 'checked' : '') + ' onchange="toggleMusic(this.checked); render();" style="opacity: 0; width: 0; height: 0;">';
            html += '<span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: ' + musicToggleBg + '; transition: 0.2s; border-radius: 18px;">';
            html += '<span style="position: absolute; height: 14px; width: 14px; left: ' + musicTogglePos + '; bottom: 2px; background-color: white; transition: 0.2s; border-radius: 50%;"></span>';
            html += '</span>';
            html += '</label>';
            html += '</div>';
            html += '<input type="range" min="0" max="100" value="' + musicVolume + '" onchange="setMusicVolume(this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #8b5cf6;" ' + (!musicEnabled ? 'disabled' : '') + '>';
            html += '<div style="font-size: 0.55rem; color: rgba(255,255,255,0.4); text-align: right; margin-top: 0.2rem;">' + musicVolume + '%</div>';
            html += '</div>';

            // Voice Volume
            html += '<div style="background: rgba(0,0,0,0.15); border-radius: 0.4rem; padding: 0.6rem;">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.4rem;">';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.7);"> Voice</span>';
            html += '<span style="font-size: 0.6rem; color: #06b6d4;">' + voiceVolume + '%</span>';
            html += '</div>';
            html += '<input type="range" min="0" max="100" value="' + voiceVolume + '" onchange="setVoiceVolume(this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #06b6d4;">';
            html += '</div>';

            html += '</div>';

            // Auto-ducking toggle
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-top: 0.75rem; padding: 0.5rem; background: rgba(0,0,0,0.1); border-radius: 0.35rem;">';
            html += '<div>';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.7);">Auto-Duck</span>';
            html += '<div style="font-size: 0.55rem; color: rgba(255,255,255,0.4);">Lower music during voiceover</div>';
            html += '</div>';
            const duckingBg = ducking ? '#10b981' : 'rgba(255,255,255,0.2)';
            const duckingPos = ducking ? '15px' : '2px';
            html += '<label style="position: relative; display: inline-block; width: 32px; height: 18px;">';
            html += '<input type="checkbox" ' + (ducking ? 'checked' : '') + ' onchange="setAudioDucking(this.checked)" style="opacity: 0; width: 0; height: 0;">';
            html += '<span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: ' + duckingBg + '; transition: 0.2s; border-radius: 18px;">';
            html += '<span style="position: absolute; height: 14px; width: 14px; left: ' + duckingPos + '; bottom: 2px; background-color: white; transition: 0.2s; border-radius: 50%;"></span>';
            html += '</span>';
            html += '</label>';
            html += '</div>';

            // Sync button
            if (genreId) {
                html += '<button onclick="resyncWithGenre()" style="width: 100%; margin-top: 0.75rem; padding: 0.5rem; border-radius: 0.4rem; border: 1px dashed rgba(245,158,11,0.4); background: transparent; color: #fbbf24; font-size: 0.7rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.3rem;">';
                html += '<span></span> Re-sync all settings with genre';
                html += '</button>';
            }

            html += '</div>';
            return html;
        }

        // Mini Timeline Scrubber
        function renderMiniTimelineScrubber(scriptScenes, storyboardScenes, currentIndex) {
            var html = '';
            html += '<div style="background: rgba(0,0,0,0.3); border-radius: 0.5rem; padding: 0.6rem;">';

            // Timeline header
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.5); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;">Timeline</span>';
            html += '<span style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">Scene ' + (currentIndex + 1) + ' of ' + scriptScenes.length + '</span>';
            html += '</div>';

            // Timeline thumbnails
            html += '<div style="display: flex; gap: 0.25rem; overflow-x: auto; padding-bottom: 0.25rem;">';
            scriptScenes.forEach(function(scene, idx) {
                var sb = storyboardScenes.find(function(s) { return s.sceneId === scene.id; }) || {};
                var isActive = idx === currentIndex;
                html += '<div onclick="selectAnimationScene(' + scene.id + ')" style="flex-shrink: 0; width: 48px; height: 27px; border-radius: 0.25rem; overflow: hidden; border: 2px solid ' + (isActive ? '#8b5cf6' : 'transparent') + '; cursor: pointer; opacity: ' + (isActive ? '1' : '0.6') + '; transition: all 0.15s;">';
                if (sb.imageUrl) {
                    html += '<img src="' + sb.imageUrl + '" style="width: 100%; height: 100%; object-fit: cover;">';
                } else {
                    html += '<div style="width: 100%; height: 100%; background: rgba(255,255,255,0.05); display: flex; align-items: center; justify-content: center; font-size: 0.5rem; color: rgba(255,255,255,0.3);">' + (idx + 1) + '</div>';
                }
                html += '</div>';
            });
            html += '</div>';

            html += '</div>';
            return html;
        }

        // Voiceover Section with Waveform
        function renderVoiceoverSection(scriptScene, animScene, voiceoverUrl, voiceoverStatus, narration) {
            var voice = animScene.voice || state.animation.voiceover.voice || 'alloy';
            var speed = animScene.speed || state.animation.voiceover.speed || 1.0;

            var html = '';
            html += '<div style="background: rgba(139,92,246,0.08); border: 1px solid rgba(139,92,246,0.2); border-radius: 0.75rem; padding: 1rem;">';

            // Header
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 1rem;"></span>';
            html += '<span style="font-size: 0.85rem; font-weight: 600; color: white;">Voiceover</span>';
            if (voiceoverStatus === 'ready') {
                html += '<span style="font-size: 0.65rem; padding: 0.2rem 0.5rem; background: rgba(16,185,129,0.2); color: #10b981; border-radius: 1rem; font-weight: 600;">Ready</span>';
            } else if (voiceoverStatus === 'generating') {
                html += '<span style="font-size: 0.65rem; padding: 0.2rem 0.5rem; background: rgba(251,191,36,0.2); color: #fbbf24; border-radius: 1rem; font-weight: 600;" class="animate-pulse">Generating...</span>';
            }
            html += '</div>';
            html += '</div>';

            // Narration text
            html += '<div style="background: rgba(0,0,0,0.2); border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 0.75rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.35rem;">NARRATION</div>';
            html += '<div style="font-size: 0.8rem; color: rgba(255,255,255,0.85); line-height: 1.5; font-style: italic;">"' + narration.substring(0, 200) + (narration.length > 200 ? '...' : '') + '"</div>';
            html += '</div>';

            // Audio Player / Waveform
            if (voiceoverUrl) {
                html += '<div style="margin-bottom: 0.75rem;">';
                // Waveform visualization (simplified bars)
                html += '<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">';
                html += '<button onclick="toggleVoiceoverPlayback(' + scriptScene.id + ')" style="width: 36px; height: 36px; border-radius: 50%; border: none; background: linear-gradient(135deg, #8b5cf6, #a855f7); color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.9rem;"></button>';
                html += '<div id="waveform-' + scriptScene.id + '" style="flex: 1; height: 32px; background: rgba(139,92,246,0.15); border-radius: 0.25rem; display: flex; align-items: center; gap: 2px; padding: 0 0.5rem; overflow: hidden;">';
                // Generate waveform bars
                for (var i = 0; i < 40; i++) {
                    var barHeight = 20 + Math.random() * 60;
                    html += '<div style="flex: 1; height: ' + barHeight + '%; background: linear-gradient(to top, #8b5cf6, #a855f7); border-radius: 1px; min-width: 2px;"></div>';
                }
                html += '</div>';
                html += '</div>';
                html += '<audio id="voiceover-audio-' + scriptScene.id + '" src="' + voiceoverUrl + '" style="display: none;"></audio>';
                html += '</div>';
            }

            // Voice Controls
            html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">';

            // Voice Selection with Preview
            html += '<div>';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.35rem;">Voice</label>';
            html += '<div style="display: flex; gap: 0.35rem;">';
            html += '<select onchange="setSceneVoice(' + scriptScene.id + ', this.value)" style="flex: 1; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.4rem; color: white; font-size: 0.75rem; cursor: pointer;">';
            var voices = ['alloy', 'nova', 'shimmer', 'echo', 'onyx', 'fable'];
            voices.forEach(function(v) {
                html += '<option value="' + v + '" ' + (voice === v ? 'selected' : '') + '>' + v.charAt(0).toUpperCase() + v.slice(1) + '</option>';
            });
            html += '</select>';
            html += '<button onclick="previewVoice(\'' + voice + '\')" style="width: 36px; padding: 0.5rem; background: rgba(139,92,246,0.2); border: 1px solid rgba(139,92,246,0.3); border-radius: 0.4rem; color: #a78bfa; cursor: pointer; font-size: 0.8rem;" title="Preview voice"></button>';
            html += '</div>';
            html += '</div>';

            // Speed Control
            html += '<div>';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.35rem;">Speed: ' + speed.toFixed(1) + 'x</label>';
            html += '<input type="range" min="0.5" max="2.0" step="0.1" value="' + speed + '" onchange="setSceneSpeed(' + scriptScene.id + ', this.value)" style="width: 100%; height: 6px; cursor: pointer; accent-color: #8b5cf6;">';
            html += '</div>';
            html += '</div>';

            // Generate Button
            var isGenerating = voiceoverStatus === 'generating';
            html += '<button onclick="generateSceneVoiceover(' + scriptScene.id + ')" ' + (isGenerating ? 'disabled' : '') + ' style="width: 100%; padding: 0.65rem; border-radius: 0.5rem; border: none; background: ' + (isGenerating ? 'rgba(255,255,255,0.1)' : 'linear-gradient(135deg, #8b5cf6, #a855f7)') + '; color: ' + (isGenerating ? 'rgba(255,255,255,0.4)' : 'white') + '; font-size: 0.8rem; font-weight: 600; cursor: ' + (isGenerating ? 'wait' : 'pointer') + '; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">';
            if (isGenerating) {
                html += '<span class="animate-spin"></span> Generating...';
            } else if (voiceoverUrl) {
                html += '<span></span> Regenerate Voiceover';
            } else {
                html += '<span></span> Generate Voiceover';
            }
            html += '</button>';

            html += '</div>';
            return html;
        }

        // Animation Style Gallery
        function renderAnimationStyleGallery(sceneId, currentType, hasVoiceover, animationStatus) {
            var styles = [
                { id: 'ken_burns', name: 'Ken Burns', desc: 'Smooth zoom & pan', icon: '', color: '#06b6d4' },
                { id: 'talking_head', name: 'Talking Head', desc: 'Subtle movement', icon: '', color: '#8b5cf6' },
                { id: 'static', name: 'Static', desc: 'No animation', icon: '', color: '#6b7280' }
            ];

            var html = '';
            html += '<div style="background: rgba(6,182,212,0.08); border: 1px solid rgba(6,182,212,0.2); border-radius: 0.75rem; padding: 1rem;">';

            // Header
            html += '<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">';
            html += '<span style="font-size: 1rem;"></span>';
            html += '<span style="font-size: 0.85rem; font-weight: 600; color: white;">Animation Style</span>';
            html += '</div>';

            // Style Cards Grid
            html += '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 0.75rem;">';

            styles.forEach(function(style) {
                var isSelected = currentType === style.id;
                html += '<div onclick="setSceneAnimationType(' + sceneId + ', \'' + style.id + '\')" style="padding: 0.6rem; background: ' + (isSelected ? 'rgba(6,182,212,0.2)' : 'rgba(255,255,255,0.03)') + '; border: 1px solid ' + (isSelected ? style.color : 'rgba(255,255,255,0.08)') + '; border-radius: 0.5rem; cursor: pointer; text-align: center; transition: all 0.15s;">';
                html += '<div style="font-size: 1.25rem; margin-bottom: 0.25rem;">' + style.icon + '</div>';
                html += '<div style="font-size: 0.7rem; font-weight: 600; color: ' + (isSelected ? style.color : 'white') + ';">' + style.name + '</div>';
                html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">' + style.desc + '</div>';
                html += '</div>';
            });

            html += '</div>';

            // Animate Button
            var isAnimating = animationStatus === 'generating';
            var canAnimate = hasVoiceover && !isAnimating;
            html += '<button onclick="animateScene(' + sceneId + ')" ' + (!canAnimate ? 'disabled' : '') + ' style="width: 100%; padding: 0.65rem; border-radius: 0.5rem; border: none; background: ' + (canAnimate ? 'linear-gradient(135deg, #06b6d4, #10b981)' : 'rgba(255,255,255,0.1)') + '; color: ' + (canAnimate ? 'white' : 'rgba(255,255,255,0.4)') + '; font-size: 0.8rem; font-weight: 600; cursor: ' + (canAnimate ? 'pointer' : 'not-allowed') + '; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">';
            if (isAnimating) {
                html += '<span class="animate-spin"></span> Animating...';
            } else if (!hasVoiceover) {
                html += '<span></span> Generate voiceover first';
            } else {
                html += '<span></span> Create Animation';
            }
            html += '</button>';

            html += '</div>';
            return html;
        }

        // Enhanced Voiceover Section with Emotion Presets & A/B Comparison
        function renderVoiceoverSectionPro(scriptScene, animScene, voiceoverUrl, voiceoverStatus, narration, storyboardScene) {
            var voice = animScene.voice || state.animation.voiceover.voice || 'alloy';
            var speed = animScene.speed || state.animation.voiceover.speed || 1.0;
            var emotions = state.animation.emotionPresets || { emotion: 'neutral', energy: 0.5, tone: 0.5 };

            // Check if scene has narration (supports new hasNarration flag)
            var sceneHasNarration = scriptScene.hasNarration !== false && narration && narration.trim() !== '';

            // Voice roles configuration (narrator vs character)
            var voiceRoles = state.animation.voiceRoles || {};
            var sceneVoiceRole = voiceRoles[scriptScene.id] || 'narrator';
            var narratorVoice = state.animation.narratorVoice || 'nova';
            var characterVoices = state.animation.characterVoices || {};

            // Get characters from script if available
            var sceneCharacters = (scriptScene.characters || []).length > 0 ? scriptScene.characters : [];
            var hasDialogue = scriptScene.hasDialogue || sceneCharacters.length > 0;

            var html = '';
            html += '<div style="background: rgba(139,92,246,0.08); border: 1px solid rgba(139,92,246,0.2); border-radius: 0.75rem; padding: 1rem;">';

            // Header with Music Only Toggle
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 1rem;"></span>';
            html += '<span style="font-size: 0.85rem; font-weight: 600; color: white;">Voiceover Pro</span>';
            // Status badge (only when voiceover is enabled)
            if (sceneHasNarration && voiceoverStatus === 'ready') {
                html += '<span style="font-size: 0.65rem; padding: 0.2rem 0.5rem; background: rgba(16,185,129,0.2); color: #10b981; border-radius: 1rem; font-weight: 600;">Ready</span>';
            } else if (sceneHasNarration && voiceoverStatus === 'generating') {
                html += '<span style="font-size: 0.65rem; padding: 0.2rem 0.5rem; background: rgba(251,191,36,0.2); color: #fbbf24; border-radius: 1rem; font-weight: 600;" class="animate-pulse">Generating...</span>';
            }
            html += '</div>';
            // Music Only Toggle Switch (always visible)
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.5);"> Music Only</span>';
            var isMusicOnly = !sceneHasNarration;
            var toggleBg = isMusicOnly ? '#8b5cf6' : 'rgba(255,255,255,0.2)';
            var togglePos = isMusicOnly ? '14px' : '2px';
            html += '<label style="position: relative; display: inline-block; width: 32px; height: 18px; cursor: pointer;">';
            html += '<input type="checkbox" ' + (isMusicOnly ? 'checked' : '') + ' onchange="toggleMusicOnlyMode(' + scriptScene.id + ', this.checked)" style="opacity: 0; width: 0; height: 0;">';
            html += '<span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: ' + toggleBg + '; transition: 0.2s; border-radius: 18px;">';
            html += '<span style="position: absolute; height: 14px; width: 14px; left: ' + togglePos + '; bottom: 2px; background-color: white; transition: 0.2s; border-radius: 50%;"></span>';
            html += '</span>';
            html += '</label>';
            html += '</div>';
            html += '</div>';

            // If no narration, show music-only mode
            if (!sceneHasNarration) {
                html += '<div style="text-align: center; padding: 2rem; background: rgba(255,255,255,0.03); border-radius: 0.5rem;">';
                html += '<div style="font-size: 2.5rem; margin-bottom: 0.75rem;"></div>';
                html += '<div style="font-size: 1rem; color: rgba(255,255,255,0.7); font-weight: 600;">Cinematic Music Scene</div>';
                html += '<div style="font-size: 0.8rem; color: rgba(255,255,255,0.4); margin-top: 0.5rem;">No voiceover - visuals and music speak for themselves</div>';
                html += '</div>';
                html += '</div>';
                return html;
            }

            // Narration preview (only if has narration)
            html += '<div style="background: rgba(0,0,0,0.2); border-radius: 0.5rem; padding: 0.6rem; margin-bottom: 0.75rem;">';
            html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.25rem;">VOICEOVER TEXT</div>';
            html += '<div style="font-size: 0.75rem; color: rgba(255,255,255,0.8); line-height: 1.4; font-style: italic;">"' + narration.substring(0, 150) + (narration.length > 150 ? '...' : '') + '"</div>';
            html += '</div>';

            // Voice Role Selection (Narrator vs Character)
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem;">Voice Role</div>';
            html += '<div style="display: flex; gap: 0.35rem;">';

            // Narrator option
            var isNarrator = sceneVoiceRole === 'narrator';
            html += '<button onclick="setSceneVoiceRole(' + scriptScene.id + ', \'narrator\')" style="flex: 1; padding: 0.5rem; border-radius: 0.4rem; border: 2px solid ' + (isNarrator ? '#06b6d4' : 'rgba(255,255,255,0.1)') + '; background: ' + (isNarrator ? 'rgba(6,182,212,0.15)' : 'transparent') + '; color: ' + (isNarrator ? '#06b6d4' : 'rgba(255,255,255,0.5)') + '; font-size: 0.7rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.3rem; transition: all 0.15s;">';
            html += '<span></span> Narrator';
            html += '</button>';

            // Character option
            var isCharacter = sceneVoiceRole === 'character';
            html += '<button onclick="setSceneVoiceRole(' + scriptScene.id + ', \'character\')" style="flex: 1; padding: 0.5rem; border-radius: 0.4rem; border: 2px solid ' + (isCharacter ? '#fbbf24' : 'rgba(255,255,255,0.1)') + '; background: ' + (isCharacter ? 'rgba(251,191,36,0.15)' : 'transparent') + '; color: ' + (isCharacter ? '#fbbf24' : 'rgba(255,255,255,0.5)') + '; font-size: 0.7rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.3rem; transition: all 0.15s;">';
            html += '<span></span> Character';
            html += '</button>';
            html += '</div>';
            html += '</div>';

            // Show narrator voice config or character voice config based on selection
            if (isNarrator) {
                // Narrator Voice Configuration
                html += '<div style="background: rgba(6,182,212,0.08); border: 1px solid rgba(6,182,212,0.2); border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 0.75rem;">';
                html += '<div style="display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.5rem;">';
                html += '<span style="font-size: 0.8rem;"></span>';
                html += '<span style="font-size: 0.7rem; font-weight: 600; color: #06b6d4;">Narrator Voice</span>';
                html += '</div>';

                html += '<div style="display: flex; gap: 0.35rem;">';
                html += '<select onchange="setNarratorVoice(this.value)" style="flex: 1; padding: 0.45rem; background: rgba(30,30,50,1); border: 1px solid rgba(6,182,212,0.3); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: pointer;">';
                var voices = ['alloy', 'nova', 'shimmer', 'echo', 'onyx', 'fable'];
                voices.forEach(function(v) {
                    html += '<option value="' + v + '" ' + (narratorVoice === v ? 'selected' : '') + '>' + v.charAt(0).toUpperCase() + v.slice(1) + '</option>';
                });
                html += '</select>';
                html += '<button onclick="previewVoice(\'' + narratorVoice + '\')" style="width: 34px; padding: 0.45rem; background: rgba(6,182,212,0.2); border: 1px solid rgba(6,182,212,0.3); border-radius: 0.35rem; color: #06b6d4; cursor: pointer; font-size: 0.75rem;" title="Preview narrator voice"></button>';
                html += '</div>';
                html += '</div>';
            } else {
                // Character Voice Configuration
                html += '<div style="background: rgba(251,191,36,0.08); border: 1px solid rgba(251,191,36,0.2); border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 0.75rem;">';
                html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">';
                html += '<div style="display: flex; align-items: center; gap: 0.4rem;">';
                html += '<span style="font-size: 0.8rem;"></span>';
                html += '<span style="font-size: 0.7rem; font-weight: 600; color: #fbbf24;">Character Voice</span>';
                html += '</div>';
                html += '<span style="font-size: 0.55rem; color: rgba(255,255,255,0.4);">Coming soon: Multi-character voices</span>';
                html += '</div>';

                // For now, show single character voice selector (future: show per-character)
                html += '<div style="display: flex; gap: 0.35rem;">';
                html += '<select onchange="setSceneVoice(' + scriptScene.id + ', this.value)" style="flex: 1; padding: 0.45rem; background: rgba(30,30,50,1); border: 1px solid rgba(251,191,36,0.3); border-radius: 0.35rem; color: white; font-size: 0.7rem; cursor: pointer;">';
                var voices = ['alloy', 'nova', 'shimmer', 'echo', 'onyx', 'fable'];
                voices.forEach(function(v) {
                    html += '<option value="' + v + '" ' + (voice === v ? 'selected' : '') + '>' + v.charAt(0).toUpperCase() + v.slice(1) + '</option>';
                });
                html += '</select>';
                html += '<button onclick="previewVoice(\'' + voice + '\')" style="width: 34px; padding: 0.45rem; background: rgba(251,191,36,0.2); border: 1px solid rgba(251,191,36,0.3); border-radius: 0.35rem; color: #fbbf24; cursor: pointer; font-size: 0.75rem;" title="Preview character voice"></button>';
                html += '</div>';

                // Future character list placeholder
                if (sceneCharacters.length > 0) {
                    html += '<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px dashed rgba(251,191,36,0.2);">';
                    html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-bottom: 0.35rem;">Characters in this scene:</div>';
                    html += '<div style="display: flex; flex-wrap: wrap; gap: 0.25rem;">';
                    sceneCharacters.forEach(function(char) {
                        html += '<span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(251,191,36,0.15); color: #fbbf24; border-radius: 0.25rem;">' + char + '</span>';
                    });
                    html += '</div>';
                    html += '</div>';
                }
                html += '</div>';
            }

            // Real-time Waveform with Playhead (show if voiceover exists)
            if (voiceoverUrl) {
                html += '<div style="margin-bottom: 0.75rem;">';
                html += '<div id="waveform-container-' + scriptScene.id + '" onclick="seekWaveform(' + scriptScene.id + ', event)" style="position: relative; display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">';
                html += '<button onclick="event.stopPropagation(); toggleVoiceoverPlayback(' + scriptScene.id + ')" id="play-btn-' + scriptScene.id + '" style="width: 40px; height: 40px; border-radius: 50%; border: none; background: linear-gradient(135deg, #8b5cf6, #a855f7); color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1rem; flex-shrink: 0;"></button>';
                html += '<div style="flex: 1; height: 40px; background: rgba(139,92,246,0.1); border-radius: 0.35rem; position: relative; overflow: hidden;">';
                // Waveform bars
                html += '<div style="position: absolute; inset: 0; display: flex; align-items: center; gap: 1px; padding: 0 0.5rem;">';
                for (var i = 0; i < 60; i++) {
                    var barHeight = 25 + Math.sin(i * 0.3) * 20 + Math.random() * 30;
                    html += '<div class="waveform-bar" style="flex: 1; height: ' + barHeight + '%; background: linear-gradient(to top, #8b5cf6, #a855f7); border-radius: 1px; min-width: 2px; transition: transform 0.1s;"></div>';
                }
                html += '</div>';
                // Playhead
                html += '<div class="waveform-playhead" style="position: absolute; top: 0; bottom: 0; left: 0%; width: 2px; background: white; box-shadow: 0 0 4px rgba(255,255,255,0.5); transition: left 0.1s linear;"></div>';
                // Progress overlay
                html += '<div class="waveform-progress" style="position: absolute; top: 0; bottom: 0; left: 0; width: 0%; background: rgba(139,92,246,0.3);"></div>';
                html += '</div>';
                html += '<span id="time-display-' + scriptScene.id + '" style="font-size: 0.7rem; color: rgba(255,255,255,0.5); font-family: monospace; min-width: 45px;">0:00</span>';
                html += '</div>';
                html += '<audio id="voiceover-audio-' + scriptScene.id + '" src="' + voiceoverUrl + '" ontimeupdate="updateWaveformUI(' + scriptScene.id + ', this)" style="display: none;"></audio>';
                html += '</div>';
            }

            // Emotion Presets (compact row)
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem;">Emotion</div>';
            html += '<div style="display: flex; gap: 0.3rem; flex-wrap: wrap;">';
            var emotionOptions = [
                { id: 'neutral', emoji: '', label: 'Neutral' },
                { id: 'happy', emoji: '', label: 'Happy' },
                { id: 'excited', emoji: '', label: 'Excited' },
                { id: 'serious', emoji: '', label: 'Serious' },
                { id: 'sad', emoji: '', label: 'Sad' }
            ];
            emotionOptions.forEach(function(em) {
                var isActive = emotions.emotion === em.id;
                html += '<button onclick="setEmotionPreset(\'' + em.id + '\')" style="padding: 0.3rem 0.45rem; border-radius: 0.3rem; border: 1px solid ' + (isActive ? '#8b5cf6' : 'rgba(255,255,255,0.1)') + '; background: ' + (isActive ? 'rgba(139,92,246,0.2)' : 'transparent') + '; color: ' + (isActive ? 'white' : 'rgba(255,255,255,0.5)') + '; font-size: 0.6rem; cursor: pointer; display: flex; align-items: center; gap: 0.2rem;">';
                html += '<span>' + em.emoji + '</span>';
                html += '<span>' + em.label + '</span>';
                html += '</button>';
            });
            html += '</div>';
            html += '</div>';

            // Speed & Energy/Tone Controls (compact)
            html += '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem; margin-bottom: 0.75rem;">';
            html += '<div>';
            html += '<label style="display: block; font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-bottom: 0.2rem;">Speed: ' + speed.toFixed(1) + 'x</label>';
            html += '<input type="range" min="0.5" max="2.0" step="0.1" value="' + speed + '" onchange="setSceneSpeed(' + scriptScene.id + ', this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #8b5cf6;">';
            html += '</div>';
            html += '<div>';
            html += '<label style="display: block; font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-bottom: 0.2rem;">Energy</label>';
            html += '<input type="range" min="0" max="1" step="0.1" value="' + emotions.energy + '" onchange="setEnergyLevel(this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #06b6d4;">';
            html += '</div>';
            html += '<div>';
            html += '<label style="display: block; font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-bottom: 0.2rem;">Tone</label>';
            html += '<input type="range" min="0" max="1" step="0.1" value="' + emotions.tone + '" onchange="setToneLevel(this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #10b981;">';
            html += '</div>';
            html += '</div>';

            // Generate Button
            var isGenerating = voiceoverStatus === 'generating';
            html += '<button onclick="generateSceneVoiceover(' + scriptScene.id + ')" ' + (isGenerating ? 'disabled' : '') + ' style="width: 100%; padding: 0.65rem; border-radius: 0.5rem; border: none; background: ' + (isGenerating ? 'rgba(255,255,255,0.1)' : 'linear-gradient(135deg, #8b5cf6, #a855f7)') + '; color: ' + (isGenerating ? 'rgba(255,255,255,0.4)' : 'white') + '; font-size: 0.8rem; font-weight: 600; cursor: ' + (isGenerating ? 'wait' : 'pointer') + '; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">';
            if (isGenerating) {
                html += '<span class="animate-spin"></span> Generating...';
            } else if (voiceoverUrl) {
                html += '<span></span> Regenerate Voiceover';
            } else {
                html += '<span></span> Generate Voiceover';
            }
            html += '</button>';

            html += '</div>';
            return html;
        }

        // A/B Comparison Panel (kept for backwards compatibility, now deprecated)
        function renderABComparisonPanel(sceneId) {
            var voices = state.animation.abCompareVoices || ['nova', 'alloy'];
            var audioUrls = state.animation.abCompareAudioUrls || [null, null];
            var allVoices = ['alloy', 'nova', 'shimmer', 'echo', 'onyx', 'fable'];

            var html = '';
            html += '<div style="background: rgba(139,92,246,0.1); border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 0.75rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.5rem; text-align: center;"> Compare Two Voices</div>';

            html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">';

            // Voice A
            html += '<div style="background: rgba(0,0,0,0.2); border-radius: 0.4rem; padding: 0.5rem;">';
            html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.35rem; text-align: center;">Voice A</div>';
            html += '<select onchange="setABCompareVoice(0, this.value)" style="width: 100%; padding: 0.4rem; background: rgba(30,30,50,1); border: 1px solid rgba(139,92,246,0.3); border-radius: 0.35rem; color: white; font-size: 0.7rem; margin-bottom: 0.35rem;">';
            allVoices.forEach(function(v) {
                html += '<option value="' + v + '" ' + (voices[0] === v ? 'selected' : '') + '>' + v.charAt(0).toUpperCase() + v.slice(1) + '</option>';
            });
            html += '</select>';
            if (audioUrls[0]) {
                html += '<button onclick="document.getElementById(\'ab-audio-0\').play()" style="width: 100%; padding: 0.4rem; border-radius: 0.35rem; border: none; background: linear-gradient(135deg, #8b5cf6, #a855f7); color: white; font-size: 0.7rem; cursor: pointer;"> Play A</button>';
                html += '<audio id="ab-audio-0" src="' + audioUrls[0] + '"></audio>';
            }
            html += '</div>';

            // Voice B
            html += '<div style="background: rgba(0,0,0,0.2); border-radius: 0.4rem; padding: 0.5rem;">';
            html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.35rem; text-align: center;">Voice B</div>';
            html += '<select onchange="setABCompareVoice(1, this.value)" style="width: 100%; padding: 0.4rem; background: rgba(30,30,50,1); border: 1px solid rgba(6,182,212,0.3); border-radius: 0.35rem; color: white; font-size: 0.7rem; margin-bottom: 0.35rem;">';
            allVoices.forEach(function(v) {
                html += '<option value="' + v + '" ' + (voices[1] === v ? 'selected' : '') + '>' + v.charAt(0).toUpperCase() + v.slice(1) + '</option>';
            });
            html += '</select>';
            if (audioUrls[1]) {
                html += '<button onclick="document.getElementById(\'ab-audio-1\').play()" style="width: 100%; padding: 0.4rem; border-radius: 0.35rem; border: none; background: linear-gradient(135deg, #06b6d4, #10b981); color: white; font-size: 0.7rem; cursor: pointer;"> Play B</button>';
                html += '<audio id="ab-audio-1" src="' + audioUrls[1] + '"></audio>';
            }
            html += '</div>';

            html += '</div>';

            // Generate / Select buttons
            if (!audioUrls[0] || !audioUrls[1]) {
                html += '<button onclick="generateABComparison()" style="width: 100%; padding: 0.6rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-size: 0.75rem; font-weight: 600; cursor: pointer;"> Generate Both Voices</button>';
            } else {
                html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">';
                html += '<button onclick="selectABWinner(0)" style="padding: 0.5rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #8b5cf6, #a855f7); color: white; font-size: 0.7rem; font-weight: 600; cursor: pointer;"> Select A</button>';
                html += '<button onclick="selectABWinner(1)" style="padding: 0.5rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #06b6d4, #10b981); color: white; font-size: 0.7rem; font-weight: 600; cursor: pointer;"> Select B</button>';
                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        // Waveform UI Update Function
        function updateWaveformUI(sceneId, audioElement) {
            var currentTime = audioElement.currentTime;
            var duration = audioElement.duration || 1;
            var progress = (currentTime / duration) * 100;

            var container = document.getElementById('waveform-container-' + sceneId);
            if (container) {
                var playhead = container.querySelector('.waveform-playhead');
                var progressEl = container.querySelector('.waveform-progress');
                if (playhead) playhead.style.left = progress + '%';
                if (progressEl) progressEl.style.width = progress + '%';
            }

            var timeDisplay = document.getElementById('time-display-' + sceneId);
            if (timeDisplay) {
                var mins = Math.floor(currentTime / 60);
                var secs = Math.floor(currentTime % 60);
                timeDisplay.textContent = mins + ':' + (secs < 10 ? '0' : '') + secs;
            }

            var playBtn = document.getElementById('play-btn-' + sceneId);
            if (playBtn) {
                playBtn.textContent = audioElement.paused ? '' : '';
            }
        }

        // Animation Style Gallery Pro with Smart Suggestions
        function renderAnimationStyleGalleryPro(sceneId, currentType, hasVoiceover, animationStatus, storyboardScene) {
            var styles = [
                { id: 'ken_burns', name: 'Ken Burns', desc: 'Smooth zoom & pan', icon: '', color: '#06b6d4' },
                { id: 'talking_head', name: 'Talking Head', desc: 'Subtle movement', icon: '', color: '#8b5cf6' },
                { id: 'static', name: 'Static', desc: 'No animation', icon: '', color: '#6b7280' }
            ];

            // Get AI suggestion
            var suggestion = getAnimationSuggestion(storyboardScene);

            var html = '';
            html += '<div style="background: rgba(6,182,212,0.08); border: 1px solid rgba(6,182,212,0.2); border-radius: 0.75rem; padding: 1rem;">';

            // Header
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 1rem;"></span>';
            html += '<span style="font-size: 0.85rem; font-weight: 600; color: white;">Animation Style</span>';
            html += '</div>';
            html += '</div>';

            // Smart Suggestion Banner
            if (suggestion && suggestion.type !== currentType) {
                html += '<div onclick="applySuggestion(' + sceneId + ', \'' + suggestion.type + '\')" style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem; background: linear-gradient(135deg, rgba(251,191,36,0.15), rgba(245,158,11,0.1)); border: 1px solid rgba(251,191,36,0.3); border-radius: 0.5rem; margin-bottom: 0.75rem; cursor: pointer; transition: all 0.15s;" onmouseenter="this.style.transform=\'scale(1.01)\'" onmouseleave="this.style.transform=\'scale(1)\'">';
                html += '<span style="font-size: 1rem;"></span>';
                html += '<div style="flex: 1;">';
                html += '<div style="font-size: 0.7rem; color: #fbbf24; font-weight: 600;">AI Suggestion</div>';
                html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.6);">' + suggestion.reason + '</div>';
                html += '</div>';
                html += '<span style="font-size: 0.65rem; color: #fbbf24; background: rgba(251,191,36,0.2); padding: 0.2rem 0.5rem; border-radius: 0.25rem;">Apply</span>';
                html += '</div>';
            }

            // Style Cards Grid
            html += '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 0.75rem;">';

            styles.forEach(function(style) {
                var isSelected = currentType === style.id;
                var isSuggested = suggestion && suggestion.type === style.id;
                html += '<div onclick="setSceneAnimationType(' + sceneId + ', \'' + style.id + '\')" style="position: relative; padding: 0.6rem; background: ' + (isSelected ? 'rgba(6,182,212,0.2)' : 'rgba(255,255,255,0.03)') + '; border: 2px solid ' + (isSelected ? style.color : 'rgba(255,255,255,0.08)') + '; border-radius: 0.5rem; cursor: pointer; text-align: center; transition: all 0.15s;">';
                if (isSuggested && !isSelected) {
                    html += '<div style="position: absolute; top: -6px; right: -6px; width: 18px; height: 18px; background: #fbbf24; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.55rem;"></div>';
                }
                html += '<div style="font-size: 1.25rem; margin-bottom: 0.25rem;">' + style.icon + '</div>';
                html += '<div style="font-size: 0.7rem; font-weight: 600; color: ' + (isSelected ? style.color : 'white') + ';">' + style.name + '</div>';
                html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">' + style.desc + '</div>';
                html += '</div>';
            });

            html += '</div>';

            // Camera Movement Selection (for Minimax AI Video)
            var videoModel = state.content.videoModel || { model: 'hailuo-2.3', duration: '10s', resolution: '768p' };
            var manualCameraMovements = (state.animation.cameraMovements && state.animation.cameraMovements[sceneId]) || [];
            // Get script-generated camera movements if no manual selection
            var scriptSceneForCamera = state.script.scenes.find(function(s) { return s.id === sceneId; });
            var scriptCameraMovements = (scriptSceneForCamera && scriptSceneForCamera.cameraMovement) || [];
            var sceneCameraMovements = manualCameraMovements.length > 0 ? manualCameraMovements : scriptCameraMovements;
            var hasScriptMovements = manualCameraMovements.length === 0 && scriptCameraMovements.length > 0;

            html += '<div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.08);">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.4rem;">';
            html += '<span style="font-size: 0.85rem;"></span>';
            html += '<span style="font-size: 0.75rem; font-weight: 600; color: white;">Camera Movement</span>';
            html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.35rem; background: rgba(6,182,212,0.2); color: #06b6d4; border-radius: 0.25rem;">Minimax AI</span>';
            if (hasScriptMovements) {
                html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.35rem; background: rgba(139,92,246,0.2); color: #a78bfa; border-radius: 0.25rem; margin-left: 0.25rem;">AI Suggested</span>';
            }
            html += '</div>';
            if (sceneCameraMovements.length > 0) {
                html += '<span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">' + sceneCameraMovements.length + '/3 ' + (hasScriptMovements ? 'suggested' : 'selected') + '</span>';
            }
            html += '</div>';

            // Camera movement buttons (show common ones, max 3 selectable)
            var cameraOptions = [
                { id: 'Pan left', icon: '', label: 'Pan L' },
                { id: 'Pan right', icon: '', label: 'Pan R' },
                { id: 'Zoom in', icon: '', label: 'Zoom+' },
                { id: 'Zoom out', icon: '', label: 'Zoom-' },
                { id: 'Push in', icon: '', label: 'Push' },
                { id: 'Pull out', icon: '', label: 'Pull' },
                { id: 'Tilt up', icon: '', label: 'Tilt' },
                { id: 'Tilt down', icon: '', label: 'Tilt' },
                { id: 'Tracking shot', icon: '', label: 'Track' },
                { id: 'Static shot', icon: '', label: 'Static' }
            ];

            html += '<div style="display: flex; flex-wrap: wrap; gap: 0.35rem;">';
            cameraOptions.forEach(function(cam) {
                var isSelected = sceneCameraMovements.includes(cam.id);
                var canSelect = isSelected || sceneCameraMovements.length < 3;
                html += '<button onclick="toggleCameraMovement(' + sceneId + ', \'' + cam.id + '\')" ' + (!canSelect ? 'disabled' : '') + ' style="padding: 0.35rem 0.5rem; border-radius: 0.35rem; border: 1px solid ' + (isSelected ? '#06b6d4' : 'rgba(255,255,255,0.15)') + '; background: ' + (isSelected ? 'rgba(6,182,212,0.2)' : 'transparent') + '; color: ' + (isSelected ? '#06b6d4' : (canSelect ? 'rgba(255,255,255,0.6)' : 'rgba(255,255,255,0.3)')) + '; font-size: 0.6rem; cursor: ' + (canSelect ? 'pointer' : 'not-allowed') + '; display: flex; align-items: center; gap: 0.2rem; transition: all 0.15s;">';
                html += '<span style="font-size: 0.7rem;">' + cam.icon + '</span>';
                html += '<span>' + cam.label + '</span>';
                html += '</button>';
            });
            html += '</div>';

            // Show selected movements preview
            if (sceneCameraMovements.length > 0) {
                html += '<div style="margin-top: 0.5rem; padding: 0.4rem 0.6rem; background: rgba(6,182,212,0.1); border-radius: 0.35rem; font-size: 0.65rem; color: #06b6d4;">';
                html += ' [' + sceneCameraMovements.join(', ') + ']';
                html += '</div>';
            }
            html += '</div>';

            // Animate Button with Model Info
            // Minimax AI Video does NOT require voiceover - it generates video from image + prompt
            var isAnimating = animationStatus === 'generating' || animationStatus === 'processing';
            var hasImage = storyboardScene && storyboardScene.imageUrl;
            var canAnimate = hasImage && !isAnimating;
            html += '<div style="margin-top: 0.75rem;">';
            html += '<button onclick="animateSceneWithMinimax(' + sceneId + ')" ' + (!canAnimate ? 'disabled' : '') + ' style="width: 100%; padding: 0.65rem; border-radius: 0.5rem; border: none; background: ' + (canAnimate ? 'linear-gradient(135deg, #06b6d4, #10b981)' : 'rgba(255,255,255,0.1)') + '; color: ' + (canAnimate ? 'white' : 'rgba(255,255,255,0.4)') + '; font-size: 0.8rem; font-weight: 600; cursor: ' + (canAnimate ? 'pointer' : 'not-allowed') + '; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">';
            if (isAnimating) {
                html += '<span class="animate-spin"></span> Generating AI Video...';
            } else if (!hasImage) {
                html += '<span></span> Generate image first';
            } else {
                html += '<span></span> Generate ' + videoModel.duration + ' AI Video';
            }
            html += '</button>';
            // Model info below button
            html += '<div style="text-align: center; margin-top: 0.35rem; font-size: 0.6rem; color: rgba(255,255,255,0.4);">';
            html += 'Using ' + (videoModel.model === 'hailuo-2.3' ? 'Hailuo 2.3' : videoModel.model === 'hailuo-2.3-fast' ? 'Hailuo 2.3 Fast' : 'Hailuo 02') + ' @ ' + videoModel.resolution;
            html += '</div>';
            html += '</div>';

            html += '</div>';
            return html;
        }

        // Camera movement toggle function
        function toggleCameraMovement(sceneId, movement) {
            if (!state.animation.cameraMovements) {
                state.animation.cameraMovements = {};
            }
            if (!state.animation.cameraMovements[sceneId]) {
                state.animation.cameraMovements[sceneId] = [];
            }

            var movements = state.animation.cameraMovements[sceneId];
            var index = movements.indexOf(movement);

            if (index > -1) {
                // Remove if already selected
                movements.splice(index, 1);
            } else if (movements.length < 3) {
                // Add if under limit
                movements.push(movement);
            } else {
                showToast('Maximum 3 camera movements allowed', 'warning');
                return;
            }

            render();
            scheduleAutoSave();
        }

        // Animate scene with Minimax AI
        async function animateSceneWithMinimax(sceneId) {
            var videoModel = state.content.videoModel || { model: 'hailuo-2.3', duration: '10s', resolution: '768p' };

            // Get scene data
            var storyboardScene = state.storyboard.scenes.find(function(s) { return s.sceneId === sceneId; });
            var scriptScene = state.script.scenes.find(function(s) { return s.id === sceneId; });

            // Get camera movements: prioritize manual selection, then script-generated, then empty
            var sceneCameraMovements = (state.animation.cameraMovements && state.animation.cameraMovements[sceneId]) || [];
            if (sceneCameraMovements.length === 0 && scriptScene && scriptScene.cameraMovement) {
                // Use camera movements from the AI-generated script
                sceneCameraMovements = scriptScene.cameraMovement;
            }

            if (!storyboardScene || !storyboardScene.imageUrl) {
                showToast('No image available for this scene', 'error');
                return;
            }

            // Update animation status
            var animScene = state.animation.scenes.find(function(s) { return s.sceneId === sceneId; });
            if (!animScene) {
                animScene = { sceneId: sceneId };
                state.animation.scenes.push(animScene);
            }
            animScene.animationStatus = 'generating';
            animScene.animationProvider = 'minimax';
            render();

            try {
                // Phase 8-11: Check for prompt chain video prompt template
                var chainData = getPromptChainForScene(sceneId);
                var visualPrompt;
                var videoPromptSource = 'assembled';

                if (chainData && chainData.videoPromptTemplate && state.storyboard.promptChain?.enabled) {
                    // Use the prompt chain video prompt template
                    visualPrompt = chainData.videoPromptTemplate.prompt || '';
                    // Replace placeholder with actual image URL
                    visualPrompt = visualPrompt.replace('[reference_image]', storyboardScene.imageUrl);
                    visualPrompt = visualPrompt.replace('[GENERATED_IMAGE_URL]', storyboardScene.imageUrl);
                    videoPromptSource = 'prompt-chain';
                    console.log('[Scene ' + sceneId + '] Using Prompt Chain video prompt');
                } else {
                    // Fallback: Build visual prompt from storyboard + script
                    visualPrompt = (storyboardScene.prompt || '') + ' ' + (scriptScene.visualDescription || scriptScene.narration || '');
                }

                // Call Minimax API via cloud function
                var generateMinimaxVideoFn = firebase.functions().httpsCallable('creationWizardGenerateMinimaxVideo');
                var result = await generateMinimaxVideoFn({
                    projectId: state.project.id,
                    sceneId: sceneId,
                    prompt: visualPrompt.trim().substring(0, 1500),
                    imageUrl: storyboardScene.imageUrl,
                    model: videoModel.model,
                    duration: videoModel.duration,
                    resolution: videoModel.resolution,
                    cameraMovements: sceneCameraMovements,
                    promptOptimizer: true,
                    // Phase 8-11: Pass prompt chain metadata
                    promptChainSource: videoPromptSource,
                    promptChainMetadata: chainData ? chainData.videoPromptTemplate?.metadata : null
                });

                if (result.data.success) {
                    animScene.minimaxTaskId = result.data.taskId;
                    animScene.animationStatus = 'processing';
                    showToast('AI video generation started!', 'success');

                    // Start polling for status
                    pollMinimaxVideoStatus(sceneId, result.data.taskId);
                } else {
                    throw new Error(result.data.error || 'Failed to start video generation');
                }

            } catch (error) {
                console.error('Minimax video generation error:', error);
                animScene.animationStatus = 'error';

                // Provide specific error messages for common issues
                var errorMsg = error.message || 'Unknown error';
                if (errorMsg.includes('API key not configured') || errorMsg.includes('failed-precondition')) {
                    showToast('Minimax API key not configured. Contact admin to set up the API key.', 'error');
                } else if (errorMsg.includes('Invalid model') || errorMsg.includes('invalid-argument')) {
                    showToast('Video configuration error: ' + errorMsg, 'error');
                } else if (errorMsg.includes('quota') || errorMsg.includes('rate limit')) {
                    showToast('API rate limit reached. Please wait and try again.', 'error');
                } else {
                    showToast('Failed to generate AI video: ' + errorMsg, 'error');
                }
            }

            render();
            saveProject();
        }

        // Poll Minimax video status
        async function pollMinimaxVideoStatus(sceneId, taskId) {
            var checkStatusFn = firebase.functions().httpsCallable('creationWizardCheckMinimaxVideoStatus');
            var maxAttempts = 60; // 5 minutes max (5s intervals)
            var attempts = 0;

            var pollInterval = setInterval(async function() {
                attempts++;

                try {
                    var result = await checkStatusFn({ taskId: taskId });

                    if (result.data.status === 'completed' && result.data.videoUrl) {
                        clearInterval(pollInterval);

                        // Update scene with video URL
                        var animScene = state.animation.scenes.find(function(s) { return s.sceneId === sceneId; });
                        if (animScene) {
                            animScene.videoUrl = result.data.videoUrl;
                            animScene.animationStatus = 'ready';
                            animScene.minimaxFileId = result.data.fileId;
                        }

                        showToast('AI video generated successfully!', 'success');
                        render();
                        saveProject();

                    } else if (result.data.status === 'failed') {
                        clearInterval(pollInterval);

                        var animScene = state.animation.scenes.find(function(s) { return s.sceneId === sceneId; });
                        if (animScene) {
                            animScene.animationStatus = 'error';
                        }

                        showToast('AI video generation failed: ' + (result.data.error || 'Unknown error'), 'error');
                        render();

                    } else if (attempts >= maxAttempts) {
                        clearInterval(pollInterval);

                        var animScene = state.animation.scenes.find(function(s) { return s.sceneId === sceneId; });
                        if (animScene) {
                            animScene.animationStatus = 'error';
                        }

                        showToast('AI video generation timed out', 'error');
                        render();
                    }

                } catch (error) {
                    console.error('Error polling video status:', error);
                    // Continue polling on transient errors
                }

            }, 5000); // Poll every 5 seconds
        }

        // Bottom Batch Queue
        function renderAnimationBatchQueue(animationScenes, storyboardScenes) {
            var processing = animationScenes.filter(function(s) {
                return s.voiceoverStatus === 'generating' || s.animationStatus === 'generating';
            });

            var html = '';
            html += '<div style="flex-shrink: 0; background: rgba(15,15,28,0.98); border-top: 1px solid rgba(255,255,255,0.08); padding: 0.6rem 1.25rem;">';

            if (processing.length > 0) {
                html += '<div style="display: flex; align-items: center; gap: 1rem;">';
                html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
                html += '<div class="animate-spin" style="width: 16px; height: 16px; border: 2px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%;"></div>';
                html += '<span style="font-size: 0.75rem; color: rgba(255,255,255,0.7);">Processing ' + processing.length + ' scene(s)...</span>';
                html += '</div>';

                // Progress items
                html += '<div style="display: flex; gap: 0.5rem; margin-left: auto;">';
                processing.forEach(function(scene, idx) {
                    var sceneNum = storyboardScenes.findIndex(function(s) { return s.sceneId === scene.sceneId; }) + 1;
                    var type = scene.voiceoverStatus === 'generating' ? '' : '';
                    html += '<div style="display: flex; align-items: center; gap: 0.3rem; padding: 0.25rem 0.5rem; background: rgba(139,92,246,0.15); border-radius: 0.3rem; font-size: 0.65rem; color: #a78bfa;">';
                    html += '<span>' + type + '</span>';
                    html += '<span>Scene ' + sceneNum + '</span>';
                    html += '</div>';
                });
                html += '</div>';
                html += '</div>';
            } else {
                // Stats bar when not processing
                var voiceoversDone = animationScenes.filter(function(s) { return s.voiceoverUrl; }).length;
                var animationsDone = animationScenes.filter(function(s) { return s.videoUrl; }).length;
                var total = storyboardScenes.length;

                html += '<div style="display: flex; align-items: center; justify-content: space-between;">';
                html += '<div style="display: flex; align-items: center; gap: 1.5rem;">';
                html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">';
                html += '<span style="color: #a78bfa;"> ' + voiceoversDone + '/' + total + '</span> voiceovers';
                html += '</div>';
                html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">';
                html += '<span style="color: #06b6d4;"> ' + animationsDone + '/' + total + '</span> animations';
                html += '</div>';
                html += '</div>';

                // Overall progress bar
                var progress = total > 0 ? Math.round((voiceoversDone / total) * 100) : 0;
                html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
                html += '<div style="width: 120px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden;">';
                html += '<div style="width: ' + progress + '%; height: 100%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); transition: width 0.3s;"></div>';
                html += '</div>';
                html += '<span style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">' + progress + '%</span>';
                html += '</div>';
                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        // Helper functions for the new Animation Studio
        function selectAnimationScene(sceneId) {
            state.animation.selectedSceneId = sceneId;
            render();
        }

        function playDetailPreview() {
            var video = document.getElementById('detail-preview-video');
            if (video) {
                if (video.paused) {
                    video.play();
                } else {
                    video.pause();
                }
            }
        }

        function toggleVoiceoverPlayback(sceneId) {
            var audio = document.getElementById('voiceover-audio-' + sceneId);
            if (audio) {
                if (audio.paused) {
                    audio.play();
                } else {
                    audio.pause();
                }
            }
        }

        function setSceneVoice(sceneId, voice) {
            var scene = state.animation.scenes.find(function(s) { return s.sceneId === sceneId; });
            if (scene) {
                scene.voice = voice;
                saveProject();
            }
        }

        function setSceneSpeed(sceneId, speed) {
            var scene = state.animation.scenes.find(function(s) { return s.sceneId === sceneId; });
            if (scene) {
                scene.speed = parseFloat(speed);
                saveProject();
                render();
            }
        }

        function previewVoice(voiceName) {
            // Create a quick sample preview of the selected voice
            showToast('Voice preview: ' + voiceName.charAt(0).toUpperCase() + voiceName.slice(1), 'info');
        }

        // ==========================================
        // VOICE ROLE MANAGEMENT (Narrator vs Characters)
        // ==========================================

        function setSceneVoiceRole(sceneId, role) {
            // Set whether this scene uses narrator or character voice
            if (!state.animation.voiceRoles) {
                state.animation.voiceRoles = {};
            }
            state.animation.voiceRoles[sceneId] = role;
            saveProject();
            render();
        }

        function setNarratorVoice(voice) {
            // Set the global narrator voice (used for all narrator scenes)
            state.animation.narratorVoice = voice;
            saveProject();
            render();
        }

        // PHASE 3: Character Voice Profiles
        // Available voice profiles matching backend CHARACTER_VOICE_ENGINE
        // Uses FAL ElevenLabs text-to-dialogue API voices
        const CHARACTER_VOICE_PROFILES = {
            // Male voices - FAL ElevenLabs: Roger, Charlie, George, Callum, Liam, Will, Eric, Chris, Brian, Daniel, Bill
            'male-hero': { name: 'Heroic Male', gender: 'male', description: 'Strong, confident hero voice', elevenLabsVoice: 'Roger' },
            'male-wise': { name: 'Wise Mentor', gender: 'male', description: 'Deep, wise mentor voice', elevenLabsVoice: 'George' },
            'male-villain': { name: 'Menacing Male', gender: 'male', description: 'Cold, calculating villain voice', elevenLabsVoice: 'Daniel' },
            'male-young': { name: 'Young Male', gender: 'male', description: 'Youthful, energetic voice', elevenLabsVoice: 'Liam' },
            'male-rugged': { name: 'Rugged Male', gender: 'male', description: 'Rough, weathered voice', elevenLabsVoice: 'Brian' },
            // Female voices - FAL ElevenLabs: Aria, Sarah, Laura, River, Charlotte, Alice, Matilda, Jessica, Lily
            'female-hero': { name: 'Heroic Female', gender: 'female', description: 'Strong, confident heroine voice', elevenLabsVoice: 'Aria' },
            'female-wise': { name: 'Wise Female', gender: 'female', description: 'Warm, wise mentor voice', elevenLabsVoice: 'Sarah' },
            'female-villain': { name: 'Femme Fatale', gender: 'female', description: 'Sultry, dangerous voice', elevenLabsVoice: 'Jessica' },
            'female-young': { name: 'Young Female', gender: 'female', description: 'Youthful, bright voice', elevenLabsVoice: 'Charlotte' },
            'female-warrior': { name: 'Warrior Woman', gender: 'female', description: 'Fierce, battle-ready voice', elevenLabsVoice: 'Laura' },
            // Special voices
            'narrator-omniscient': { name: 'Narrator', gender: 'neutral', description: 'Classic documentary narrator', elevenLabsVoice: 'Roger' },
            'child': { name: 'Child', gender: 'neutral', description: 'Childlike voice', elevenLabsVoice: 'Alice' },
            'robot': { name: 'Robot/AI', gender: 'neutral', description: 'Synthetic AI voice', elevenLabsVoice: 'Charlie' }
        };

        // FAL ElevenLabs available voices for UI
        const FAL_ELEVENLABS_VOICES = {
            male: ['Roger', 'Charlie', 'George', 'Callum', 'Liam', 'Will', 'Eric', 'Chris', 'Brian', 'Daniel', 'Bill'],
            female: ['Aria', 'Sarah', 'Laura', 'River', 'Charlotte', 'Alice', 'Matilda', 'Jessica', 'Lily']
        };

        // Map old OpenAI TTS voices and voice profile IDs to FAL ElevenLabs voices
        // Used for backward compatibility with projects created before ElevenLabs integration
        const OPENAI_TO_ELEVENLABS_VOICE_MAP = {
            // OpenAI male voices -> ElevenLabs male voices
            'adam': 'Roger',      // Deep, warm male
            'onyx': 'George',     // Deeper male
            'echo': 'Daniel',     // Standard male
            'fable': 'Liam',      // Younger male
            // OpenAI female voices -> ElevenLabs female voices
            'nova': 'Aria',       // Warm female
            'shimmer': 'Sarah',   // Bright female
            'alloy': 'Charlotte', // Neutral female
            'bella': 'Jessica',   // Expressive female
            'rachel': 'Laura',    // Professional female
            'domi': 'River',      // Energetic female
            'elli': 'Alice',      // Soft female
            'josh': 'Brian',      // Masculine
            'arnold': 'Will',     // Strong male
            'sam': 'Chris',       // Casual male
            'antoni': 'Eric',     // Friendly male

            // Voice Profile IDs -> ElevenLabs voices (matching CHARACTER_VOICE_PROFILES)
            'male-hero': 'Roger',
            'male-wise': 'George',
            'male-villain': 'Daniel',
            'male-young': 'Liam',
            'male-rugged': 'Brian',
            'female-hero': 'Aria',
            'female-wise': 'Sarah',
            'female-villain': 'Jessica',
            'female-young': 'Charlotte',
            'female-warrior': 'Laura',
            'narrator-omniscient': 'Roger',
            'child': 'Alice',
            'robot': 'Charlie',

            // Direct pass-through for already-valid ElevenLabs voices (case-insensitive)
            'roger': 'Roger', 'charlie': 'Charlie', 'george': 'George', 'callum': 'Callum',
            'liam': 'Liam', 'will': 'Will', 'eric': 'Eric', 'chris': 'Chris', 'brian': 'Brian',
            'daniel': 'Daniel', 'bill': 'Bill', 'aria': 'Aria', 'sarah': 'Sarah', 'laura': 'Laura',
            'river': 'River', 'charlotte': 'Charlotte', 'alice': 'Alice', 'matilda': 'Matilda',
            'jessica': 'Jessica', 'lily': 'Lily'
        };

        // Helper function to convert any voice name/object to ElevenLabs voice
        function toElevenLabsVoice(voiceInput) {
            if (!voiceInput) return 'Roger';

            // Handle object inputs - extract the voice ID string
            let voiceName = voiceInput;
            if (typeof voiceInput === 'object') {
                // Priority: elevenLabsVoice > voiceProfileId > voiceProfile.elevenLabsVoice > id
                voiceName = voiceInput.elevenLabsVoice ||
                            voiceInput.voiceProfileId ||
                            voiceInput.voiceProfile?.elevenLabsVoice ||
                            voiceInput.id ||
                            voiceInput.name ||
                            'Roger';
                console.log(`[toElevenLabsVoice] Extracted '${voiceName}' from object:`, voiceInput);
            }

            // Ensure we have a string
            if (typeof voiceName !== 'string') {
                console.warn('[toElevenLabsVoice] Non-string voice, defaulting to Roger:', voiceName);
                return 'Roger';
            }

            const normalized = voiceName.toLowerCase();

            // Check direct mapping (handles both OpenAI names and voice profile IDs)
            if (OPENAI_TO_ELEVENLABS_VOICE_MAP[normalized]) {
                const mapped = OPENAI_TO_ELEVENLABS_VOICE_MAP[normalized];
                console.log(`[toElevenLabsVoice] Mapped '${voiceName}' -> '${mapped}'`);
                return mapped;
            }

            // Check if already a valid ElevenLabs voice (case-insensitive)
            const allVoices = [...FAL_ELEVENLABS_VOICES.male, ...FAL_ELEVENLABS_VOICES.female];
            const match = allVoices.find(v => v.toLowerCase() === normalized);
            if (match) {
                console.log(`[toElevenLabsVoice] Already valid ElevenLabs voice: '${match}'`);
                return match;
            }

            // Default fallback
            console.log(`[toElevenLabsVoice] No mapping for '${voiceName}', defaulting to Roger`);
            return 'Roger';
        }

        function setCharacterVoice(characterName, voiceProfileId) {
            // Set voice profile for a specific character
            if (!state.animation.characterVoices) {
                state.animation.characterVoices = {};
            }

            const voiceProfile = CHARACTER_VOICE_PROFILES[voiceProfileId];
            state.animation.characterVoices[characterName] = {
                voiceProfileId: voiceProfileId,
                voiceProfile: voiceProfile,
                customVoiceId: null
            };

            // Also update in script.characters if exists
            if (state.script?.characters) {
                const charIndex = state.script.characters.findIndex(c => c.name === characterName);
                if (charIndex >= 0) {
                    state.script.characters[charIndex].voiceProfileId = voiceProfileId;
                    state.script.characters[charIndex].voice = {
                        voiceProfileId: voiceProfileId,
                        voiceProfile: voiceProfile
                    };
                }
            }

            // Update voiceAssignments
            if (state.script?.voiceAssignments) {
                state.script.voiceAssignments[characterName] = {
                    voiceProfileId: voiceProfileId,
                    voiceProfile: voiceProfile,
                    characterName: characterName
                };
            }

            console.log(`[setCharacterVoice] Set ${characterName} voice to ${voiceProfile?.name || voiceProfileId}`);
            saveProject();
            render();
        }

        function getCharacterVoice(characterName) {
            // Get voice profile for a character
            const charVoices = state.animation?.characterVoices || {};
            const assignment = charVoices[characterName] || state.script?.voiceAssignments?.[characterName];

            if (assignment) {
                return {
                    voiceProfileId: assignment.voiceProfileId,
                    voiceProfile: assignment.voiceProfile || CHARACTER_VOICE_PROFILES[assignment.voiceProfileId]
                };
            }

            // Try to find in script.characters
            const char = state.script?.characters?.find(c => c.name === characterName);
            if (char?.voiceProfileId) {
                return {
                    voiceProfileId: char.voiceProfileId,
                    voiceProfile: CHARACTER_VOICE_PROFILES[char.voiceProfileId]
                };
            }

            return null;
        }

        /**
         * PHASE 5: Validate TTS config before Multitalk API call
         * Ensures all required fields are present and valid
         * @param {Object} shot - Shot object containing ttsConfig
         * @returns {Object} { valid, errors, warnings, enhanced }
         */
        function validateTTSConfigForMultitalk(shot) {
            const errors = [];
            const warnings = [];
            const ttsConfig = shot?.ttsConfig;

            // If no ttsConfig, return empty but valid (no TTS needed)
            if (!ttsConfig) {
                return {
                    valid: true,
                    errors: [],
                    warnings: ['No TTS config - using audio file only'],
                    enhanced: null,
                    isEmpty: true
                };
            }

            const enhanced = { ...ttsConfig };

            // Validate lines array
            if (!ttsConfig.lines || !Array.isArray(ttsConfig.lines)) {
                warnings.push('TTS config missing lines array');
                enhanced.lines = [];
            } else {
                enhanced.lines = ttsConfig.lines.map((line, idx) => {
                    const enhancedLine = { ...line };

                    // Ensure voice is set - fallback to default
                    if (!line.voice) {
                        warnings.push(`Line ${idx + 1}: No voice, using default 'adam'`);
                        enhancedLine.voice = 'adam';
                    }

                    // Ensure text is present
                    if (!line.text || typeof line.text !== 'string' || line.text.trim().length === 0) {
                        errors.push(`Line ${idx + 1}: Empty text`);
                        enhancedLine._invalid = true;
                    }

                    // Ensure character is set
                    if (!line.character) {
                        warnings.push(`Line ${idx + 1}: No character name`);
                        enhancedLine.character = 'Character';
                    }

                    return enhancedLine;
                }).filter(line => !line._invalid);
            }

            // Validate total duration
            if (!ttsConfig.totalDuration || typeof ttsConfig.totalDuration !== 'number') {
                const estimatedDuration = enhanced.lines.reduce((sum, l) => {
                    const words = (l.text?.split(/\s+/).length || 0);
                    return sum + Math.max(1.5, words / 2.5);
                }, 0);
                enhanced.totalDuration = Math.ceil(estimatedDuration) || 5;
                warnings.push(`Estimated TTS duration: ${enhanced.totalDuration}s`);
            }

            // Check if we have any valid lines
            if (enhanced.lines.length === 0) {
                warnings.push('No valid TTS lines after validation');
            }

            return {
                valid: errors.length === 0,
                errors,
                warnings,
                enhanced: enhanced.lines.length > 0 ? enhanced : null,
                isEmpty: enhanced.lines.length === 0,
                lineCount: enhanced.lines.length
            };
        }

        function getVoiceForScene(sceneId) {
            // Get the appropriate voice for a scene based on its role
            var voiceRoles = state.animation.voiceRoles || {};
            var role = voiceRoles[sceneId] || 'narrator';

            if (role === 'narrator') {
                return state.animation.narratorVoice || 'nova';
            } else {
                // For character role, use scene-specific voice or default
                var scene = state.animation.scenes.find(function(s) { return s.sceneId === sceneId; });
                return (scene && scene.voice) || 'alloy';
            }
        }

        // ==========================================
        // DEVICE PREVIEW MODAL
        // ==========================================

        function openDevicePreview() {
            if (!state.animation.devicePreview) {
                state.animation.devicePreview = { isOpen: false, device: 'laptop', currentClipIndex: 0 };
            }
            state.animation.devicePreview.isOpen = true;
            state.animation.devicePreview.currentClipIndex = 0;
            render();
        }

        function closeDevicePreview() {
            if (state.animation.devicePreview) {
                state.animation.devicePreview.isOpen = false;
            }
            render();
        }

        function setDevicePreviewType(deviceType) {
            if (!state.animation.devicePreview) {
                state.animation.devicePreview = { isOpen: true, device: 'laptop', currentClipIndex: 0 };
            }
            state.animation.devicePreview.device = deviceType;
            render();
        }

        function prevDevicePreviewClip() {
            var devicePreview = state.animation.devicePreview;
            if (devicePreview && devicePreview.currentClipIndex > 0) {
                devicePreview.currentClipIndex--;
                render();
            }
        }

        function nextDevicePreviewClip() {
            var devicePreview = state.animation.devicePreview;
            var storyboardScenes = state.storyboard.scenes || [];
            if (devicePreview && devicePreview.currentClipIndex < storyboardScenes.length - 1) {
                devicePreview.currentClipIndex++;
                render();
            }
        }

        // ==========================================
        // FLOATING PREVIEW (PiP MODE)
        // ==========================================

        function toggleFloatingPreview() {
            if (!state.animation.floatingPreview) {
                state.animation.floatingPreview = { enabled: false, position: 'bottom-right', minimized: false };
            }
            state.animation.floatingPreview.enabled = !state.animation.floatingPreview.enabled;
            state.animation.floatingPreview.minimized = false;
            render();
            if (state.animation.floatingPreview.enabled) {
                showToast('Picture-in-Picture mode enabled', 'success');
            }
        }

        function setFloatingPreviewPosition(position) {
            if (!state.animation.floatingPreview) {
                state.animation.floatingPreview = { enabled: true, position: 'bottom-right', minimized: false };
            }
            state.animation.floatingPreview.position = position;
            render();
        }

        function toggleFloatingPreviewMinimize() {
            if (!state.animation.floatingPreview) return;
            state.animation.floatingPreview.minimized = !state.animation.floatingPreview.minimized;
            render();
        }

        function renderFloatingPreview() {
            var floatingPreview = state.animation.floatingPreview;
            if (!floatingPreview || !floatingPreview.enabled) {
                return '';
            }

            var position = floatingPreview.position || 'bottom-right';
            var isMinimized = floatingPreview.minimized;
            var selectedId = state.animation.selectedSceneId;
            var scriptScenes = state.script.scenes || [];
            var storyboardScenes = state.storyboard.scenes || [];
            var animationScenes = state.animation.scenes || [];

            var scriptScene = scriptScenes.find(function(s) { return s.id === selectedId; });
            var storyboardScene = storyboardScenes.find(function(s) { return s.sceneId === selectedId; }) || {};
            var animScene = animationScenes.find(function(s) { return s.sceneId === selectedId; }) || {};

            var sceneIndex = scriptScenes.findIndex(function(s) { return s.id === selectedId; });
            var imageUrl = storyboardScene.imageUrl || '';
            var videoUrl = animScene.videoUrl || '';

            var html = '';

            // Minimized state - just a floating icon
            if (isMinimized) {
                html += '<div class="floating-preview-container minimized ' + position + '" onclick="toggleFloatingPreviewMinimize()" title="Expand Preview">';
                html += '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #8b5cf6, #6366f1);">';
                html += '<span style="font-size: 1.5rem;"></span>';
                html += '</div>';
                html += '</div>';
                return html;
            }

            html += '<div class="floating-preview-container ' + position + '">';

            // Header with drag handle and controls
            html += '<div class="floating-preview-header">';
            html += '<div style="display: flex; align-items: center; gap: 0.4rem;">';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.5);"></span>';
            html += '<span style="font-size: 0.7rem; font-weight: 600; color: white;">Scene ' + (sceneIndex + 1) + '</span>';
            if (videoUrl) {
                html += '<span style="font-size: 0.55rem; padding: 0.1rem 0.3rem; background: rgba(16,185,129,0.3); color: #10b981; border-radius: 0.25rem;"></span>';
            }
            html += '</div>';
            html += '<div style="display: flex; align-items: center; gap: 0.25rem;">';
            html += '<button onclick="toggleFloatingPreviewMinimize()" class="floating-preview-btn" title="Minimize"><span style="font-size: 0.8rem;"></span></button>';
            html += '<button onclick="toggleFloatingPreview()" class="floating-preview-btn" title="Close PiP"><span style="font-size: 0.7rem;"></span></button>';
            html += '</div>';
            html += '</div>';

            // Preview content
            html += '<div class="floating-preview-content">';
            if (videoUrl) {
                html += '<video id="floating-preview-video" src="' + videoUrl + '" style="width: 100%; height: 100%; object-fit: cover;" onclick="playFloatingPreviewVideo()"></video>';
                html += '<div onclick="playFloatingPreviewVideo()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); cursor: pointer;" id="floating-play-overlay">';
                html += '<div style="width: 40px; height: 40px; background: rgba(16,185,129,0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center;">';
                html += '<span style="font-size: 1rem; margin-left: 2px;"></span>';
                html += '</div>';
                html += '</div>';
            } else if (imageUrl) {
                html += '<img src="' + imageUrl + '" style="width: 115%; height: 115%; object-fit: cover; animation: kenBurnsPreview 8s ease-in-out infinite alternate;">';
            } else {
                html += '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3);">';
                html += '<span style="font-size: 2rem;"></span>';
                html += '</div>';
            }
            html += '</div>';

            // Position controls
            html += '<div class="floating-preview-position-grid">';
            html += '<button onclick="setFloatingPreviewPosition(\'top-left\')" class="floating-preview-position-btn ' + (position === 'top-left' ? 'active' : '') + '"> Top Left</button>';
            html += '<button onclick="setFloatingPreviewPosition(\'top-right\')" class="floating-preview-position-btn ' + (position === 'top-right' ? 'active' : '') + '"> Top Right</button>';
            html += '<button onclick="setFloatingPreviewPosition(\'bottom-left\')" class="floating-preview-position-btn ' + (position === 'bottom-left' ? 'active' : '') + '"> Bottom Left</button>';
            html += '<button onclick="setFloatingPreviewPosition(\'bottom-right\')" class="floating-preview-position-btn ' + (position === 'bottom-right' ? 'active' : '') + '"> Bottom Right</button>';
            html += '</div>';

            // Quick navigation
            html += '<div class="floating-preview-controls">';
            html += '<button onclick="navigateFloatingPreview(-1)" class="floating-preview-btn" title="Previous scene" ' + (sceneIndex <= 0 ? 'disabled style="opacity: 0.3; cursor: not-allowed;"' : '') + '></button>';
            html += '<span style="flex: 1; text-align: center; font-size: 0.65rem; color: rgba(255,255,255,0.5);">' + (sceneIndex + 1) + ' / ' + scriptScenes.length + '</span>';
            html += '<button onclick="navigateFloatingPreview(1)" class="floating-preview-btn" title="Next scene" ' + (sceneIndex >= scriptScenes.length - 1 ? 'disabled style="opacity: 0.3; cursor: not-allowed;"' : '') + '></button>';
            html += '</div>';

            html += '</div>';
            return html;
        }

        function playFloatingPreviewVideo() {
            var video = document.getElementById('floating-preview-video');
            var overlay = document.getElementById('floating-play-overlay');
            if (video) {
                if (video.paused) {
                    video.play();
                    if (overlay) overlay.style.display = 'none';
                } else {
                    video.pause();
                    if (overlay) overlay.style.display = 'flex';
                }
            }
        }

        function navigateFloatingPreview(direction) {
            var scriptScenes = state.script.scenes || [];
            var currentId = state.animation.selectedSceneId;
            var currentIndex = scriptScenes.findIndex(function(s) { return s.id === currentId; });
            var newIndex = currentIndex + direction;

            if (newIndex >= 0 && newIndex < scriptScenes.length) {
                state.animation.selectedSceneId = scriptScenes[newIndex].id;
                render();
            }
        }

        function renderDevicePreviewModal() {
            var devicePreview = state.animation.devicePreview;
            if (!devicePreview || !devicePreview.isOpen) {
                return '';
            }

            var device = devicePreview.device || 'laptop';
            var clipIndex = devicePreview.currentClipIndex || 0;
            var storyboardScenes = state.storyboard.scenes || [];
            var scriptScenes = state.script.scenes || [];
            var totalClips = storyboardScenes.length;

            // Get current scene data
            var currentStoryboard = storyboardScenes[clipIndex] || {};
            var currentScript = scriptScenes.find(function(s) { return s.id === currentStoryboard.sceneId; }) || {};
            var imageUrl = currentStoryboard.imageUrl || '';
            var videoUrl = currentStoryboard.videoUrl || '';
            var narration = currentScript.narration || '';

            var html = '';
            html += '<div class="device-preview-overlay" onclick="closeDevicePreview()">';
            html += '<div class="device-preview-modal" onclick="event.stopPropagation()">';

            // Header with device selector and close button
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; padding: 0 0.5rem;">';

            // Device selector buttons
            html += '<div style="display: flex; gap: 0.5rem;">';
            html += '<button onclick="setDevicePreviewType(\'mobile\')" class="device-selector-btn ' + (device === 'mobile' ? 'active' : '') + '" title="Mobile (9:16)">';
            html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"/><line x1="12" y1="18" x2="12" y2="18"/></svg>';
            html += '</button>';
            html += '<button onclick="setDevicePreviewType(\'laptop\')" class="device-selector-btn ' + (device === 'laptop' ? 'active' : '') + '" title="Laptop (16:9)">';
            html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="2" y1="20" x2="22" y2="20"/></svg>';
            html += '</button>';
            html += '<button onclick="setDevicePreviewType(\'tablet\')" class="device-selector-btn ' + (device === 'tablet' ? 'active' : '') + '" title="Tablet (4:3)">';
            html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="2" width="16" height="20" rx="2" ry="2"/><line x1="12" y1="18" x2="12" y2="18"/></svg>';
            html += '</button>';
            html += '</div>';

            // Close button
            html += '<button onclick="closeDevicePreview()" style="width: 36px; height: 36px; border-radius: 50%; border: none; background: rgba(255,255,255,0.1); color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; transition: all 0.2s;" onmouseenter="this.style.background=\'rgba(239,68,68,0.3)\'" onmouseleave="this.style.background=\'rgba(255,255,255,0.1)\'">';
            html += '';
            html += '</button>';
            html += '</div>';

            // Device Frame
            html += '<div class="device-frame-' + device + '">';
            html += '<div class="device-screen">';

            // Content inside device
            if (videoUrl) {
                html += '<video src="' + videoUrl + '" style="width: 100%; height: 100%; object-fit: cover;" autoplay muted loop></video>';
            } else if (imageUrl) {
                html += '<div style="width: 100%; height: 100%; overflow: hidden;">';
                html += '<img src="' + imageUrl + '" style="width: 115%; height: 115%; object-fit: cover; animation: kenBurnsPreview 8s ease-in-out infinite alternate;">';
                html += '</div>';
            } else {
                html += '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(20,20,30,1); color: rgba(255,255,255,0.3);">';
                html += '<div style="text-align: center;">';
                html += '<div style="font-size: 2.5rem; margin-bottom: 0.5rem;"></div>';
                html += '<div style="font-size: 0.8rem;">No preview available</div>';
                html += '</div>';
                html += '</div>';
            }

            // Narration overlay (for mobile view especially)
            if (device === 'mobile' && narration) {
                html += '<div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); padding: 2rem 1rem 1rem;">';
                html += '<div style="font-size: 0.75rem; color: white; text-align: center; line-height: 1.4;">' + narration.substring(0, 100) + (narration.length > 100 ? '...' : '') + '</div>';
                html += '</div>';
            }

            html += '</div>'; // device-screen
            html += '</div>'; // device-frame

            // Navigation controls
            html += '<div style="display: flex; align-items: center; justify-content: center; gap: 1rem; margin-top: 1.25rem;">';

            // Prev button
            var prevDisabled = clipIndex === 0;
            html += '<button onclick="prevDevicePreviewClip()" ' + (prevDisabled ? 'disabled' : '') + ' style="padding: 0.5rem 1rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: ' + (prevDisabled ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.1)') + '; color: ' + (prevDisabled ? 'rgba(255,255,255,0.3)' : 'white') + '; font-size: 0.8rem; cursor: ' + (prevDisabled ? 'not-allowed' : 'pointer') + '; display: flex; align-items: center; gap: 0.3rem;">';
            html += ' Prev';
            html += '</button>';

            // Clip counter
            html += '<div style="padding: 0.4rem 0.8rem; background: rgba(139,92,246,0.2); border-radius: 1rem; font-size: 0.75rem; color: #a78bfa; font-weight: 600;">';
            html += 'Clip ' + (clipIndex + 1) + ' of ' + totalClips;
            html += '</div>';

            // Next button
            var nextDisabled = clipIndex >= totalClips - 1;
            html += '<button onclick="nextDevicePreviewClip()" ' + (nextDisabled ? 'disabled' : '') + ' style="padding: 0.5rem 1rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: ' + (nextDisabled ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.1)') + '; color: ' + (nextDisabled ? 'rgba(255,255,255,0.3)' : 'white') + '; font-size: 0.8rem; cursor: ' + (nextDisabled ? 'not-allowed' : 'pointer') + '; display: flex; align-items: center; gap: 0.3rem;">';
            html += 'Next ';
            html += '</button>';

            html += '</div>';

            html += '</div>'; // device-preview-modal
            html += '</div>'; // device-preview-overlay

            return html;
        }

        // ==========================================
        // ANIMATION STUDIO PRO 2.0 - NEW FEATURES
        // ==========================================

        // Keyboard Shortcuts Handler
        function initAnimationKeyboardShortcuts() {
            document.addEventListener('keydown', handleAnimationKeydown);
        }

        function handleAnimationKeydown(e) {
            // Only handle if we're on step 5 and not in an input
            if (state.currentStep !== 5) return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

            var scriptScenes = state.script.scenes || [];
            var currentIndex = scriptScenes.findIndex(function(s) { return s.id === state.animation.selectedSceneId; });

            switch(e.key) {
                case '?':
                    e.preventDefault();
                    toggleKeyboardShortcuts();
                    break;
                case 'Escape':
                    if (state.animation.cinemaMode) {
                        e.preventDefault();
                        exitCinemaMode();
                    } else if (state.animation.showKeyboardShortcuts) {
                        e.preventDefault();
                        toggleKeyboardShortcuts();
                    }
                    break;
                case 'ArrowUp':
                case 'k':
                    e.preventDefault();
                    if (currentIndex > 0) {
                        selectAnimationScene(scriptScenes[currentIndex - 1].id);
                    }
                    break;
                case 'ArrowDown':
                case 'j':
                    e.preventDefault();
                    if (currentIndex < scriptScenes.length - 1) {
                        selectAnimationScene(scriptScenes[currentIndex + 1].id);
                    }
                    break;
                case ' ':
                    e.preventDefault();
                    toggleCurrentPreview();
                    break;
                case 'v':
                    if (!e.shiftKey) {
                        e.preventDefault();
                        if (state.animation.selectedSceneId) {
                            generateSceneVoiceover(state.animation.selectedSceneId);
                        }
                    } else {
                        e.preventDefault();
                        generateAllVoiceovers();
                    }
                    break;
                case 'V':
                    e.preventDefault();
                    generateAllVoiceovers();
                    break;
                case 'a':
                    if (!e.shiftKey) {
                        e.preventDefault();
                        if (state.animation.selectedSceneId) {
                            animateScene(state.animation.selectedSceneId);
                        }
                    } else {
                        e.preventDefault();
                        animateAllScenes();
                    }
                    break;
                case 'A':
                    e.preventDefault();
                    animateAllScenes();
                    break;
                case 'c':
                    e.preventDefault();
                    enterCinemaMode();
                    break;
                case 'q':
                    e.preventDefault();
                    toggleQueueManager();
                    break;
                case 'b':
                    e.preventDefault();
                    toggleABCompareMode();
                    break;
                case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9':
                    e.preventDefault();
                    var num = parseInt(e.key) - 1;
                    if (num < scriptScenes.length) {
                        selectAnimationScene(scriptScenes[num].id);
                    }
                    break;
            }
        }

        function toggleKeyboardShortcuts() {
            state.animation.showKeyboardShortcuts = !state.animation.showKeyboardShortcuts;
            render();
        }

        function toggleQueueManager() {
            state.animation.showQueueManager = !state.animation.showQueueManager;
            render();
        }

        function toggleCurrentPreview() {
            var video = document.getElementById('detail-preview-video');
            var audio = document.getElementById('voiceover-audio-' + state.animation.selectedSceneId);
            if (video) {
                if (video.paused) video.play(); else video.pause();
            } else if (audio) {
                if (audio.paused) audio.play(); else audio.pause();
            }
        }

        // Multi-Select Functions
        function toggleSceneSelection(sceneId, event) {
            if (event) event.stopPropagation();

            var selectedIds = state.animation.selectedSceneIds || [];
            var index = selectedIds.indexOf(sceneId);

            if (event && event.ctrlKey) {
                // Ctrl+Click: Toggle individual selection
                if (index > -1) {
                    selectedIds.splice(index, 1);
                } else {
                    selectedIds.push(sceneId);
                }
            } else if (event && event.shiftKey && state.animation.selectedSceneId) {
                // Shift+Click: Range selection
                var scriptScenes = state.script.scenes || [];
                var startIdx = scriptScenes.findIndex(function(s) { return s.id === state.animation.selectedSceneId; });
                var endIdx = scriptScenes.findIndex(function(s) { return s.id === sceneId; });
                if (startIdx > endIdx) { var temp = startIdx; startIdx = endIdx; endIdx = temp; }
                selectedIds = [];
                for (var i = startIdx; i <= endIdx; i++) {
                    selectedIds.push(scriptScenes[i].id);
                }
            } else {
                // Normal click: Single selection
                selectedIds = [sceneId];
                state.animation.selectedSceneId = sceneId;
            }

            state.animation.selectedSceneIds = selectedIds;
            if (selectedIds.length === 1) {
                state.animation.selectedSceneId = selectedIds[0];
            }
            render();
        }

        function clearMultiSelection() {
            state.animation.selectedSceneIds = [];
            render();
        }

        function batchGenerateVoiceovers() {
            var selectedIds = state.animation.selectedSceneIds || [];
            if (selectedIds.length === 0) {
                showToast('No scenes selected', 'info');
                return;
            }
            showToast('Generating voiceovers for ' + selectedIds.length + ' scenes...', 'info');
            selectedIds.forEach(function(id) {
                var scene = state.animation.scenes.find(function(s) { return s.sceneId === id; });
                if (scene && !scene.voiceoverUrl) {
                    generateSceneVoiceover(id);
                }
            });
        }

        function batchAnimateScenes() {
            var selectedIds = state.animation.selectedSceneIds || [];
            if (selectedIds.length === 0) {
                showToast('No scenes selected', 'info');
                return;
            }
            showToast('Animating ' + selectedIds.length + ' scenes...', 'info');
            selectedIds.forEach(function(id) {
                var scene = state.animation.scenes.find(function(s) { return s.sceneId === id; });
                if (scene && scene.voiceoverUrl && !scene.videoUrl) {
                    animateScene(id);
                }
            });
        }

        // Drag and Drop Scene Reordering
        function handleSceneDragStart(sceneId, event) {
            state.animation.draggedSceneId = sceneId;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', sceneId);
            event.target.style.opacity = '0.5';
        }

        function handleSceneDragOver(index, event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            state.animation.dropTargetIndex = index;
            render();
        }

        function handleSceneDragEnd(event) {
            event.target.style.opacity = '1';
            state.animation.draggedSceneId = null;
            state.animation.dropTargetIndex = null;
            render();
        }

        function handleSceneDrop(targetIndex, event) {
            event.preventDefault();
            var draggedId = state.animation.draggedSceneId;
            if (!draggedId) return;

            var scriptScenes = state.script.scenes || [];
            var sourceIndex = scriptScenes.findIndex(function(s) { return s.id === draggedId; });

            if (sourceIndex !== -1 && sourceIndex !== targetIndex) {
                var scene = scriptScenes.splice(sourceIndex, 1)[0];
                if (targetIndex > sourceIndex) targetIndex--;
                scriptScenes.splice(targetIndex, 0, scene);
                state.script.scenes = scriptScenes;
                saveProject();
                showToast('Scene reordered', 'success');
            }

            state.animation.draggedSceneId = null;
            state.animation.dropTargetIndex = null;
            render();
        }

        // Cinema Mode
        function enterCinemaMode() {
            state.animation.cinemaMode = true;
            state.animation.cinemaModeSceneIndex = 0;
            render();
        }

        function exitCinemaMode() {
            state.animation.cinemaMode = false;
            render();
        }

        function cinemaModeNext() {
            var scriptScenes = state.script.scenes || [];
            if (state.animation.cinemaModeSceneIndex < scriptScenes.length - 1) {
                state.animation.cinemaModeSceneIndex++;
                render();
            }
        }

        function cinemaModePrev() {
            if (state.animation.cinemaModeSceneIndex > 0) {
                state.animation.cinemaModeSceneIndex--;
                render();
            }
        }

        function cinemaModePlayAll() {
            // Play all scenes sequentially
            var scriptScenes = state.script.scenes || [];
            var animScenes = state.animation.scenes || [];
            var currentIdx = state.animation.cinemaModeSceneIndex;

            function playNext() {
                if (currentIdx >= scriptScenes.length) {
                    showToast('Preview complete!', 'success');
                    return;
                }
                state.animation.cinemaModeSceneIndex = currentIdx;
                render();

                var scene = scriptScenes[currentIdx];
                var animScene = animScenes.find(function(s) { return s.sceneId === scene.id; });
                var duration = (scene.duration || 8) * 1000;

                // Play voiceover if available
                setTimeout(function() {
                    var audio = document.getElementById('cinema-audio');
                    if (audio && animScene && animScene.voiceoverUrl) {
                        audio.src = animScene.voiceoverUrl;
                        audio.play();
                    }
                }, 100);

                currentIdx++;
                setTimeout(playNext, duration);
            }

            playNext();
        }

        // A/B Voice Comparison
        function toggleABCompareMode() {
            state.animation.abCompareMode = !state.animation.abCompareMode;
            state.animation.abCompareAudioUrls = [null, null];
            render();
        }

        function setABCompareVoice(index, voice) {
            state.animation.abCompareVoices[index] = voice;
            state.animation.abCompareAudioUrls[index] = null;
            render();
        }

        async function generateABComparison() {
            var sceneId = state.animation.selectedSceneId;
            var scriptScene = state.script.scenes.find(function(s) { return s.id === sceneId; });
            if (!scriptScene || !scriptScene.narration) {
                showToast('No narration for this scene', 'error');
                return;
            }

            showToast('Generating A/B comparison...', 'info');

            try {
                var generateVoiceover = firebase.functions().httpsCallable('creationWizardGenerateVoiceover');

                // Generate both voices
                var results = await Promise.all([
                    generateVoiceover({
                        projectId: state.project.id,
                        sceneId: sceneId,
                        text: scriptScene.narration,
                        voice: state.animation.abCompareVoices[0],
                        speed: state.animation.voiceover.speed,
                        isABTest: true
                    }),
                    generateVoiceover({
                        projectId: state.project.id,
                        sceneId: sceneId,
                        text: scriptScene.narration,
                        voice: state.animation.abCompareVoices[1],
                        speed: state.animation.voiceover.speed,
                        isABTest: true
                    })
                ]);

                state.animation.abCompareAudioUrls = [
                    results[0].data.audioUrl,
                    results[1].data.audioUrl
                ];
                render();
                showToast('A/B comparison ready!', 'success');
            } catch (error) {
                console.error('A/B comparison error:', error);
                showToast('Failed to generate comparison', 'error');
            }
        }

        function selectABWinner(index) {
            var sceneId = state.animation.selectedSceneId;
            var animScene = state.animation.scenes.find(function(s) { return s.sceneId === sceneId; });
            if (animScene && state.animation.abCompareAudioUrls[index]) {
                animScene.voiceoverUrl = state.animation.abCompareAudioUrls[index];
                animScene.voiceoverStatus = 'ready';
                animScene.voice = state.animation.abCompareVoices[index];
                state.animation.abCompareMode = false;
                saveProject();
                render();
                showToast('Voice ' + (index + 1) + ' selected!', 'success');
            }
        }

        // Voice Emotion Presets
        function setEmotionPreset(emotion) {
            state.animation.emotionPresets.emotion = emotion;
            render();
        }

        function setEnergyLevel(energy) {
            state.animation.emotionPresets.energy = parseFloat(energy);
            render();
        }

        function setToneLevel(tone) {
            state.animation.emotionPresets.tone = parseFloat(tone);
            render();
        }

        // Smart Animation Suggestions
        function getAnimationSuggestion(storyboardScene) {
            if (!storyboardScene || !storyboardScene.imageUrl) return null;

            var prompt = (storyboardScene.prompt || '').toLowerCase();
            var source = storyboardScene.source || '';

            // Simple heuristics for suggestions
            if (prompt.includes('face') || prompt.includes('person') || prompt.includes('portrait') || prompt.includes('character')) {
                return { type: 'talking_head', reason: 'Face detected - subtle movement recommended' };
            }
            if (prompt.includes('landscape') || prompt.includes('city') || prompt.includes('panorama') || prompt.includes('view')) {
                return { type: 'ken_burns', reason: 'Scenic view - smooth pan suggested' };
            }
            if (prompt.includes('action') || prompt.includes('dynamic') || prompt.includes('motion')) {
                return { type: 'ken_burns', reason: 'Dynamic scene - zoom effect recommended' };
            }
            if (source === 'stock-video') {
                return { type: 'static', reason: 'Stock video - no animation needed' };
            }

            return { type: 'ken_burns', reason: 'Ken Burns adds subtle motion' };
        }

        function applySuggestion(sceneId, animationType) {
            setSceneAnimationType(sceneId, animationType);
            showToast('Applied: ' + animationType.replace('_', ' '), 'success');
        }

        // Real-time Waveform Functions
        function initWaveformVisualization(sceneId, audioUrl) {
            // Generate pseudo-waveform data based on audio analysis
            // In production, this would use Web Audio API
            var waveformBars = [];
            for (var i = 0; i < 60; i++) {
                waveformBars.push(20 + Math.random() * 60);
            }
            state.animation.waveformData[sceneId] = waveformBars;
        }

        function updateWaveformPlayhead(sceneId, currentTime, duration) {
            state.animation.currentPlaybackTime = currentTime;
            var waveform = document.getElementById('waveform-container-' + sceneId);
            if (waveform) {
                var progress = (currentTime / duration) * 100;
                var playhead = waveform.querySelector('.waveform-playhead');
                if (playhead) {
                    playhead.style.left = progress + '%';
                }
            }
        }

        function seekWaveform(sceneId, event) {
            var waveform = event.currentTarget;
            var rect = waveform.getBoundingClientRect();
            var x = event.clientX - rect.left;
            var progress = x / rect.width;

            var audio = document.getElementById('voiceover-audio-' + sceneId);
            if (audio && audio.duration) {
                audio.currentTime = progress * audio.duration;
            }
        }

        function initializeAnimationScenes() {
            const storyboardScenes = state.storyboard.scenes || [];
            const scriptScenes = state.script.scenes || [];

            state.animation.scenes = scriptScenes.map(scene => ({
                sceneId: scene.id,
                voiceoverStatus: 'idle',
                voiceoverUrl: null,
                animationStatus: 'idle',
                videoUrl: null,
                voice: state.animation.voiceover.voice,
                speed: state.animation.voiceover.speed,
                animationType: 'ken_burns',
                jobId: null
            }));
            saveProject();
        }

        function renderAnimationSceneCard(scriptScene, storyboardScene, animScene, index) {
            const imageUrl = storyboardScene.imageUrl;
            const voiceoverStatus = animScene.voiceoverStatus || 'idle';
            const voiceoverUrl = animScene.voiceoverUrl;
            const animationStatus = animScene.animationStatus || 'idle';
            const videoUrl = animScene.videoUrl;
            const animationType = animScene.animationType || 'ken_burns';

            return `
                <div class="content-card" style="padding: 0; overflow: hidden;">
                    <div style="display: grid; grid-template-columns: 200px 1fr; gap: 0;">
                        <!-- Left: Image/Video Preview -->
                        <div style="position: relative; background: rgba(0,0,0,0.3);">
                            ${videoUrl ? `
                                <video id="animation-video-${scriptScene.id}" src="${videoUrl}" style="width: 100%; height: 180px; object-fit: cover;"></video>
                                <div style="position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); cursor: pointer;" onclick="playAnimationPreview(${scriptScene.id}, '${videoUrl}')">
                                    <div style="width: 3rem; height: 3rem; background: rgba(16, 185, 129, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-bottom: 0.5rem;">
                                        <span style="font-size: 1.5rem; margin-left: 0.2rem;"></span>
                                    </div>
                                    <span style="font-size: 0.7rem; color: white; font-weight: 600;">Click to Preview</span>
                                </div>
                                <div style="position: absolute; top: 0.5rem; right: 0.5rem; background: rgba(16, 185, 129, 0.9); padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.65rem; font-weight: 600;">
                                     ANIMATED
                                </div>
                            ` : imageUrl ? `
                                <img src="${imageUrl}" alt="Scene ${index + 1}" style="width: 100%; height: 180px; object-fit: cover;">
                                ${animationStatus === 'generating' ? `
                                    <div style="position: absolute; inset: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center;">
                                        <div class="animate-spin" style="width: 2rem; height: 2rem; border: 3px solid rgba(6,182,212,0.3); border-top-color: #06b6d4; border-radius: 50%; margin-bottom: 0.5rem;"></div>
                                        <div style="color: white; font-size: 0.75rem;">Animating...</div>
                                    </div>
                                ` : ''}
                            ` : `
                                <div style="width: 100%; height: 180px; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.4);">
                                    No Image
                                </div>
                            `}
                            <div style="position: absolute; top: 0.5rem; left: 0.5rem; width: 1.75rem; height: 1.75rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.75rem;">
                                ${index + 1}
                            </div>
                        </div>

                        <!-- Right: Controls -->
                        <div style="padding: 1rem;">
                            <!-- Narration Preview -->
                            <div style="font-size: 0.85rem; color: rgba(255,255,255,0.8); margin-bottom: 0.75rem; line-height: 1.4; max-height: 2.8em; overflow: hidden; text-overflow: ellipsis;">
                                "${scriptScene.narration?.substring(0, 100) || 'No narration'}${scriptScene.narration?.length > 100 ? '...' : ''}"
                            </div>

                            <!-- Voiceover Section -->
                            <div style="margin-bottom: 0.75rem;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);"> Voiceover:</span>
                                    ${voiceoverStatus === 'idle' ? `
                                        <span style="font-size: 0.7rem; color: rgba(255,255,255,0.4);">Not generated</span>
                                    ` : voiceoverStatus === 'generating' ? `
                                        <span style="font-size: 0.7rem; color: #a855f7;" class="animate-pulse">Generating...</span>
                                    ` : voiceoverStatus === 'ready' ? `
                                        <span style="font-size: 0.7rem; color: #10b981;"> Ready</span>
                                    ` : `
                                        <span style="font-size: 0.7rem; color: #ef4444;">Error</span>
                                    `}
                                </div>
                                ${voiceoverUrl ? `
                                    <audio src="${voiceoverUrl}" controls style="width: 100%; height: 28px; margin-bottom: 0.5rem;"></audio>
                                ` : ''}
                                <div style="display: flex; gap: 0.5rem;">
                                    <button onclick="generateSceneVoiceover(${scriptScene.id})"
                                            ${voiceoverStatus === 'generating' ? 'disabled' : ''}
                                            style="flex: 1; padding: 0.4rem 0.6rem; border-radius: 0.4rem; border: 1px solid rgba(139, 92, 246, 0.4); background: rgba(139, 92, 246, 0.15); color: ${voiceoverStatus === 'generating' ? 'rgba(255,255,255,0.4)' : 'white'}; cursor: ${voiceoverStatus === 'generating' ? 'wait' : 'pointer'}; font-size: 0.75rem;">
                                        ${voiceoverUrl ? ' Regenerate' : ' Generate'} Voice
                                    </button>
                                </div>
                            </div>

                            <!-- Animation Section -->
                            <div>
                                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);"> Animation Type:</span>
                                    <select onchange="setSceneAnimationType(${scriptScene.id}, this.value)"
                                            style="padding: 0.3rem 0.5rem; border-radius: 0.3rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(30,30,50,1); color: white; font-size: 0.7rem;">
                                        ${[
                                            { id: 'ken_burns', name: 'Ken Burns (Zoom/Pan)' },
                                            { id: 'talking_head', name: 'Talking Head' },
                                            { id: 'static', name: 'Static (No Animation)' }
                                        ].map(type => `
                                            <option value="${type.id}" ${animationType === type.id ? 'selected' : ''}>${type.name}</option>
                                        `).join('')}
                                    </select>
                                </div>
                                <button onclick="animateScene(${scriptScene.id})"
                                        ${!voiceoverUrl || animationStatus === 'generating' ? 'disabled' : ''}
                                        style="width: 100%; padding: 0.5rem; border-radius: 0.4rem; border: none; background: ${voiceoverUrl && animationStatus !== 'generating' ? 'linear-gradient(135deg, #06b6d4, #10b981)' : 'rgba(255,255,255,0.1)'}; color: ${voiceoverUrl && animationStatus !== 'generating' ? 'white' : 'rgba(255,255,255,0.4)'}; cursor: ${voiceoverUrl && animationStatus !== 'generating' ? 'pointer' : 'not-allowed'}; font-size: 0.8rem; font-weight: 600;">
                                    ${animationStatus === 'generating' ? ' Animating...' : videoUrl ? ' Re-Animate' : ' Animate Scene'}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Animation Functions
        function setGlobalVoice(voice) {
            state.animation.voiceover.voice = voice;
            // Update all scenes that haven't generated voiceover yet
            state.animation.scenes.forEach(scene => {
                if (!scene.voiceoverUrl) {
                    scene.voice = voice;
                }
            });
            saveProject();
            render();
        }

        function setGlobalSpeed(speed) {
            state.animation.voiceover.speed = parseFloat(speed);
            // Update all scenes that haven't generated voiceover yet
            state.animation.scenes.forEach(scene => {
                if (!scene.voiceoverUrl) {
                    scene.speed = parseFloat(speed);
                }
            });
            saveProject();
            render();
        }

        function setSceneAnimationType(sceneId, type) {
            const scene = state.animation.scenes.find(s => s.sceneId === sceneId);
            if (scene) {
                scene.animationType = type;
                saveProject();
            }
        }

        async function generateSceneVoiceover(sceneId) {
            const animScene = state.animation.scenes.find(s => s.sceneId === sceneId);
            const scriptScene = state.script.scenes.find(s => s.id === sceneId);

            if (!animScene || !scriptScene || !scriptScene.narration) {
                showToast('No narration available for this scene', 'error');
                return;
            }

            animScene.voiceoverStatus = 'generating';
            render();

            try {
                const generateVoiceover = firebase.functions().httpsCallable('creationWizardGenerateVoiceover');
                const result = await generateVoiceover({
                    projectId: state.project.id,
                    sceneId: sceneId,
                    text: scriptScene.narration,
                    voice: animScene.voice || state.animation.voiceover.voice,
                    speed: animScene.speed || state.animation.voiceover.speed
                });

                animScene.voiceoverStatus = 'ready';
                animScene.voiceoverUrl = result.data.audioUrl;
                animScene.voiceoverDuration = result.data.duration;  // Store actual audio duration

                // Phase 2: Audio-driven scene duration
                // Adjust scene duration to match voiceover + visual padding
                if (result.data.duration && result.data.duration > 0) {
                    const voiceoverDuration = result.data.duration;
                    const visualPadding = 1.0;  // 0.5s intro + 0.5s outro buffer
                    const newSceneDuration = Math.ceil(voiceoverDuration + visualPadding);

                    // Update script scene duration
                    const oldDuration = scriptScene.duration;
                    scriptScene.duration = newSceneDuration;

                    // Set voiceoverOffset to center audio within scene
                    // (padding / 2) gives equal buffer before and after voiceover
                    scriptScene.voiceoverOffset = visualPadding / 2;

                    // Recalculate total video duration
                    state.script.totalDuration = state.script.scenes.reduce((sum, s) => sum + (s.duration || 8), 0);

                    console.log(`[Voiceover] Scene ${sceneId}: voiceover=${voiceoverDuration.toFixed(2)}s, scene adjusted ${oldDuration}s  ${newSceneDuration}s, offset=${scriptScene.voiceoverOffset}s`);
                }

                showToast('Voiceover generated successfully!', 'success');
            } catch (error) {
                console.error('Voiceover generation error:', error);
                animScene.voiceoverStatus = 'error';
                showToast('Failed to generate voiceover: ' + error.message, 'error');
            }

            saveProject();
            render();
        }

        async function generateAllVoiceovers() {
            const scenesToGenerate = state.animation.scenes.filter(s => !s.voiceoverUrl && s.voiceoverStatus !== 'generating');

            if (scenesToGenerate.length === 0) {
                showToast('All voiceovers are already generated', 'info');
                return;
            }

            showToast(`Generating ${scenesToGenerate.length} voiceovers...`, 'info');

            // Generate sequentially to avoid rate limits
            for (const scene of scenesToGenerate) {
                await generateSceneVoiceover(scene.sceneId);
                // Small delay between generations
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            showToast('All voiceovers generated!', 'success');
        }

        // Video preview modal for animated scenes
        function playAnimationPreview(sceneId, videoUrl) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('animation-preview-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'animation-preview-modal';
                modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 2rem;';
                modal.innerHTML = `
                    <div style="position: relative; max-width: 900px; width: 100%; background: #1a1a2e; border-radius: 1rem; overflow: hidden; box-shadow: 0 25px 50px rgba(0,0,0,0.5);">
                        <div style="padding: 1rem; display: flex; align-items: center; justify-content: space-between; background: rgba(255,255,255,0.05);">
                            <span style="font-size: 1rem; font-weight: 600; color: white;" id="preview-modal-title">Animation Preview</span>
                            <button onclick="closeAnimationPreview()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem 0.5rem;"></button>
                        </div>
                        <div style="padding: 0;">
                            <video id="preview-modal-video" controls autoplay style="width: 100%; max-height: 70vh; background: black;"></video>
                        </div>
                        <div style="padding: 1rem; background: rgba(255,255,255,0.05); text-align: center;">
                            <span style="font-size: 0.85rem; color: rgba(255,255,255,0.6);">Scene animation preview  Click outside or press ESC to close</span>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                // Close on click outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeAnimationPreview();
                });

                // Close on ESC
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') closeAnimationPreview();
                });
            }

            // Update modal content
            const video = document.getElementById('preview-modal-video');
            const title = document.getElementById('preview-modal-title');
            const sceneIndex = state.script.scenes.findIndex(s => s.id === sceneId);

            video.src = videoUrl;
            title.textContent = `Scene ${sceneIndex + 1} Animation Preview`;
            modal.style.display = 'flex';

            // Play the video
            video.play().catch(() => {});
        }

        function closeAnimationPreview() {
            const modal = document.getElementById('animation-preview-modal');
            const video = document.getElementById('preview-modal-video');
            if (modal) {
                modal.style.display = 'none';
                if (video) {
                    video.pause();
                    video.src = '';
                }
            }
        }

        async function animateScene(sceneId) {
            // SMART ROUTING: Check video model provider to route to correct animation function
            const videoModel = state.content.videoModel || { provider: 'minimax', model: 'hailuo-2.3' };

            // If provider is minimax, use AI video generation
            if (videoModel.provider === 'minimax' || !videoModel.provider) {
                console.log('[animateScene] Routing to Minimax AI video for scene', sceneId);
                return animateSceneWithMinimax(sceneId);
            }

            // Fallback: Legacy Ken Burns animation (requires voiceover + RunPod)
            const animScene = state.animation.scenes.find(s => s.sceneId === sceneId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);

            if (!animScene || !storyboardScene || !storyboardScene.imageUrl) {
                showToast('No image available for animation', 'error');
                return;
            }

            if (!animScene.voiceoverUrl) {
                showToast('Please generate voiceover first', 'error');
                return;
            }

            animScene.animationStatus = 'generating';
            render();

            try {
                const animate = firebase.functions().httpsCallable('creationWizardAnimateScene');
                const result = await animate({
                    projectId: state.project.id,
                    sceneId: sceneId,
                    imageUrl: storyboardScene.imageUrl,
                    audioUrl: animScene.voiceoverUrl,
                    animationType: animScene.animationType || 'ken_burns'
                });

                // Start polling for completion
                animScene.jobId = result.data.jobId;
                pollAnimationStatus(sceneId, result.data.jobId);

            } catch (error) {
                console.error('Animation error:', error);
                animScene.animationStatus = 'error';
                showToast('Failed to start animation: ' + error.message, 'error');
                saveProject();
                render();
            }
        }

        async function pollAnimationStatus(sceneId, jobId) {
            const animScene = state.animation.scenes.find(s => s.sceneId === sceneId);
            if (!animScene) return;

            try {
                const checkStatus = firebase.functions().httpsCallable('creationWizardCheckAnimationStatus');
                const result = await checkStatus({ jobId });

                if (result.data.status === 'COMPLETED') {
                    animScene.animationStatus = 'ready';
                    animScene.videoUrl = result.data.videoUrl;
                    animScene.jobId = null;
                    showToast(`Scene ${state.script.scenes.findIndex(s => s.id === sceneId) + 1} animated!`, 'success');
                    saveProject();
                    render();
                } else if (result.data.status === 'FAILED') {
                    animScene.animationStatus = 'error';
                    animScene.jobId = null;
                    showToast('Animation failed. Please try again.', 'error');
                    saveProject();
                    render();
                } else {
                    // Still processing, poll again
                    setTimeout(() => pollAnimationStatus(sceneId, jobId), 5000);
                }
            } catch (error) {
                console.error('Animation status check error:', error);
                // Retry polling
                setTimeout(() => pollAnimationStatus(sceneId, jobId), 8000);
            }
        }

        async function animateAllScenes() {
            const scenesToAnimate = state.animation.scenes.filter(s => s.voiceoverUrl && !s.videoUrl && s.animationStatus !== 'generating');

            if (scenesToAnimate.length === 0) {
                showToast('No scenes ready to animate', 'info');
                return;
            }

            showToast(`Starting animation for ${scenesToAnimate.length} scenes...`, 'info');

            // Start all animations (they will poll independently)
            for (const scene of scenesToAnimate) {
                await animateScene(scene.sceneId);
                // Small delay between starting jobs
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }

        // ==========================================
        // 7.10 STEP 6: ASSEMBLY
        // ==========================================

        async function initializeAssembly() {
            // Load music library and options if not already loaded
            if (state.assembly.musicLibrary.length === 0) {
                try {
                    const getMusicLibrary = firebase.functions().httpsCallable('creationWizardGetMusicLibrary');
                    const result = await getMusicLibrary({});
                    state.assembly.musicLibrary = result.data.tracks || [];
                    state.assembly.transitionTypes = result.data.transitionTypes || [];
                    state.assembly.captionStyles = result.data.captionStyles || [];
                } catch (error) {
                    console.error('Failed to load music library:', error);
                    // Use defaults
                    state.assembly.transitionTypes = [
                        { id: 'cut', name: 'Cut' },
                        { id: 'fade', name: 'Fade' },
                        { id: 'crossfade', name: 'Crossfade' },
                        { id: 'dissolve', name: 'Dissolve' }
                    ];
                    state.assembly.captionStyles = [
                        { id: 'karaoke', name: 'Karaoke' },
                        { id: 'subtitle', name: 'Subtitle' },
                        { id: 'dynamic', name: 'Dynamic' },
                        { id: 'none', name: 'No Captions' }
                    ];
                }
            }

            // Initialize scene order if empty
            if (state.assembly.sceneOrder.length === 0 && state.script.scenes.length > 0) {
                state.assembly.sceneOrder = state.script.scenes.map(s => s.id);
            }

            // Initialize transitions for each scene if empty
            if (Object.keys(state.assembly.transitions).length === 0) {
                state.script.scenes.forEach(scene => {
                    state.assembly.transitions[scene.id] = { type: 'cut' };
                });
            }
        }

        function renderStep6Assembly() {
            // Initialize on first render
            if (state.assembly.musicLibrary.length === 0) {
                setTimeout(() => initializeAssembly().then(() => render()), 100);
            }

            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            // Calculate total duration
            let totalDuration = 0;
            sceneOrder.forEach(sceneId => {
                const scene = scriptScenes.find(s => s.id === sceneId);
                if (scene) totalDuration += scene.visualDuration || scene.duration || 8;
            });

            const activeTab = state.assembly.activeTab || 'text';
            const projectName = state.project.name || 'Untitled Video';
            const sceneCountText = sceneOrder.length + ' scenes';
            const durationText = formatDuration(totalDuration);

            // FULL-SCREEN FIXED LAYOUT - Like professional video editors
            let html = '';
            html += '<div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%); z-index: 100; display: flex; flex-direction: column; overflow: hidden;">';

            // TOP HEADER BAR
            html += '<div style="flex-shrink: 0; display: flex; align-items: center; gap: 1rem; padding: 0.5rem 1rem; background: rgba(20,20,35,0.98); border-bottom: 1px solid rgba(255,255,255,0.1);">';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 1.1rem;"></span>';
            html += '<span style="font-weight: 600; color: white; font-size: 0.9rem;">Video Creation Wizard</span>';
            html += '</div>';
            html += '<div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2);"></div>';
            html += '<span style="color: rgba(255,255,255,0.6); font-size: 0.8rem;">' + projectName + '</span>';
            html += '<div style="margin-left: auto; display: flex; align-items: center; gap: 1rem;">';
            html += '<span style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">' + sceneCountText + '  ' + durationText + '</span>';
            html += '<button onclick="saveAssemblySettings()" style="padding: 0.4rem 0.75rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-size: 0.75rem; font-weight: 600; cursor: pointer;"> Save</button>';
            html += '<button onclick="goToStep(5)" style="padding: 0.4rem 0.75rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; font-size: 0.75rem; cursor: pointer;"> Back</button>';
            html += '<button onclick="openExportModal()" style="padding: 0.4rem 0.75rem; border-radius: 0.4rem; border: none; background: #10b981; color: white; font-size: 0.75rem; font-weight: 600; cursor: pointer;"> Export</button>';
            html += '</div>';
            html += '</div>';

            // MAIN CONTENT AREA - Three columns
            html += '<div style="flex: 1; display: grid; grid-template-columns: 220px 340px 1fr; gap: 0; overflow: hidden;">';

            // LEFT SIDEBAR
            html += renderAssemblySidebar(sceneOrder.length, totalDuration);

            // MIDDLE PANEL - Tabbed Controls
            html += renderTabbedControlPanel(activeTab);

            // RIGHT PANEL - Preview
            html += renderCompactPreviewPanel();

            html += '</div>';

            // BOTTOM TIMELINE - pass all required parameters
            const timelineZoom = state.timeline.zoom || 50;
            const snapToGrid = state.timeline.snapToGrid !== false;
            const selectedClipId = state.timeline.selectedClipId || null;
            const currentTime = state.preview.currentTime || 0;
            const isReady = state.preview.isReady || false;

            html += '<div style="flex-shrink: 0;">';
            html += renderProfessionalTimeline(scriptScenes, animationScenes, totalDuration, timelineZoom, snapToGrid, selectedClipId, currentTime, isReady);
            html += '</div>';

            html += '</div>'; // Close fixed container

            // Add export modal if open
            if (state.export.showModal) {
                html += renderExportModal();
            }

            // Add music browser modal if open
            html += renderMusicBrowserModal();

            return html;
        }

        // LEFT SIDEBAR for Assembly
        function renderAssemblySidebar(sceneCount, totalDuration) {
            return `
                <div style="background: rgba(20,20,35,0.98); border-right: 1px solid rgba(255,255,255,0.1); padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem; overflow-y: auto;">
                    <!-- Project Info -->
                    <div style="padding: 0.5rem; background: rgba(139,92,246,0.1); border-radius: 0.5rem; margin-bottom: 0.5rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Project</div>
                        <div style="font-size: 0.85rem; color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${state.project.name || 'Untitled'}</div>
                    </div>

                    <!-- Navigation Items -->
                    <button onclick="setAssemblyTab('scenes')" style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.5rem; color: white; cursor: pointer; text-align: left; width: 100%;">
                        <span></span>
                        <span style="flex: 1; font-size: 0.8rem;">Scenes</span>
                        <span style="font-size: 0.7rem; color: rgba(255,255,255,0.5); background: rgba(139,92,246,0.2); padding: 0.15rem 0.4rem; border-radius: 0.25rem;">${sceneCount}</span>
                    </button>

                    <button onclick="setAssemblyTab('text')" style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem; background: ${state.assembly.activeTab === 'text' ? 'rgba(139,92,246,0.2)' : 'transparent'}; border: 1px solid ${state.assembly.activeTab === 'text' ? 'rgba(139,92,246,0.4)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; color: white; cursor: pointer; text-align: left; width: 100%;">
                        <span></span>
                        <span style="flex: 1; font-size: 0.8rem;">Captions</span>
                        ${state.assembly.captions.enabled ? '<span style="width: 8px; height: 8px; background: #10b981; border-radius: 50%;"></span>' : ''}
                    </button>

                    <button onclick="setAssemblyTab('audio')" style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem; background: ${state.assembly.activeTab === 'audio' ? 'rgba(139,92,246,0.2)' : 'transparent'}; border: 1px solid ${state.assembly.activeTab === 'audio' ? 'rgba(139,92,246,0.4)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; color: white; cursor: pointer; text-align: left; width: 100%;">
                        <span></span>
                        <span style="flex: 1; font-size: 0.8rem;">Audio</span>
                        ${state.assembly.music.enabled ? '<span style="width: 8px; height: 8px; background: #10b981; border-radius: 50%;"></span>' : ''}
                    </button>

                    <button onclick="setAssemblyTab('transitions')" style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem; background: ${state.assembly.activeTab === 'transitions' ? 'rgba(139,92,246,0.2)' : 'transparent'}; border: 1px solid ${state.assembly.activeTab === 'transitions' ? 'rgba(139,92,246,0.4)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; color: white; cursor: pointer; text-align: left; width: 100%;">
                        <span></span>
                        <span style="flex: 1; font-size: 0.8rem;">Transitions</span>
                    </button>

                    <div style="flex: 1;"></div>

                    <!-- Quick Actions -->
                    <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 0.75rem; margin-top: 0.5rem;">
                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.5px;">Quick Actions</div>
                        <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                            <button onclick="initializePreviewEngine()" style="display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem 0.6rem; background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3); border-radius: 0.4rem; color: #10b981; cursor: pointer; font-size: 0.7rem;">
                                <span></span> Preview
                            </button>
                            <button onclick="openExportModal()" style="display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem 0.6rem; background: rgba(139,92,246,0.1); border: 1px solid rgba(139,92,246,0.3); border-radius: 0.4rem; color: #a78bfa; cursor: pointer; font-size: 0.7rem;">
                                <span></span> Export
                            </button>
                        </div>
                    </div>

                    <!-- Duration Display -->
                    <div style="text-align: center; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 0.4rem; margin-top: 0.5rem;">
                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">Total Duration</div>
                        <div style="font-size: 1rem; color: white; font-weight: 600; font-family: monospace;">${formatDuration(totalDuration)}</div>
                    </div>
                </div>
            `;
        }

        // TABBED CONTROL PANEL
        function renderTabbedControlPanel(activeTab) {
            return `
                <div style="background: rgba(20,20,35,0.98); border-right: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; overflow: hidden;">
                    <!-- Tab Headers -->
                    <div style="display: flex; border-bottom: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.2);">
                        <button onclick="setAssemblyTab('text')" style="flex: 1; padding: 0.75rem 0.5rem; background: ${activeTab === 'text' ? 'rgba(139,92,246,0.15)' : 'transparent'}; border: none; border-bottom: 2px solid ${activeTab === 'text' ? '#8b5cf6' : 'transparent'}; color: ${activeTab === 'text' ? 'white' : 'rgba(255,255,255,0.5)'}; cursor: pointer; font-size: 0.75rem; font-weight: ${activeTab === 'text' ? '600' : '400'}; transition: all 0.2s;">
                            TEXT
                        </button>
                        <button onclick="setAssemblyTab('audio')" style="flex: 1; padding: 0.75rem 0.5rem; background: ${activeTab === 'audio' ? 'rgba(139,92,246,0.15)' : 'transparent'}; border: none; border-bottom: 2px solid ${activeTab === 'audio' ? '#8b5cf6' : 'transparent'}; color: ${activeTab === 'audio' ? 'white' : 'rgba(255,255,255,0.5)'}; cursor: pointer; font-size: 0.75rem; font-weight: ${activeTab === 'audio' ? '600' : '400'}; transition: all 0.2s;">
                            Audio
                        </button>
                        <button onclick="setAssemblyTab('media')" style="flex: 1; padding: 0.75rem 0.5rem; background: ${activeTab === 'media' ? 'rgba(139,92,246,0.15)' : 'transparent'}; border: none; border-bottom: 2px solid ${activeTab === 'media' ? '#8b5cf6' : 'transparent'}; color: ${activeTab === 'media' ? 'white' : 'rgba(255,255,255,0.5)'}; cursor: pointer; font-size: 0.75rem; font-weight: ${activeTab === 'media' ? '600' : '400'}; transition: all 0.2s;">
                            Media
                        </button>
                        <button onclick="setAssemblyTab('transitions')" style="flex: 1; padding: 0.75rem 0.5rem; background: ${activeTab === 'transitions' ? 'rgba(139,92,246,0.15)' : 'transparent'}; border: none; border-bottom: 2px solid ${activeTab === 'transitions' ? '#8b5cf6' : 'transparent'}; color: ${activeTab === 'transitions' ? 'white' : 'rgba(255,255,255,0.5)'}; cursor: pointer; font-size: 0.75rem; font-weight: ${activeTab === 'transitions' ? '600' : '400'}; transition: all 0.2s;">
                            Transitions
                        </button>
                    </div>

                    <!-- Tab Content -->
                    <div style="flex: 1; overflow-y: auto; padding: 1rem;">
                        ${activeTab === 'text' ? renderTextTabContent() : ''}
                        ${activeTab === 'audio' ? renderAudioTabContent() : ''}
                        ${activeTab === 'media' ? renderMediaTabContent() : ''}
                        ${activeTab === 'transitions' ? renderTransitionsTabContent() : ''}
                    </div>
                </div>
            `;
        }

        // TEXT TAB - Professional Caption Controls
        function renderTextTabContent() {
            const captions = state.assembly.captions;
            const fonts = ['Montserrat', 'Poppins', 'Roboto', 'Inter', 'Oswald', 'Bebas Neue', 'Anton', 'Playfair Display'];
            const effects = [
                { id: 'none', name: 'None', icon: '' },
                { id: 'pop', name: 'Pop', icon: '' },
                { id: 'fade', name: 'Fade', icon: '' },
                { id: 'zoom', name: 'Zoom', icon: '' },
                { id: 'bounce', name: 'Bounce', icon: '' }
            ];

            return `
                <!-- Captions Section Header -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">Captions</div>
                </div>

                <!-- Show Captions Toggle -->
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 0.5rem; margin-bottom: 1rem;">
                    <span style="font-size: 0.85rem; color: white;">Show Captions</span>
                    <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                        <input type="checkbox" ${captions.enabled ? 'checked' : ''} onchange="setCaptionEnabled(this.checked)" style="opacity: 0; width: 0; height: 0;">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: ${captions.enabled ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; transition: 0.3s; border-radius: 24px;">
                            <span style="position: absolute; content: ''; height: 18px; width: 18px; left: ${captions.enabled ? '23px' : '3px'}; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%;"></span>
                        </span>
                    </label>
                </div>

                <div style="opacity: ${captions.enabled ? '1' : '0.4'}; pointer-events: ${captions.enabled ? 'auto' : 'none'};">
                    <!-- Caption Style (Word/Sentence) -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">Caption Style</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                            <button onclick="setCaptionMode('word')" style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid ${captions.mode === 'word' ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; background: ${captions.mode === 'word' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.75rem; font-weight: ${captions.mode === 'word' ? '600' : '400'};">
                                WORD LEVEL
                            </button>
                            <button onclick="setCaptionMode('sentence')" style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid ${captions.mode === 'sentence' ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; background: ${captions.mode === 'sentence' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.75rem; font-weight: ${captions.mode === 'sentence' ? '600' : '400'};">
                                SENTENCE LEVEL
                            </button>
                        </div>
                    </div>

                    <!-- Font Selection -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">Font</label>
                        <select onchange="setCaptionFont(this.value)" style="width: 100%; padding: 0.6rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.8rem; cursor: pointer;">
                            ${fonts.map(f => `<option value="${f}" ${captions.fontFamily === f ? 'selected' : ''} style="font-family: ${f};">${f}</option>`).join('')}
                        </select>
                    </div>

                    <!-- Fill Color -->
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
                        <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Fill Color</span>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="color" value="${captions.fillColor}" onchange="setCaptionFillColor(this.value)" style="width: 32px; height: 24px; border: none; border-radius: 0.25rem; cursor: pointer; background: transparent;">
                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.5); font-family: monospace;">${captions.fillColor}</span>
                        </div>
                    </div>

                    <!-- Stroke Color -->
                    <div style="margin-bottom: 0.75rem;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.4rem;">
                            <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Stroke Color</span>
                            <input type="color" value="${captions.strokeColor}" onchange="setCaptionStrokeColor(this.value)" style="width: 24px; height: 18px; border: none; border-radius: 0.2rem; cursor: pointer;">
                        </div>
                    </div>

                    <!-- Stroke Width -->
                    <div style="margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.4rem;">
                            <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Stroke Width</span>
                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">${captions.strokeWidth}px</span>
                        </div>
                        <input type="range" min="0" max="5" step="0.5" value="${captions.strokeWidth}" onchange="setCaptionStrokeWidth(this.value)" style="width: 100%; height: 6px; cursor: pointer; accent-color: #8b5cf6;">
                    </div>

                    <!-- Effects Section -->
                    <div style="margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);"> EFFECTS</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.4rem;">
                            ${effects.map(e => `
                                <button onclick="setCaptionEffect('${e.id}')" style="padding: 0.4rem 0.25rem; border-radius: 0.3rem; border: 1px solid ${captions.effect === e.id ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${captions.effect === e.id ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.65rem; text-align: center;">
                                    <div style="font-size: 0.9rem; margin-bottom: 2px;">${e.icon}</div>
                                    ${e.name}
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Text Style Presets -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">Text Style</label>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.4rem;">
                            <button onclick="setCaptionStyle('karaoke')" style="padding: 0.5rem; border-radius: 0.3rem; border: 1px solid ${captions.style === 'karaoke' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${captions.style === 'karaoke' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.7rem;">
                                Karaoke
                            </button>
                            <button onclick="setCaptionStyle('beasty')" style="padding: 0.5rem; border-radius: 0.3rem; border: 1px solid ${captions.style === 'beasty' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${captions.style === 'beasty' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.7rem;">
                                Bold
                            </button>
                            <button onclick="setCaptionStyle('deepdiver')" style="padding: 0.5rem; border-radius: 0.3rem; border: 1px solid ${captions.style === 'deepdiver' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${captions.style === 'deepdiver' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.7rem;">
                                Minimal
                            </button>
                        </div>
                    </div>

                    <!-- Highlight Color -->
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; background: rgba(251,191,36,0.1); border: 1px solid rgba(251,191,36,0.3); border-radius: 0.5rem;">
                        <span style="font-size: 0.75rem; color: rgba(255,255,255,0.8);">Highlight Color</span>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="color" value="${captions.highlightColor}" onchange="setCaptionHighlightColor(this.value)" style="width: 32px; height: 24px; border: none; border-radius: 0.25rem; cursor: pointer;">
                            <span style="font-size: 0.65rem; padding: 0.2rem 0.4rem; background: rgba(251,191,36,0.2); color: #fbbf24; border-radius: 0.25rem;">KARAOKE</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // AUDIO TAB
        function renderAudioTabContent() {
            const musicLibrary = state.assembly.musicLibrary || [];
            const selectedTrackId = state.assembly.music.trackId;
            const musicEnabled = state.assembly.music.enabled;
            const musicVolume = state.assembly.music.volume;
            const voiceVolume = state.assembly.audioMix?.voiceVolume || 100;

            // Phase 4: Additional audio settings
            const audioDucking = state.assembly.audioMix?.ducking !== false;
            const musicFadeIn = state.assembly.music.fadeIn || 2;
            const musicFadeOut = state.assembly.music.fadeOut || 3;

            // Pre-compute styles to avoid complex template expressions
            const musicToggleBg = musicEnabled ? '#8b5cf6' : 'rgba(255,255,255,0.2)';
            const musicTogglePos = musicEnabled ? '23px' : '3px';
            const duckingToggleBg = audioDucking ? '#10b981' : 'rgba(255,255,255,0.2)';
            const duckingTogglePos = audioDucking ? '19px' : '3px';
            const musicPanelOpacity = musicEnabled ? '1' : '0.4';
            const musicPanelPointer = musicEnabled ? 'auto' : 'none';
            const voiceLabel = voiceVolume + '%';
            const musicLabel = musicEnabled ? musicVolume + '%' : 'Off';

            let html = '';

            // Smart Audio AI Panel (Phase 2)
            var audioProfile = state.assembly.audioProfile || null;
            var audioAnalyzing = state.assembly.audioAnalyzing || false;

            html += '<div style="margin-bottom: 1.25rem; padding: 1rem; background: linear-gradient(135deg, rgba(139,92,246,0.15), rgba(236,72,153,0.1)); border-radius: 0.75rem; border: 1px solid rgba(139,92,246,0.3);">';

            // Header
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 1.1rem;"></span>';
            html += '<span style="font-size: 0.85rem; font-weight: 600; color: white;">Smart Audio</span>';
            html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.4rem; background: linear-gradient(135deg, #8b5cf6, #ec4899); border-radius: 0.25rem; color: white; font-weight: 600;">AI</span>';
            html += '</div>';

            if (audioProfile) {
                html += '<span style="font-size: 0.6rem; color: #10b981;"> Analyzed</span>';
            }
            html += '</div>';

            // Description
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.6); margin-bottom: 0.75rem; line-height: 1.4;">';
            html += 'AI analyzes your content genre, pacing, and mood to recommend perfect background music, sound effects, and mix settings.';
            html += '</div>';

            if (audioAnalyzing) {
                // Loading state
                html += '<div style="display: flex; align-items: center; justify-content: center; padding: 1rem; gap: 0.5rem;">';
                html += '<div class="animate-spin" style="width: 20px; height: 20px; border: 2px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%;"></div>';
                html += '<span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Analyzing content...</span>';
                html += '</div>';
            } else if (audioProfile) {
                // Show recommendations
                html += '<div style="background: rgba(0,0,0,0.2); border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 0.75rem;">';

                // Recommended Track
                if (audioProfile.music && audioProfile.music.topPick) {
                    var topPick = audioProfile.music.topPick;
                    html += '<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">';
                    html += '<span style="font-size: 0.85rem;"></span>';
                    html += '<div style="flex: 1;">';
                    html += '<div style="font-size: 0.75rem; font-weight: 600; color: white;">' + (topPick.name || 'Recommended Track') + '</div>';
                    html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">' + (topPick.mood || '') + '  ' + (topPick.bpm || '?') + ' BPM  ' + (topPick.matchScore || 0) + '% match</div>';
                    html += '</div>';
                    html += '</div>';
                }

                // Mix Settings
                if (audioProfile.mix) {
                    html += '<div style="display: flex; gap: 0.75rem; flex-wrap: wrap; margin-top: 0.5rem;">';
                    html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);"><span style="color: #06b6d4;"></span> Voice: ' + audioProfile.mix.voiceVolume + '%</div>';
                    html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);"><span style="color: #8b5cf6;"></span> Music: ' + audioProfile.mix.musicVolume + '%</div>';
                    html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);"><span style="color: #f59e0b;"></span> SFX: ' + audioProfile.mix.sfxVolume + '%</div>';
                    html += '</div>';
                }

                // SFX & Ambience info
                if (audioProfile.sfx) {
                    html += '<div style="margin-top: 0.5rem; font-size: 0.6rem; color: rgba(255,255,255,0.5);">';
                    html += 'SFX Style: <span style="color: #a78bfa;">' + (audioProfile.sfx.style || 'subtle') + '</span>';
                    if (audioProfile.ambience && audioProfile.ambience.primaryAmbience) {
                        html += '  Ambience: <span style="color: #a78bfa;">' + audioProfile.ambience.primaryAmbience + '</span>';
                    }
                    html += '</div>';
                }

                html += '</div>';

                // Action buttons
                html += '<div style="display: flex; gap: 0.5rem;">';
                html += '<button onclick="applySmartAudioRecommendations()" style="flex: 1; padding: 0.6rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #8b5cf6, #ec4899); color: white; font-size: 0.75rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.3rem;">';
                html += ' Apply All Recommendations';
                html += '</button>';
                html += '<button onclick="analyzeContentForAudio()" style="padding: 0.6rem 0.75rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: rgba(255,255,255,0.7); font-size: 0.75rem; cursor: pointer;" title="Re-analyze">';
                html += '';
                html += '</button>';
                html += '</div>';

            } else {
                // No analysis yet - show analyze button
                html += '<button onclick="analyzeContentForAudio()" style="width: 100%; padding: 0.75rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #6366f1); color: white; font-size: 0.8rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.4rem;">';
                html += '<span style="font-size: 1rem;"></span>';
                html += 'Analyze & Get AI Recommendations';
                html += '</button>';
            }

            html += '</div>';

            // Audio Mix Visualization
            html += '<div style="margin-bottom: 1.25rem; padding: 0.75rem; background: linear-gradient(135deg, rgba(6,182,212,0.1), rgba(139,92,246,0.1)); border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.1);">';
            html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">Audio Mix</div>';
            html += '<div style="display: flex; align-items: flex-end; gap: 3px; height: 32px;">';
            // Static visualization bars
            html += '<div style="flex: 1; height: 70%; background: linear-gradient(to top, #06b6d4, #22d3ee); border-radius: 1px;"></div>';
            html += '<div style="flex: 1; height: 85%; background: linear-gradient(to top, #06b6d4, #22d3ee); border-radius: 1px;"></div>';
            html += '<div style="flex: 1; height: 60%; background: linear-gradient(to top, #06b6d4, #22d3ee); border-radius: 1px;"></div>';
            html += '<div style="flex: 1; height: 90%; background: linear-gradient(to top, #8b5cf6, #a78bfa); border-radius: 1px;"></div>';
            html += '<div style="flex: 1; height: 75%; background: linear-gradient(to top, #8b5cf6, #a78bfa); border-radius: 1px;"></div>';
            html += '<div style="flex: 1; height: 65%; background: linear-gradient(to top, #06b6d4, #22d3ee); border-radius: 1px;"></div>';
            html += '<div style="flex: 1; height: 80%; background: linear-gradient(to top, #8b5cf6, #a78bfa); border-radius: 1px;"></div>';
            html += '<div style="flex: 1; height: 55%; background: linear-gradient(to top, #06b6d4, #22d3ee); border-radius: 1px;"></div>';
            html += '</div>';
            html += '<div style="display: flex; justify-content: space-between; margin-top: 0.5rem;">';
            html += '<span style="font-size: 0.6rem; color: #06b6d4;"> Voice ' + voiceLabel + '</span>';
            html += '<span style="font-size: 0.6rem; color: #8b5cf6;"> Music ' + musicLabel + '</span>';
            html += '</div>';
            html += '</div>';

            // Voice Settings
            html += '<div style="margin-bottom: 1.25rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem;"> Voiceover</div>';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">';
            html += '<span style="font-size: 0.8rem; color: white;">Volume</span>';
            html += '<span style="font-size: 0.75rem; color: #06b6d4; font-weight: 600;">' + voiceVolume + '%</span>';
            html += '</div>';
            html += '<input type="range" min="0" max="100" value="' + voiceVolume + '" onchange="setVoiceVolume(this.value)" style="width: 100%; height: 6px; cursor: pointer; accent-color: #06b6d4;">';
            html += '</div>';

            // Background Music Section
            html += '<div style="margin-bottom: 1rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem;"> Background Music</div>';

            // Enable Toggle
            html += '<div style="display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 0.5rem; margin-bottom: 1rem;">';
            html += '<span style="font-size: 0.85rem; color: white;">Enable Music</span>';
            html += '<label style="position: relative; display: inline-block; width: 44px; height: 24px;">';
            html += '<input type="checkbox" ' + (musicEnabled ? 'checked' : '') + ' onchange="toggleMusic(this.checked)" style="opacity: 0; width: 0; height: 0;">';
            html += '<span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: ' + musicToggleBg + '; transition: 0.3s; border-radius: 24px;">';
            html += '<span style="position: absolute; height: 18px; width: 18px; left: ' + musicTogglePos + '; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%;"></span>';
            html += '</span>';
            html += '</label>';
            html += '</div>';

            // Music Controls (when enabled)
            html += '<div style="opacity: ' + musicPanelOpacity + '; pointer-events: ' + musicPanelPointer + ';">';

            // Track Selection
            html += '<div style="margin-bottom: 1rem;">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.4rem;">';
            html += '<label style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Select Track</label>';
            html += '<button onclick="openMusicBrowser()" style="padding: 0.25rem 0.5rem; border-radius: 0.3rem; border: 1px solid rgba(139,92,246,0.4); background: transparent; color: #a78bfa; font-size: 0.65rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;">';
            html += '<span></span> Browse Library';
            html += '</button>';
            html += '</div>';
            html += '<select id="music-select" onchange="selectMusicTrack(this.value)" style="width: 100%; padding: 0.6rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.8rem; cursor: pointer;">';
            html += '<option value="">Choose a track...</option>';
            musicLibrary.forEach(function(track) {
                var selected = selectedTrackId === track.id ? 'selected' : '';
                html += '<option value="' + track.id + '" ' + selected + '>' + track.name + '</option>';
            });
            html += '</select>';
            html += '</div>';

            // Volume
            html += '<div style="margin-bottom: 1rem;">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">';
            html += '<span style="font-size: 0.8rem; color: white;">Volume</span>';
            html += '<span style="font-size: 0.75rem; color: #8b5cf6; font-weight: 600;">' + musicVolume + '%</span>';
            html += '</div>';
            html += '<input type="range" min="0" max="100" value="' + musicVolume + '" onchange="setMusicVolume(this.value)" style="width: 100%; height: 6px; cursor: pointer; accent-color: #8b5cf6;">';
            html += '</div>';

            // Auto-Duck Toggle
            html += '<div style="display: flex; align-items: center; justify-content: space-between; padding: 0.6rem; background: rgba(255,255,255,0.03); border-radius: 0.4rem; margin-bottom: 1rem;">';
            html += '<div>';
            html += '<span style="font-size: 0.8rem; color: white;">Auto-Duck</span>';
            html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">Lower music during voice</div>';
            html += '</div>';
            html += '<label style="position: relative; display: inline-block; width: 36px; height: 20px;">';
            html += '<input type="checkbox" ' + (audioDucking ? 'checked' : '') + ' onchange="setAudioDucking(this.checked)" style="opacity: 0; width: 0; height: 0;">';
            html += '<span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: ' + duckingToggleBg + '; transition: 0.3s; border-radius: 20px;">';
            html += '<span style="position: absolute; height: 14px; width: 14px; left: ' + duckingTogglePos + '; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%;"></span>';
            html += '</span>';
            html += '</label>';
            html += '</div>';

            // Fade Controls
            html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">';
            html += '<div>';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.3rem;">';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">Fade In</span>';
            html += '<span style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">' + musicFadeIn + 's</span>';
            html += '</div>';
            html += '<input type="range" min="0" max="5" step="0.5" value="' + musicFadeIn + '" onchange="setMusicFadeIn(this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #8b5cf6;">';
            html += '</div>';
            html += '<div>';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.3rem;">';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">Fade Out</span>';
            html += '<span style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">' + musicFadeOut + 's</span>';
            html += '</div>';
            html += '<input type="range" min="0" max="5" step="0.5" value="' + musicFadeOut + '" onchange="setMusicFadeOut(this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #8b5cf6;">';
            html += '</div>';
            html += '</div>';

            html += '</div>'; // Close music controls
            html += '</div>'; // Close background music section

            // Phase 3D: Audio Intelligence Section
            html += '<div style="margin-top: 1.25rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px;"> Audio Intelligence</div>';
            html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.4rem; background: linear-gradient(135deg, #f59e0b, #ef4444); border-radius: 0.2rem; color: white; font-weight: 600;">AI</span>';
            html += '</div>';

            // Audio Mood Selector (links to Visual Intelligence)
            var audioMood = state.assembly.audioMood || state.storyboard.visualStyle?.mood || '';
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Audio Mood</label>';
            html += '<select onchange="setAudioMood(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem;">';
            html += '<option value="">Auto (from genre)</option>';
            html += '<option value="epic"' + (audioMood === 'epic' ? ' selected' : '') + '> Epic</option>';
            html += '<option value="intimate"' + (audioMood === 'intimate' ? ' selected' : '') + '> Intimate</option>';
            html += '<option value="mysterious"' + (audioMood === 'mysterious' ? ' selected' : '') + '> Mysterious</option>';
            html += '<option value="energetic"' + (audioMood === 'energetic' ? ' selected' : '') + '> Energetic</option>';
            html += '<option value="contemplative"' + (audioMood === 'contemplative' ? ' selected' : '') + '> Contemplative</option>';
            html += '<option value="tense"' + (audioMood === 'tense' ? ' selected' : '') + '> Tense</option>';
            html += '<option value="hopeful"' + (audioMood === 'hopeful' ? ' selected' : '') + '> Hopeful</option>';
            html += '<option value="professional"' + (audioMood === 'professional' ? ' selected' : '') + '> Professional</option>';
            html += '<option value="nostalgic"' + (audioMood === 'nostalgic' ? ' selected' : '') + '> Nostalgic</option>';
            html += '<option value="dark"' + (audioMood === 'dark' ? ' selected' : '') + '> Dark</option>';
            html += '</select>';
            html += '</div>';

            // Voice Enhancement Profile
            var voiceProfile = state.assembly.voiceProfile || '';
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Voice Style</label>';
            html += '<select onchange="setVoiceProfile(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem;">';
            html += '<option value="">Auto (from genre)</option>';
            html += '<option value="narrator-warm"' + (voiceProfile === 'narrator-warm' ? ' selected' : '') + '> Warm Narrator</option>';
            html += '<option value="narrator-authoritative"' + (voiceProfile === 'narrator-authoritative' ? ' selected' : '') + '> Authoritative</option>';
            html += '<option value="narrator-intimate"' + (voiceProfile === 'narrator-intimate' ? ' selected' : '') + '> Intimate</option>';
            html += '<option value="narrator-energetic"' + (voiceProfile === 'narrator-energetic' ? ' selected' : '') + '> Energetic</option>';
            html += '<option value="documentary"' + (voiceProfile === 'documentary' ? ' selected' : '') + '> Documentary</option>';
            html += '<option value="cinematic-trailer"' + (voiceProfile === 'cinematic-trailer' ? ' selected' : '') + '> Cinematic Trailer</option>';
            html += '<option value="podcast"' + (voiceProfile === 'podcast' ? ' selected' : '') + '> Podcast</option>';
            html += '</select>';
            html += '</div>';

            // Transition Sound Style
            var transitionSound = state.assembly.transitionSound || '';
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Transition Sounds</label>';
            html += '<select onchange="setTransitionSound(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem;">';
            html += '<option value="">None</option>';
            html += '<option value="whoosh-soft"' + (transitionSound === 'whoosh-soft' ? ' selected' : '') + '> Soft Whoosh</option>';
            html += '<option value="whoosh-medium"' + (transitionSound === 'whoosh-medium' ? ' selected' : '') + '> Medium Whoosh</option>';
            html += '<option value="whoosh-hard"' + (transitionSound === 'whoosh-hard' ? ' selected' : '') + '> Hard Whoosh</option>';
            html += '<option value="swoosh-magical"' + (transitionSound === 'swoosh-magical' ? ' selected' : '') + '> Magical Swoosh</option>';
            html += '<option value="glitch"' + (transitionSound === 'glitch' ? ' selected' : '') + '> Glitch</option>';
            html += '<option value="tape-stop"' + (transitionSound === 'tape-stop' ? ' selected' : '') + '> Tape Stop</option>';
            html += '<option value="sub-drop"' + (transitionSound === 'sub-drop' ? ' selected' : '') + '> Sub Drop</option>';
            html += '</select>';
            html += '</div>';

            // Ambience Layer
            var ambienceLayer = state.assembly.ambienceLayer || '';
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Ambience Layer</label>';
            html += '<select onchange="setAmbienceLayer(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem;">';
            html += '<option value="">None</option>';
            html += '<option value="nature-forest"' + (ambienceLayer === 'nature-forest' ? ' selected' : '') + '> Forest</option>';
            html += '<option value="nature-ocean"' + (ambienceLayer === 'nature-ocean' ? ' selected' : '') + '> Ocean</option>';
            html += '<option value="nature-rain"' + (ambienceLayer === 'nature-rain' ? ' selected' : '') + '> Rain</option>';
            html += '<option value="nature-night"' + (ambienceLayer === 'nature-night' ? ' selected' : '') + '> Night</option>';
            html += '<option value="urban-city"' + (ambienceLayer === 'urban-city' ? ' selected' : '') + '> City</option>';
            html += '<option value="urban-cafe"' + (ambienceLayer === 'urban-cafe' ? ' selected' : '') + '> Caf</option>';
            html += '<option value="urban-office"' + (ambienceLayer === 'urban-office' ? ' selected' : '') + '> Office</option>';
            html += '<option value="space-scifi"' + (ambienceLayer === 'space-scifi' ? ' selected' : '') + '> Space/Sci-Fi</option>';
            html += '</select>';
            html += '</div>';

            // Audio Intelligence Tip
            if (audioMood) {
                var moodTips = {
                    'epic': 'Orchestral swells, brass fanfares, wide dynamics',
                    'intimate': 'Soft piano, minimal arrangement, gentle pads',
                    'mysterious': 'Dark drones, sparse elements, tension holds',
                    'energetic': 'Driving drums, punchy bass, constant momentum',
                    'contemplative': 'Ambient textures, slow evolution, space',
                    'tense': 'Staccato strings, building pressure, dissonance',
                    'hopeful': 'Uplifting strings, major keys, dawn-like builds',
                    'professional': 'Clean synths, consistent dynamics, polished',
                    'nostalgic': 'Warm tones, vinyl texture, retro keys',
                    'dark': 'Sub bass, industrial elements, ominous choir'
                };
                html += '<div style="padding: 0.5rem; background: rgba(139,92,246,0.1); border: 1px solid rgba(139,92,246,0.2); border-radius: 0.4rem; margin-top: 0.5rem;">';
                html += '<div style="font-size: 0.65rem; color: #a78bfa;"> ' + (moodTips[audioMood] || 'Custom audio treatment applied') + '</div>';
                html += '</div>';
            }

            html += '</div>'; // Close Audio Intelligence section

            // Phase 5: Beat Synchronization Section
            html += renderBeatSyncSection();

            return html;
        }

        // Phase 5: Beat Sync Section
        function renderBeatSyncSection() {
            const beatSync = state.assembly.beatSync || {};
            const musicEnabled = state.assembly.music.enabled;
            const selectedTrack = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music.trackId);
            const scenes = state.script.scenes || [];
            const hasSuggestions = beatSync.suggestions && beatSync.suggestions.length > 0;

            let html = '';
            html += '<div style="margin-top: 1.25rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">';

            // Header
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">';
            html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span style="font-size: 1rem;"></span>';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px;">Beat Sync</span>';
            html += '</div>';
            html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.4rem; background: linear-gradient(135deg, #06b6d4, #8b5cf6); border-radius: 0.2rem; color: white; font-weight: 600;">PRO</span>';
            html += '</div>';

            // Description
            html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.75rem; line-height: 1.4;">';
            html += 'Align scene cuts with music beats for professional rhythm. Scene transitions will snap to measure boundaries.';
            html += '</div>';

            if (!musicEnabled) {
                // Music not enabled warning
                html += '<div style="padding: 0.75rem; background: rgba(245,158,11,0.1); border: 1px solid rgba(245,158,11,0.3); border-radius: 0.5rem; text-align: center;">';
                html += '<div style="font-size: 0.7rem; color: #f59e0b;">Enable background music to use Beat Sync</div>';
                html += '</div>';
            } else if (!selectedTrack) {
                // No track selected warning
                html += '<div style="padding: 0.75rem; background: rgba(245,158,11,0.1); border: 1px solid rgba(245,158,11,0.3); border-radius: 0.5rem; text-align: center;">';
                html += '<div style="font-size: 0.7rem; color: #f59e0b;">Select a music track to enable Beat Sync</div>';
                html += '</div>';
            } else {
                // Track info
                var trackBpm = selectedTrack.bpm || 120;
                html += '<div style="padding: 0.5rem; background: rgba(6,182,212,0.1); border: 1px solid rgba(6,182,212,0.2); border-radius: 0.4rem; margin-bottom: 0.75rem;">';
                html += '<div style="display: flex; align-items: center; justify-content: space-between;">';
                html += '<div style="font-size: 0.7rem; color: white;">' + selectedTrack.name + '</div>';
                html += '<div style="font-size: 0.65rem; color: #06b6d4; font-weight: 600;">' + trackBpm + ' BPM</div>';
                html += '</div>';
                html += '</div>';

                // Sync Mode Selector
                var syncMode = beatSync.syncMode || 'balanced';
                html += '<div style="margin-bottom: 0.75rem;">';
                html += '<label style="display: block; font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Sync Precision</label>';
                html += '<div style="display: flex; gap: 0.4rem;">';
                html += '<button onclick="setBeatSyncMode(\'tight\')" style="flex: 1; padding: 0.4rem; border-radius: 0.3rem; border: 1px solid ' + (syncMode === 'tight' ? '#06b6d4' : 'rgba(255,255,255,0.2)') + '; background: ' + (syncMode === 'tight' ? 'rgba(6,182,212,0.2)' : 'transparent') + '; color: ' + (syncMode === 'tight' ? '#06b6d4' : 'rgba(255,255,255,0.6)') + '; font-size: 0.65rem; cursor: pointer;">';
                html += 'Tight';
                html += '</button>';
                html += '<button onclick="setBeatSyncMode(\'balanced\')" style="flex: 1; padding: 0.4rem; border-radius: 0.3rem; border: 1px solid ' + (syncMode === 'balanced' ? '#06b6d4' : 'rgba(255,255,255,0.2)') + '; background: ' + (syncMode === 'balanced' ? 'rgba(6,182,212,0.2)' : 'transparent') + '; color: ' + (syncMode === 'balanced' ? '#06b6d4' : 'rgba(255,255,255,0.6)') + '; font-size: 0.65rem; cursor: pointer;">';
                html += 'Balanced';
                html += '</button>';
                html += '<button onclick="setBeatSyncMode(\'relaxed\')" style="flex: 1; padding: 0.4rem; border-radius: 0.3rem; border: 1px solid ' + (syncMode === 'relaxed' ? '#06b6d4' : 'rgba(255,255,255,0.2)') + '; background: ' + (syncMode === 'relaxed' ? 'rgba(6,182,212,0.2)' : 'transparent') + '; color: ' + (syncMode === 'relaxed' ? '#06b6d4' : 'rgba(255,255,255,0.6)') + '; font-size: 0.65rem; cursor: pointer;">';
                html += 'Relaxed';
                html += '</button>';
                html += '</div>';
                html += '<div style="font-size: 0.55rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">';
                if (syncMode === 'tight') html += 'Cuts every 2 measures - fast paced editing';
                else if (syncMode === 'balanced') html += 'Cuts every 4 measures - natural rhythm';
                else html += 'Cuts every 8 measures - cinematic pacing';
                html += '</div>';
                html += '</div>';

                // Analysis/Preview
                if (beatSync.analyzing) {
                    html += '<div style="display: flex; align-items: center; justify-content: center; padding: 1rem; gap: 0.5rem;">';
                    html += '<div class="animate-spin" style="width: 20px; height: 20px; border: 2px solid rgba(6,182,212,0.3); border-top-color: #06b6d4; border-radius: 50%;"></div>';
                    html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">Analyzing beat alignment...</span>';
                    html += '</div>';
                } else if (hasSuggestions) {
                    // Show analysis results
                    var summary = beatSync.summary || {};
                    var score = summary.overallScore || 0;
                    var scoreColor = score >= 80 ? '#10b981' : score >= 60 ? '#f59e0b' : '#ef4444';

                    html += '<div style="padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 0.5rem; margin-bottom: 0.75rem;">';

                    // Score display
                    html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">';
                    html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">Alignment Score</span>';
                    html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
                    html += '<div style="width: 60px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">';
                    html += '<div style="width: ' + score + '%; height: 100%; background: ' + scoreColor + '; border-radius: 3px;"></div>';
                    html += '</div>';
                    html += '<span style="font-size: 0.75rem; font-weight: 600; color: ' + scoreColor + ';">' + score + '%</span>';
                    html += '</div>';
                    html += '</div>';

                    // Sync breakdown
                    html += '<div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">';
                    if (summary.perfectSyncs > 0) {
                        html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.35rem; background: rgba(16,185,129,0.2); color: #10b981; border-radius: 0.2rem;"> ' + summary.perfectSyncs + ' perfect</span>';
                    }
                    if (summary.greatSyncs > 0) {
                        html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.35rem; background: rgba(6,182,212,0.2); color: #06b6d4; border-radius: 0.2rem;"> ' + summary.greatSyncs + ' great</span>';
                    }
                    if (summary.goodSyncs > 0) {
                        html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.35rem; background: rgba(245,158,11,0.2); color: #f59e0b; border-radius: 0.2rem;"> ' + summary.goodSyncs + ' good</span>';
                    }
                    if (summary.keptOriginal > 0) {
                        html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.35rem; background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.5); border-radius: 0.2rem;"> ' + summary.keptOriginal + ' kept</span>';
                    }
                    html += '</div>';

                    html += '</div>';

                    // Scene adjustments preview
                    html += '<div style="max-height: 120px; overflow-y: auto; margin-bottom: 0.75rem;">';
                    beatSync.suggestions.forEach(function(s, i) {
                        if (s.quality === 'keep') return; // Skip unchanged scenes

                        var qualityColors = { perfect: '#10b981', great: '#06b6d4', good: '#f59e0b' };
                        var qualityIcons = { perfect: '', great: '', good: '' };
                        var adjustText = s.adjustmentSeconds > 0 ? '+' + s.adjustmentSeconds + 's' : s.adjustmentSeconds + 's';

                        html += '<div style="display: flex; align-items: center; justify-content: space-between; padding: 0.35rem 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.25rem; margin-bottom: 0.25rem;">';
                        html += '<div style="display: flex; align-items: center; gap: 0.4rem;">';
                        html += '<span style="font-size: 0.65rem; color: ' + qualityColors[s.quality] + ';">' + qualityIcons[s.quality] + '</span>';
                        html += '<span style="font-size: 0.65rem; color: rgba(255,255,255,0.7);">Scene ' + (i + 1) + '</span>';
                        html += '</div>';
                        html += '<div style="display: flex; align-items: center; gap: 0.5rem;">';
                        html += '<span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">' + (s.originalDuration / 1000).toFixed(1) + 's  ' + (s.suggestedDuration / 1000).toFixed(1) + 's</span>';
                        html += '<span style="font-size: 0.55rem; padding: 0.1rem 0.25rem; background: rgba(6,182,212,0.2); color: #06b6d4; border-radius: 0.15rem;">' + adjustText + '</span>';
                        html += '</div>';
                        html += '</div>';
                    });
                    html += '</div>';

                    // Action buttons
                    html += '<div style="display: flex; gap: 0.5rem;">';
                    html += '<button onclick="applyBeatSyncSuggestions()" style="flex: 1; padding: 0.6rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #06b6d4, #8b5cf6); color: white; font-size: 0.75rem; font-weight: 600; cursor: pointer;">';
                    html += ' Apply Beat Sync';
                    html += '</button>';
                    html += '<button onclick="analyzeBeatSync()" style="padding: 0.6rem 0.75rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: rgba(255,255,255,0.7); font-size: 0.75rem; cursor: pointer;" title="Re-analyze">';
                    html += '';
                    html += '</button>';
                    html += '</div>';

                } else {
                    // No analysis yet - show analyze button
                    html += '<button onclick="analyzeBeatSync()" style="width: 100%; padding: 0.75rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #06b6d4, #0891b2); color: white; font-size: 0.8rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.4rem;">';
                    html += '<span style="font-size: 1rem;"></span>';
                    html += 'Analyze Beat Alignment';
                    html += '</button>';

                    html += '<div style="font-size: 0.55rem; color: rgba(255,255,255,0.4); text-align: center; margin-top: 0.5rem;">';
                    html += scenes.length + ' scenes will be analyzed against ' + trackBpm + ' BPM rhythm';
                    html += '</div>';
                }
            }

            html += '</div>'; // Close Beat Sync section

            return html;
        }

        // MEDIA TAB
        function renderMediaTabContent() {
            const scriptScenes = state.script.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const currentSceneIndex = state.preview.currentSceneIndex || 0;

            // Build HTML using string concatenation to avoid template literal issues
            let html = '';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem;">Scene Media</div>';

            // Scene count summary
            html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(139,92,246,0.1); border-radius: 0.4rem;">';
            html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.7);">' + scriptScenes.length + ' Scenes</span>';
            html += '<span style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">Click to jump</span>';
            html += '</div>';

            html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; max-height: 400px; overflow-y: auto; padding-right: 0.25rem;">';

            scriptScenes.forEach(function(scene, i) {
                const storyboard = storyboardScenes.find(function(s) { return s.sceneId === scene.id; });
                const anim = animationScenes.find(function(s) { return s.sceneId === scene.id; });
                const imageUrl = storyboard ? storyboard.imageUrl : null;
                const hasVideo = anim ? anim.videoUrl : false;
                const duration = scene.duration || 5;
                const isActive = i === currentSceneIndex;

                // Pre-compute styles
                const borderColor = isActive ? 'rgba(139,92,246,0.8)' : 'rgba(255,255,255,0.1)';
                const shadowStyle = isActive ? '0 0 15px rgba(139,92,246,0.4)' : 'none';
                const bgColor = isActive ? 'rgba(139,92,246,0.15)' : 'rgba(255,255,255,0.03)';
                const statusColor = hasVideo ? '#10b981' : '#f59e0b';
                const statusText = hasVideo ? ' Video' : ' Image';

                html += '<div onclick="seekToScene(' + scene.id + ')" ';
                html += 'style="background: ' + bgColor + '; border: 1px solid ' + borderColor + '; border-radius: 0.5rem; overflow: hidden; cursor: pointer; transition: all 0.2s; box-shadow: ' + shadowStyle + ';" ';
                html += 'onmouseenter="this.style.borderColor=\'rgba(139,92,246,0.6)\';this.style.transform=\'scale(1.02)\'" ';
                html += 'onmouseleave="this.style.borderColor=\'' + borderColor + '\';this.style.transform=\'scale(1)\'">';

                html += '<div style="aspect-ratio: 16/9; background: rgba(0,0,0,0.3); position: relative;">';
                if (imageUrl) {
                    html += '<img src="' + imageUrl + '" style="width: 100%; height: 100%; object-fit: cover;">';
                } else {
                    html += '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3);"></div>';
                }

                // Duration badge overlay
                html += '<div style="position: absolute; bottom: 4px; right: 4px; background: rgba(0,0,0,0.75); padding: 2px 6px; border-radius: 3px; font-size: 0.6rem; color: white; font-family: monospace;">';
                html += duration.toFixed(1) + 's';
                html += '</div>';

                // Active indicator
                if (isActive) {
                    html += '<div style="position: absolute; top: 4px; left: 4px; background: rgba(139,92,246,0.9); padding: 2px 6px; border-radius: 3px; font-size: 0.55rem; color: white; font-weight: 600;">PLAYING</div>';
                }

                html += '</div>';

                html += '<div style="padding: 0.4rem;">';
                html += '<div style="display: flex; justify-content: space-between; align-items: center;">';
                html += '<div style="font-size: 0.7rem; color: white; font-weight: ' + (isActive ? '600' : '400') + ';">Scene ' + (i + 1) + '</div>';
                html += '<div style="font-size: 0.6rem; color: ' + statusColor + ';">' + statusText + '</div>';
                html += '</div>';
                html += '</div>';

                html += '</div>';
            });

            html += '</div>';

            return html;
        }

        // TRANSITIONS TAB
        function renderTransitionsTabContent() {
            const scriptScenes = state.script.scenes || [];
            const transitionTypes = state.assembly.transitionTypes || [];

            // Default transitions if not defined
            const defaultTypes = transitionTypes.length > 0 ? transitionTypes : [
                { id: 'fade', name: 'Fade', icon: '' },
                { id: 'dissolve', name: 'Dissolve', icon: '' },
                { id: 'wipe', name: 'Wipe', icon: '' },
                { id: 'slide', name: 'Slide', icon: '' },
                { id: 'zoom', name: 'Zoom', icon: '' },
                { id: 'none', name: 'Cut (None)', icon: '' }
            ];

            // Build HTML using string concatenation
            let html = '';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem;">Scene Transitions</div>';

            // Default transition selector
            html += '<div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(139,92,246,0.1); border: 1px solid rgba(139,92,246,0.3); border-radius: 0.5rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Default for all transitions:</div>';
            html += '<select onchange="setDefaultTransition(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(139,92,246,0.4); border-radius: 0.4rem; color: white; font-size: 0.8rem; cursor: pointer;">';

            const defaultTransition = state.assembly.defaultTransition || 'fade';
            defaultTypes.forEach(function(t) {
                const selected = defaultTransition === t.id ? ' selected' : '';
                const icon = t.icon || '';
                html += '<option value="' + t.id + '"' + selected + '>' + icon + ' ' + t.name + '</option>';
            });
            html += '</select>';
            html += '</div>';

            // Per-scene transitions
            if (scriptScenes.length > 1) {
                html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.5rem;">Per-Scene Overrides:</div>';
                html += '<div style="display: flex; flex-direction: column; gap: 0.5rem; max-height: 300px; overflow-y: auto; padding-right: 0.25rem;">';

                scriptScenes.slice(0, -1).forEach(function(scene, i) {
                    const transition = state.assembly.transitions[scene.id] || { type: defaultTransition };

                    html += '<div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.6rem; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08); border-radius: 0.4rem;">';

                    // Scene indicators with mini thumbnails
                    html += '<div style="display: flex; align-items: center; gap: 0.3rem; min-width: 90px;">';
                    html += '<div style="width: 24px; height: 16px; background: rgba(139,92,246,0.3); border-radius: 2px; display: flex; align-items: center; justify-content: center; font-size: 0.5rem; color: white;">' + (i + 1) + '</div>';
                    html += '<span style="font-size: 0.7rem; color: rgba(255,255,255,0.5);"></span>';
                    html += '<div style="width: 24px; height: 16px; background: rgba(6,182,212,0.3); border-radius: 2px; display: flex; align-items: center; justify-content: center; font-size: 0.5rem; color: white;">' + (i + 2) + '</div>';
                    html += '</div>';

                    // Transition selector
                    html += '<select onchange="setSceneTransition(' + scene.id + ', this.value)" style="flex: 1; padding: 0.35rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.3rem; color: white; font-size: 0.7rem; cursor: pointer;">';
                    defaultTypes.forEach(function(t) {
                        const selected = transition.type === t.id ? ' selected' : '';
                        const icon = t.icon || '';
                        html += '<option value="' + t.id + '"' + selected + '>' + icon + ' ' + t.name + '</option>';
                    });
                    html += '</select>';

                    html += '</div>';
                });

                html += '</div>';
            } else {
                html += '<div style="text-align: center; padding: 2rem; color: rgba(255,255,255,0.4); font-size: 0.8rem;">';
                html += 'Add more scenes to configure transitions';
                html += '</div>';
            }

            // Phase 3E: Smart Assembly Intelligence Section
            html += '<div style="margin-top: 1.25rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px;"> Smart Assembly</div>';
            html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.4rem; background: linear-gradient(135deg, #06b6d4, #8b5cf6); border-radius: 0.2rem; color: white; font-weight: 600;">AI</span>';
            html += '</div>';

            // Assembly Preset Selector
            var assemblyPreset = state.assembly.assemblyPreset || '';
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Assembly Preset</label>';
            html += '<select onchange="setAssemblyPreset(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem;">';
            html += '<option value="">Auto (from genre)</option>';
            html += '<option value="youtube-engaging"' + (assemblyPreset === 'youtube-engaging' ? ' selected' : '') + '> YouTube Engaging</option>';
            html += '<option value="tiktok-viral"' + (assemblyPreset === 'tiktok-viral' ? ' selected' : '') + '> TikTok Viral</option>';
            html += '<option value="cinematic-film"' + (assemblyPreset === 'cinematic-film' ? ' selected' : '') + '> Cinematic Film</option>';
            html += '<option value="documentary"' + (assemblyPreset === 'documentary' ? ' selected' : '') + '> Documentary</option>';
            html += '<option value="music-video"' + (assemblyPreset === 'music-video' ? ' selected' : '') + '> Music Video</option>';
            html += '<option value="commercial-ad"' + (assemblyPreset === 'commercial-ad' ? ' selected' : '') + '> Commercial/Ad</option>';
            html += '<option value="educational"' + (assemblyPreset === 'educational' ? ' selected' : '') + '> Educational</option>';
            html += '<option value="asmr-relaxation"' + (assemblyPreset === 'asmr-relaxation' ? ' selected' : '') + '> ASMR/Relaxation</option>';
            html += '</select>';
            html += '</div>';

            // Pacing Profile Selector
            var pacingProfile = state.assembly.pacingProfile || '';
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Pacing Profile</label>';
            html += '<select onchange="setPacingProfile(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem;">';
            html += '<option value="">Auto (from preset)</option>';
            html += '<option value="rapid-fire"' + (pacingProfile === 'rapid-fire' ? ' selected' : '') + '> Rapid Fire (1-2s)</option>';
            html += '<option value="fast"' + (pacingProfile === 'fast' ? ' selected' : '') + '> Fast (2-3s)</option>';
            html += '<option value="dynamic"' + (pacingProfile === 'dynamic' ? ' selected' : '') + '> Dynamic (varies)</option>';
            html += '<option value="balanced"' + (pacingProfile === 'balanced' ? ' selected' : '') + '> Balanced (3-5s)</option>';
            html += '<option value="contemplative"' + (pacingProfile === 'contemplative' ? ' selected' : '') + '> Contemplative (5-8s)</option>';
            html += '<option value="cinematic"' + (pacingProfile === 'cinematic' ? ' selected' : '') + '> Cinematic (6-12s)</option>';
            html += '<option value="episodic"' + (pacingProfile === 'episodic' ? ' selected' : '') + '> Episodic (structured)</option>';
            html += '</select>';
            html += '</div>';

            // Beat Sync Mode Selector
            var beatSyncMode = state.assembly.beatSyncMode || 'off';
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Beat Synchronization</label>';
            html += '<select onchange="setBeatSyncMode(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem;">';
            html += '<option value="off"' + (beatSyncMode === 'off' ? ' selected' : '') + '> Off</option>';
            html += '<option value="subtle"' + (beatSyncMode === 'subtle' ? ' selected' : '') + '> Subtle (phrases)</option>';
            html += '<option value="moderate"' + (beatSyncMode === 'moderate' ? ' selected' : '') + '> Moderate (measures)</option>';
            html += '<option value="aggressive"' + (beatSyncMode === 'aggressive' ? ' selected' : '') + '> Aggressive (beats)</option>';
            html += '<option value="music-video"' + (beatSyncMode === 'music-video' ? ' selected' : '') + '> Music Video (every beat)</option>';
            html += '</select>';
            html += '</div>';

            // Pattern Interrupt Strategy
            var patternInterrupt = state.assembly.patternInterrupt || '';
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Pattern Interrupts</label>';
            html += '<select onchange="setPatternInterrupt(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem;">';
            html += '<option value="">Auto (from platform)</option>';
            html += '<option value="youtube"' + (patternInterrupt === 'youtube' ? ' selected' : '') + '> YouTube (every 45-60s)</option>';
            html += '<option value="tiktok"' + (patternInterrupt === 'tiktok' ? ' selected' : '') + '> TikTok (every 3-5s)</option>';
            html += '<option value="instagram"' + (patternInterrupt === 'instagram' ? ' selected' : '') + '> Instagram (every 15-20s)</option>';
            html += '<option value="cinema"' + (patternInterrupt === 'cinema' ? ' selected' : '') + '> Cinema (story beats)</option>';
            html += '<option value="documentary"' + (patternInterrupt === 'documentary' ? ' selected' : '') + '> Documentary (every 90-120s)</option>';
            html += '<option value="minimal"' + (patternInterrupt === 'minimal' ? ' selected' : '') + '> Minimal (rare)</option>';
            html += '</select>';
            html += '</div>';

            // B-Roll Strategy
            var bRollStrategy = state.assembly.bRollStrategy || '';
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">B-Roll Strategy</label>';
            html += '<select onchange="setBRollStrategy(this.value)" style="width: 100%; padding: 0.5rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem;">';
            html += '<option value="">Auto (from genre)</option>';
            html += '<option value="aggressive"' + (bRollStrategy === 'aggressive' ? ' selected' : '') + '> Aggressive (50-70%)</option>';
            html += '<option value="moderate"' + (bRollStrategy === 'moderate' ? ' selected' : '') + '> Moderate (30-50%)</option>';
            html += '<option value="minimal"' + (bRollStrategy === 'minimal' ? ' selected' : '') + '> Minimal (10-30%)</option>';
            html += '<option value="talking-head"' + (bRollStrategy === 'talking-head' ? ' selected' : '') + '> Talking Head Focus</option>';
            html += '<option value="montage"' + (bRollStrategy === 'montage' ? ' selected' : '') + '> Montage Heavy (70%+)</option>';
            html += '</select>';
            html += '</div>';

            // Smart Assembly Tips
            var tipMessages = {
                'youtube-engaging': 'Hook in first 5s, pattern breaks every 45-60s, visual variety',
                'tiktok-viral': 'Rapid cuts, text overlays, trending transitions, high energy',
                'cinematic-film': 'Motivated cuts, emotional pacing, film language transitions',
                'documentary': 'Evidence-based cuts, archival integration, interview rhythm',
                'music-video': 'Beat-synced cuts, creative transitions, performance focus',
                'commercial-ad': 'Feature highlights, call-to-action timing, brand reveals',
                'educational': 'Concept reinforcement, visual aids timing, retention points',
                'asmr-relaxation': 'Slow dissolves, minimal cuts, ambient flow'
            };
            if (assemblyPreset && tipMessages[assemblyPreset]) {
                html += '<div style="padding: 0.5rem; background: rgba(6,182,212,0.1); border: 1px solid rgba(6,182,212,0.2); border-radius: 0.4rem; margin-top: 0.5rem;">';
                html += '<div style="font-size: 0.65rem; color: #22d3ee;"> ' + tipMessages[assemblyPreset] + '</div>';
                html += '</div>';
            }

            // Get AI Recommendations Button
            html += '<button onclick="getAssemblyRecommendationsForProject()" style="width: 100%; margin-top: 0.75rem; padding: 0.6rem; background: linear-gradient(135deg, rgba(6,182,212,0.2), rgba(139,92,246,0.2)); border: 1px solid rgba(6,182,212,0.4); border-radius: 0.4rem; color: white; font-size: 0.7rem; cursor: pointer; transition: all 0.2s;" onmouseenter="this.style.background=\'linear-gradient(135deg, rgba(6,182,212,0.3), rgba(139,92,246,0.3))\'" onmouseleave="this.style.background=\'linear-gradient(135deg, rgba(6,182,212,0.2), rgba(139,92,246,0.2))\'">';
            html += ' Get AI Assembly Recommendations';
            html += '</button>';

            html += '</div>'; // Close Smart Assembly section

            return html;
        }

        // Set default transition for all scenes
        function setDefaultTransition(type) {
            state.assembly.defaultTransition = type;
            // Apply to all scenes that don't have an override
            const scriptScenes = state.script.scenes || [];
            scriptScenes.forEach(function(scene) {
                if (!state.assembly.transitions[scene.id]) {
                    state.assembly.transitions[scene.id] = { type: type };
                }
            });
            render();
        }

        // COMPACT PREVIEW PANEL
        function renderCompactPreviewPanel() {
            const { isReady, isPlaying, currentTime, totalDuration, currentSceneIndex, loadProgress } = state.preview;
            const scriptScenes = state.script.scenes || [];
            const currentScene = scriptScenes[currentSceneIndex] || {};

            return `
                <div style="background: rgba(15,15,25,0.98); display: flex; flex-direction: column; overflow: hidden; padding: 1rem;">
                    <!-- Preview Canvas Container -->
                    <div style="flex: 1; display: flex; align-items: center; justify-content: center; min-height: 0;">
                        <div style="position: relative; width: 100%; max-width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 0.5rem; overflow: hidden;">
                        <canvas id="preview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>

                        ${!isReady ? `
                            <div style="position: absolute; inset: 0; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem;">
                                ${loadProgress > 0 ? `
                                    <div style="width: 60%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
                                        <div style="width: ${loadProgress}%; height: 100%; background: linear-gradient(135deg, #8b5cf6, #06b6d4); transition: width 0.3s;"></div>
                                    </div>
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Loading ${loadProgress}%</span>
                                ` : `
                                    <button onclick="initializePreviewEngine()" style="padding: 0.75rem 1.5rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; font-size: 0.85rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-size: 1.2rem;"></span> Load Preview
                                    </button>
                                `}
                            </div>
                        ` : `
                            <div id="preview-play-overlay" onclick="togglePreviewPlayback()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; cursor: pointer; background: rgba(0,0,0,0.2); transition: opacity 0.2s; opacity: ${isPlaying ? '0' : '1'}; pointer-events: ${isPlaying ? 'none' : 'auto'};">
                                <div style="width: 50px; height: 50px; background: rgba(139, 92, 246, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(0,0,0,0.4);">
                                    <span style="font-size: 1.2rem; margin-left: 3px;"></span>
                                </div>
                            </div>
                        `}
                        </div>
                    </div>

                    <!-- Playback Controls -->
                    <div style="flex-shrink: 0; padding: 0.75rem 0; margin-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <button onclick="togglePreviewPlayback()" ${!isReady ? 'disabled' : ''} style="width: 36px; height: 36px; border-radius: 50%; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; font-size: 0.9rem;">
                                ${isPlaying ? '' : ''}
                            </button>
                            <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6); font-family: monospace;">
                                ${formatDuration(currentTime)} / ${formatDuration(totalDuration)}
                            </span>
                            <div style="margin-left: auto; display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Scene ${currentSceneIndex + 1}</span>
                                <span style="font-size: 0.75rem;"></span>
                                <input type="range" min="0" max="100" value="${state.preview.volume || 100}" onchange="setPreviewVolume(this.value)" style="width: 60px; height: 4px; cursor: pointer; accent-color: #8b5cf6;">
                            </div>
                        </div>
                        <input type="range" id="preview-scrubber" min="0" max="${totalDuration || 100}" step="0.1" value="${currentTime}" onchange="seekPreview(this.value)" ${!isReady ? 'disabled' : ''} style="width: 100%; height: 6px; cursor: ${isReady ? 'pointer' : 'not-allowed'}; accent-color: #8b5cf6; border-radius: 3px;">
                    </div>
                </div>
            `;
        }

        // Tab switching function
        function setAssemblyTab(tab) {
            state.assembly.activeTab = tab;
            render();
        }

        // New caption control functions
        function setCaptionEnabled(enabled) {
            state.assembly.captions.enabled = enabled;
            updatePreviewCaptions();
            render();
        }

        function setCaptionMode(mode) {
            state.assembly.captions.mode = mode;
            updatePreviewCaptions();
            render();
        }

        function setCaptionFont(font) {
            state.assembly.captions.fontFamily = font;
            updatePreviewCaptions();
            render();
        }

        function setCaptionFillColor(color) {
            state.assembly.captions.fillColor = color;
            updatePreviewCaptions();
            render();
        }

        function setCaptionStrokeColor(color) {
            state.assembly.captions.strokeColor = color;
            updatePreviewCaptions();
            render();
        }

        function setCaptionStrokeWidth(width) {
            state.assembly.captions.strokeWidth = parseFloat(width);
            updatePreviewCaptions();
            render();
        }

        function setCaptionEffect(effect) {
            state.assembly.captions.effect = effect;
            updatePreviewCaptions();
            render();
        }

        function setCaptionHighlightColor(color) {
            state.assembly.captions.highlightColor = color;
            updatePreviewCaptions();
            render();
        }

        function updatePreviewCaptions() {
            if (previewEngine) {
                const captions = state.assembly.captions;
                // Basic settings
                previewEngine.setCaptionStyle(captions.style);
                previewEngine.setCaptionPosition(captions.position);
                previewEngine.setCaptionSize(captions.size);
                previewEngine.setCaptionsEnabled(captions.enabled);
                // Enhanced settings (Phase 2)
                previewEngine.setCaptionMode(captions.mode);
                previewEngine.setCaptionFontFamily(captions.fontFamily);
                previewEngine.setCaptionFillColor(captions.fillColor);
                previewEngine.setCaptionStrokeColor(captions.strokeColor);
                previewEngine.setCaptionStrokeWidth(captions.strokeWidth);
                previewEngine.setCaptionEffect(captions.effect);
                previewEngine.setCaptionHighlightColor(captions.highlightColor);
            }
        }

        function renderPreviewPanel() {
            const { isReady, isPlaying, currentTime, totalDuration, currentSceneIndex, loadProgress } = state.preview;
            const scriptScenes = state.script.scenes || [];
            const currentScene = scriptScenes[currentSceneIndex] || {};

            return `
                <div class="content-card" style="padding: 1rem;">
                    <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Live Preview
                        ${isReady ? '<span style="font-size: 0.65rem; padding: 0.15rem 0.4rem; background: rgba(16, 185, 129, 0.2); color: #10b981; border-radius: 0.25rem; margin-left: auto;">Ready</span>' :
                          loadProgress > 0 ? `<span style="font-size: 0.65rem; padding: 0.15rem 0.4rem; background: rgba(139, 92, 246, 0.2); color: #a78bfa; border-radius: 0.25rem; margin-left: auto;">Loading ${loadProgress}%</span>` :
                          '<span style="font-size: 0.65rem; padding: 0.15rem 0.4rem; background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.5); border-radius: 0.25rem; margin-left: auto;">Click to load</span>'}
                    </div>

                    <!-- Preview Canvas Container -->
                    <div style="position: relative; width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 0.5rem; overflow: hidden; margin-bottom: 0.75rem;">
                        <canvas id="preview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>

                        <!-- Captions are rendered directly on canvas by PreviewEngine -->

                        <!-- Loading Overlay -->
                        ${!isReady ? `
                            <div id="preview-loading-overlay" style="position: absolute; inset: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem;">
                                ${loadProgress > 0 ? `
                                    <div style="width: 60%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
                                        <div style="width: ${loadProgress}%; height: 100%; background: linear-gradient(135deg, #8b5cf6, #06b6d4); transition: width 0.3s;"></div>
                                    </div>
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Loading media...</span>
                                ` : `
                                    <button onclick="initializePreviewEngine()" style="padding: 0.75rem 1.5rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; font-size: 0.85rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-size: 1.2rem;"></span> Load Preview
                                    </button>
                                    <span style="font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">Loads all scenes for preview</span>
                                `}
                            </div>
                        ` : ''}

                        <!-- Play Button Overlay (when paused) - Always rendered, visibility controlled by JS -->
                        ${isReady ? `
                            <div id="preview-play-overlay" onclick="togglePreviewPlayback()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; cursor: pointer; background: rgba(0,0,0,0.3); transition: opacity 0.2s; opacity: ${isPlaying ? '0' : '1'}; pointer-events: ${isPlaying ? 'none' : 'auto'};" onmouseover="if(!state.preview.isPlaying) this.style.background='rgba(0,0,0,0.1)'" onmouseout="if(!state.preview.isPlaying) this.style.background='rgba(0,0,0,0.3)'">
                                <div style="width: 60px; height: 60px; background: rgba(139, 92, 246, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(0,0,0,0.4);">
                                    <span style="font-size: 1.5rem; margin-left: 4px;"></span>
                                </div>
                            </div>
                        ` : ''}
                    </div>

                    <!-- Playback Controls -->
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                        <button id="preview-play-btn" onclick="togglePreviewPlayback()" ${!isReady ? 'disabled' : ''}
                                style="width: 36px; height: 36px; border-radius: 50%; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; font-size: 0.9rem;">
                            ${isPlaying ? '' : ''}
                        </button>

                        <button onclick="stopPreview()" ${!isReady ? 'disabled' : ''}
                                style="width: 28px; height: 28px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; font-size: 0.7rem;">
                            
                        </button>

                        <!-- Time Display -->
                        <span id="preview-time-display" style="font-size: 0.75rem; color: rgba(255,255,255,0.7); font-family: monospace; min-width: 90px;">
                            ${formatDuration(currentTime)} / ${formatDuration(totalDuration)}
                        </span>

                        <!-- Volume Control -->
                        <div style="margin-left: auto; display: flex; align-items: center; gap: 0.3rem;">
                            <span style="font-size: 0.75rem;"></span>
                            <input type="range" min="0" max="100" value="${(state.preview.volume || 100)}"
                                   onchange="setPreviewVolume(this.value)"
                                   style="width: 60px; height: 4px; cursor: pointer;">
                        </div>
                    </div>

                    <!-- Scrubber -->
                    <div style="margin-bottom: 0.75rem;">
                        <input type="range" id="preview-scrubber" min="0" max="${totalDuration || 100}" step="0.1" value="${currentTime}"
                               onchange="seekPreview(this.value)" oninput="updateScrubberPreview(this.value)"
                               ${!isReady ? 'disabled' : ''}
                               style="width: 100%; height: 6px; cursor: ${isReady ? 'pointer' : 'not-allowed'}; background: linear-gradient(to right, #8b5cf6 0%, #8b5cf6 ${(currentTime / (totalDuration || 1)) * 100}%, rgba(255,255,255,0.2) ${(currentTime / (totalDuration || 1)) * 100}%, rgba(255,255,255,0.2) 100%); border-radius: 3px;">
                    </div>

                    <!-- Current Scene Info -->
                    <div style="background: rgba(139, 92, 246, 0.1); border-radius: 0.4rem; padding: 0.5rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem;">Currently Playing</div>
                        <div id="current-scene-info" style="font-size: 0.8rem; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            Scene ${currentSceneIndex + 1}: "${currentScene.narration?.substring(0, 35) || 'No scene loaded'}${currentScene.narration?.length > 35 ? '...' : ''}"
                        </div>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                            <button onclick="prevPreviewScene()" ${!isReady || currentSceneIndex <= 0 ? 'disabled' : ''}
                                    style="flex: 1; padding: 0.3rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady && currentSceneIndex > 0 ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady && currentSceneIndex > 0 ? 'pointer' : 'not-allowed'}; font-size: 0.7rem;">
                                 Prev
                            </button>
                            <button onclick="nextPreviewScene()" ${!isReady || currentSceneIndex >= (scriptScenes.length - 1) ? 'disabled' : ''}
                                    style="flex: 1; padding: 0.3rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady && currentSceneIndex < (scriptScenes.length - 1) ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady && currentSceneIndex < (scriptScenes.length - 1) ? 'pointer' : 'not-allowed'}; font-size: 0.7rem;">
                                Next 
                            </button>
                        </div>
                    </div>

                    <!-- Keyboard Shortcuts Hint -->
                    ${isReady ? `
                        <div style="margin-top: 0.5rem; font-size: 0.65rem; color: rgba(255,255,255,0.4); text-align: center;">
                            <span title="Space: Play/Pause, /: Seek 5s, Shift+/: Prev/Next Scene, M: Mute">
                                 Space: Play/Pause  : Seek  M: Mute
                            </span>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderTimelineSceneCard(scriptScene, animScene, storyboardScene, transition, index, totalScenes) {
            const imageUrl = storyboardScene?.imageUrl;
            const hasVideo = animScene?.videoUrl;
            const hasStockVideo = storyboardScene?.source === 'stock-video' && storyboardScene?.videoUrl;
            const transitionTypes = state.assembly.transitionTypes || [];
            const isCurrentScene = state.preview.isReady && state.preview.currentSceneIndex === index;

            let html = `
                <div class="timeline-scene" data-scene-id="${scriptScene.id}" data-scene-index="${index}"
                     onclick="seekToScene(${scriptScene.id})"
                     style="background: ${isCurrentScene ? 'rgba(139, 92, 246, 0.1)' : 'rgba(255,255,255,0.03)'}; border: 2px solid ${isCurrentScene ? 'rgba(139, 92, 246, 0.8)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; overflow: hidden; cursor: pointer; transition: all 0.2s; ${isCurrentScene ? 'box-shadow: 0 0 20px rgba(139, 92, 246, 0.4);' : ''}"
                     onmouseover="if(!this.dataset.playing) this.style.borderColor='rgba(139, 92, 246, 0.5)'"
                     onmouseout="if(!this.dataset.playing) this.style.borderColor='${isCurrentScene ? 'rgba(139, 92, 246, 0.8)' : 'rgba(255,255,255,0.1)'}'"
                     ${isCurrentScene ? 'data-playing="true"' : ''}>

                    <!-- Scene Progress Bar -->
                    <div class="scene-progress-bar" style="height: 3px; background: rgba(255,255,255,0.1);">
                        <div class="scene-progress-fill" style="height: 100%; width: 0%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); transition: width 0.1s linear;"></div>
                    </div>

                    <div style="display: flex; gap: 0.75rem; padding: 0.75rem;">
                        <!-- Drag Handle & Number -->
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 0.25rem;" onclick="event.stopPropagation()">
                            <div style="cursor: grab; color: rgba(255,255,255,0.3); font-size: 1rem;"></div>
                            <div style="width: 1.5rem; height: 1.5rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 700;">
                                ${index + 1}
                            </div>
                        </div>

                        <!-- Thumbnail -->
                        <div style="width: 80px; height: 50px; border-radius: 0.25rem; overflow: hidden; background: rgba(0,0,0,0.3); flex-shrink: 0;">
                            ${imageUrl ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">` :
                              `<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3); font-size: 0.7rem;">No image</div>`}
                        </div>

                        <!-- Scene Info -->
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: 0.8rem; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 0.25rem;">
                                ${scriptScene.narration?.substring(0, 40) || 'No narration'}...
                            </div>
                            <div style="display: flex; gap: 0.5rem; font-size: 0.7rem; color: rgba(255,255,255,0.5);">
                                <span> ${scriptScene.duration || 8}s</span>
                                ${hasVideo ? '<span style="color: #10b981;"> Video</span>' : '<span style="color: #f59e0b;"> No video</span>'}
                            </div>
                        </div>

                        <!-- Reorder Buttons -->
                        <div style="display: flex; flex-direction: column; gap: 0.25rem;" onclick="event.stopPropagation()">
                            <button onclick="event.stopPropagation(); moveSceneInOrder(${scriptScene.id}, -1)" ${index === 0 ? 'disabled' : ''}
                                    style="padding: 0.25rem 0.4rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: ${index === 0 ? 'rgba(255,255,255,0.2)' : 'white'}; cursor: ${index === 0 ? 'not-allowed' : 'pointer'}; font-size: 0.65rem;">
                                
                            </button>
                            <button onclick="event.stopPropagation(); moveSceneInOrder(${scriptScene.id}, 1)" ${index === totalScenes - 1 ? 'disabled' : ''}
                                    style="padding: 0.25rem 0.4rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: ${index === totalScenes - 1 ? 'rgba(255,255,255,0.2)' : 'white'}; cursor: ${index === totalScenes - 1 ? 'not-allowed' : 'pointer'}; font-size: 0.65rem;">
                                
                            </button>
                        </div>
                    </div>

                    <!-- Transition Selector (between scenes) -->
                    ${index < totalScenes - 1 ? `
                        <div onclick="event.stopPropagation()" style="padding: 0.5rem 0.75rem; background: rgba(139, 92, 246, 0.1); border-top: 1px solid rgba(255,255,255,0.05); display: flex; align-items: center; gap: 0.5rem;">
                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">Transition:</span>
                            <select onchange="setSceneTransition(${scriptScene.id}, this.value)"
                                    style="flex: 1; padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(30,30,50,1); color: white; font-size: 0.7rem;">
                                ${transitionTypes.map(t => `
                                    <option value="${t.id}" ${transition.type === t.id ? 'selected' : ''}>${t.name}</option>
                                `).join('')}
                            </select>
                        </div>
                    ` : ''}
                </div>
            `;
            return html;
        }

        function renderMusicSettings() {
            const musicLibrary = state.assembly.musicLibrary || [];
            const selectedTrackId = state.assembly.music.trackId;
            const musicEnabled = state.assembly.music.enabled;
            const musicVolume = state.assembly.music.volume;

            // Group by category
            const categories = ['upbeat', 'calm', 'dramatic', 'electronic', 'hiphop', 'none'];
            const categoryNames = {
                upbeat: ' Upbeat',
                calm: ' Calm',
                dramatic: ' Dramatic',
                electronic: ' Electronic',
                hiphop: ' Hip Hop',
                none: ' None'
            };

            return `
                <div class="content-card" style="padding: 1rem;">
                    <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Background Music
                        <label style="margin-left: auto; display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" ${musicEnabled ? 'checked' : ''} onchange="toggleMusic(this.checked)"
                                   style="width: 1rem; height: 1rem; cursor: pointer;">
                            <span style="font-size: 0.75rem; font-weight: 400; color: rgba(255,255,255,0.6);">Enable</span>
                        </label>
                    </div>

                    <div style="opacity: ${musicEnabled ? '1' : '0.5'}; pointer-events: ${musicEnabled ? 'auto' : 'none'};">
                        <select id="music-select" onchange="selectMusicTrack(this.value)"
                                style="width: 100%; padding: 0.6rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(30,30,50,1); color: white; font-size: 0.85rem; margin-bottom: 0.75rem;">
                            <option value="">Select a track...</option>
                            ${categories.map(cat => `
                                <optgroup label="${categoryNames[cat] || cat}">
                                    ${musicLibrary.filter(t => t.category === cat).map(track => `
                                        <option value="${track.id}" ${selectedTrackId === track.id ? 'selected' : ''}>
                                            ${track.name} ${track.duration ? `(${Math.floor(track.duration / 60)}:${(track.duration % 60).toString().padStart(2, '0')})` : ''}
                                        </option>
                                    `).join('')}
                                </optgroup>
                            `).join('')}
                        </select>

                        ${selectedTrackId && selectedTrackId !== 'none' ? `
                            <div style="background: rgba(139, 92, 246, 0.1); border-radius: 0.4rem; padding: 0.5rem; margin-bottom: 0.75rem;">
                                <div style="font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                                    ${musicLibrary.find(t => t.id === selectedTrackId)?.mood || ''}
                                </div>
                            </div>
                        ` : ''}

                        <div>
                            <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">
                                Volume: ${musicVolume}%
                            </label>
                            <input type="range" min="0" max="100" value="${musicVolume}"
                                   onchange="setMusicVolume(this.value)"
                                   style="width: 100%; height: 6px; cursor: pointer;">
                        </div>
                    </div>
                </div>
            `;
        }

        // NOTE: Caption rendering is now handled by VideoPreviewEngine._renderCaption()
        // which provides style-aware, word-by-word synchronized captions on the canvas

        function renderCaptionSettings() {
            const selectedStyle = state.assembly.captions.style || 'karaoke';
            const position = state.assembly.captions.position || 'bottom';
            const size = state.assembly.captions.size || 1;

            // Same styles as video-wizard.html for consistency and correct export
            const captionStyles = [
                { id: 'none', name: 'None', preview: '' },
                { id: 'karaoke', name: 'Karaoke', preview: '<span style="color:#fff">The</span> <span style="color:#fbbf24;font-weight:700">biggest</span>' },
                { id: 'beasty', name: 'MrBeast', preview: '<span style="color:#fbbf24;font-weight:900;text-transform:uppercase;font-size:0.8rem">BOLD</span>' },
                { id: 'deepdiver', name: 'Minimal', preview: '<span style="font-weight:400;font-size:0.7rem;opacity:0.8">minimal style</span>' },
                { id: 'podp', name: 'Podcast', preview: '<span style="font-weight:500;letter-spacing:0.3px">Clean Text</span>' },
                { id: 'hormozi', name: 'Hormozi', preview: '<span style="background:linear-gradient(180deg,#22c55e,#16a34a);padding:2px 6px;border-radius:3px;font-weight:600;color:#fff">KEY</span>' },
                { id: 'ali', name: 'Ali', preview: '<span style="text-shadow:0 0 8px rgba(236,72,153,0.8);color:#ec4899">Glow</span>' },
                { id: 'custom', name: 'Custom', preview: '' }
            ];

            return `
                <div class="content-card" style="padding: 1rem;">
                    <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Captions
                        <span style="margin-left: auto; font-size: 0.7rem; color: rgba(255,255,255,0.5); padding: 0.2rem 0.5rem; background: rgba(255,255,255,0.05); border-radius: 0.25rem;">8 Styles</span>
                    </div>

                    <!-- Style Selection Grid - 4 columns like video-wizard -->
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-bottom: 0.75rem;">
                        ${captionStyles.map(style => `
                            <button onclick="setCaptionStyle('${style.id}')"
                                    style="padding: 0.5rem 0.25rem; border-radius: 0.5rem; border: 2px solid ${selectedStyle === style.id ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.1)'}; background: ${selectedStyle === style.id ? 'rgba(139, 92, 246, 0.15)' : 'rgba(255,255,255,0.03)'}; color: white; cursor: pointer; text-align: center; transition: all 0.2s; position: relative;">
                                <div style="height: 24px; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; margin-bottom: 0.25rem;">
                                    ${style.preview}
                                </div>
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.7);">${style.name}</div>
                                ${selectedStyle === style.id ? '<div style="position: absolute; top: 2px; right: 2px; width: 8px; height: 8px; background: #8b5cf6; border-radius: 50%;"></div>' : ''}
                            </button>
                        `).join('')}
                    </div>

                    <!-- Position and Size Controls -->
                    <div style="display: flex; gap: 0.75rem; opacity: ${selectedStyle === 'none' ? '0.4' : '1'}; pointer-events: ${selectedStyle === 'none' ? 'none' : 'auto'};">
                        <!-- Position -->
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Position</label>
                            <select onchange="setCaptionPosition(this.value)"
                                    style="width: 100%; padding: 0.4rem; background: rgba(30,30,30,0.9); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.4rem; color: white; font-size: 0.75rem; cursor: pointer;">
                                <option value="bottom" ${position === 'bottom' ? 'selected' : ''}> Bottom</option>
                                <option value="middle" ${position === 'middle' || position === 'center' ? 'selected' : ''}> Middle</option>
                                <option value="top" ${position === 'top' ? 'selected' : ''}> Top</option>
                            </select>
                        </div>

                        <!-- Size (numeric like video-wizard) -->
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Size</label>
                            <select onchange="setCaptionSize(this.value)"
                                    style="width: 100%; padding: 0.4rem; background: rgba(30,30,30,0.9); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.4rem; color: white; font-size: 0.75rem; cursor: pointer;">
                                <option value="0.7" ${size == 0.7 ? 'selected' : ''}>70%</option>
                                <option value="0.85" ${size == 0.85 ? 'selected' : ''}>85%</option>
                                <option value="1" ${size == 1 ? 'selected' : ''}>100%</option>
                                <option value="1.15" ${size == 1.15 ? 'selected' : ''}>115%</option>
                                <option value="1.3" ${size == 1.3 ? 'selected' : ''}>130%</option>
                                <option value="1.5" ${size == 1.5 ? 'selected' : ''}>150%</option>
                            </select>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAudioMixSettings() {
            const voiceVolume = state.assembly.audioMix?.voiceVolume || 100;
            const musicVolume = state.assembly.audioMix?.musicVolume || 30;

            return `
                <div class="content-card" style="padding: 1rem;">
                    <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Audio Mix
                    </div>

                    <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                        <div>
                            <label style="display: flex; justify-content: space-between; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">
                                <span> Voiceover</span>
                                <span>${voiceVolume}%</span>
                            </label>
                            <input type="range" min="0" max="100" value="${voiceVolume}"
                                   onchange="setVoiceVolume(this.value)"
                                   style="width: 100%; height: 6px; cursor: pointer;">
                        </div>

                        <div>
                            <label style="display: flex; justify-content: space-between; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">
                                <span> Music</span>
                                <span>${musicVolume}%</span>
                            </label>
                            <input type="range" min="0" max="100" value="${musicVolume}"
                                   onchange="setAudioMixMusicVolume(this.value)"
                                   style="width: 100%; height: 6px; cursor: pointer;">
                        </div>
                    </div>
                </div>
            `;
        }

        // Assembly Functions
        function moveSceneInOrder(sceneId, direction) {
            const order = state.assembly.sceneOrder.length > 0
                ? [...state.assembly.sceneOrder]
                : state.script.scenes.map(s => s.id);

            const currentIndex = order.indexOf(sceneId);
            const newIndex = currentIndex + direction;

            if (newIndex >= 0 && newIndex < order.length) {
                [order[currentIndex], order[newIndex]] = [order[newIndex], order[currentIndex]];
                state.assembly.sceneOrder = order;
                saveProject();
                render();
            }
        }

        function setSceneTransition(sceneId, transitionType) {
            state.assembly.transitions[sceneId] = { type: transitionType };
            saveProject();
            // Update preview engine transitions
            updatePreviewTransitions();
        }

        async function toggleMusic(enabled) {
            state.assembly.music.enabled = enabled;
            saveProject();
            // Update preview music - AWAIT to prevent race condition with render()
            await updatePreviewMusic();
            render();
        }

        async function selectMusicTrack(trackId) {
            state.assembly.music.trackId = trackId;
            if (trackId && trackId !== 'none') {
                state.assembly.music.enabled = true;
            }
            saveProject();
            // Update preview music - AWAIT to prevent race condition with render()
            await updatePreviewMusic();
            render();
        }

        function setMusicVolume(volume) {
            state.assembly.music.volume = parseInt(volume);
            saveProject();
            // Update preview music volume
            if (previewEngine && previewEngine.musicElement) {
                previewEngine.musicElement.volume = volume / 100;
                previewEngine.musicVolume = volume / 100;
            }
        }

        function toggleCaptions(enabled) {
            state.assembly.captions.enabled = enabled;
            saveProject();
            // Update preview captions
            if (previewEngine) {
                previewEngine.captionsEnabled = enabled;
            }
            render();
        }

        function setCaptionStyle(style) {
            state.assembly.captions.style = style;
            saveProject();
            // Update preview caption style
            if (previewEngine) {
                previewEngine.captionStyle = style;
            }
            render();
        }

        function setCaptionPosition(position) {
            state.assembly.captions.position = position;
            saveProject();
            // Update preview caption position
            if (previewEngine) {
                previewEngine.captionPosition = position;
            }
            render();
        }

        function setCaptionSize(size) {
            state.assembly.captions.size = parseFloat(size);
            saveProject();
            // Update preview caption size
            if (previewEngine) {
                previewEngine.captionSize = parseFloat(size);
            }
            render();
        }

        function setVoiceVolume(volume) {
            if (!state.assembly.audioMix) state.assembly.audioMix = {};
            state.assembly.audioMix.voiceVolume = parseInt(volume);
            saveProject();
            // Update preview voice volume
            if (previewEngine) {
                previewEngine.voiceVolume = volume / 100;
            }
            render();
        }

        function setAudioMixMusicVolume(volume) {
            if (!state.assembly.audioMix) state.assembly.audioMix = {};
            state.assembly.audioMix.musicVolume = parseInt(volume);
            saveProject();
            // Update preview music volume
            if (previewEngine) {
                previewEngine.musicVolume = volume / 100;
            }
            render();
        }

        function setMusicFadeIn(seconds) {
            state.assembly.music.fadeIn = parseFloat(seconds);
            scheduleAutoSave();
            render();
        }

        function setMusicFadeOut(seconds) {
            state.assembly.music.fadeOut = parseFloat(seconds);
            scheduleAutoSave();
            render();
        }

        function setAudioDucking(enabled) {
            if (!state.assembly.audioMix) state.assembly.audioMix = {};
            state.assembly.audioMix.ducking = enabled;
            if (previewEngine) {
                previewEngine.audioDucking = enabled;
            }
            scheduleAutoSave();
            render();
        }

        // ==========================================
        // SMART AUDIO - AI Analysis & Recommendations
        // ==========================================

        async function analyzeContentForAudio() {
            // Gather content information
            const genre = state.content.genre || state.content.niche || 'general';
            const pacing = state.content.pacing || state.assembly.pacingProfile || 'balanced';
            const mood = state.assembly.audioMood || state.content.mood || '';
            const style = state.content.style || '';
            const scenes = state.script.scenes || [];
            const narrativeArc = state.content.narrativePreset || state.content.storyArc || '';
            const emotionalJourney = state.content.emotionalJourney || '';
            const platform = state.platform.selected || 'youtube';

            // Calculate total duration
            let totalDuration = 0;
            scenes.forEach(scene => {
                totalDuration += scene.duration || 8;
            });

            state.assembly.audioAnalyzing = true;
            render();

            try {
                const analyzeAudio = firebase.functions().httpsCallable('analyzeContentForAudio');
                const result = await analyzeAudio({
                    genre: genre,
                    mood: mood,
                    pacing: pacing,
                    scenes: scenes.map(s => ({ id: s.id, visual: s.visual, narration: s.narration })),
                    totalDuration: totalDuration,
                    narrativeArc: narrativeArc,
                    emotionalJourney: emotionalJourney,
                    platform: platform,
                    style: style
                });

                if (result.data.success) {
                    state.assembly.audioProfile = result.data.audioProfile;
                    showToast('Audio analysis complete! Review recommendations.', 'success');
                } else {
                    throw new Error('Analysis failed');
                }
            } catch (error) {
                console.error('[analyzeContentForAudio] Error:', error);
                showToast('Failed to analyze audio. Please try again.', 'error');
            } finally {
                state.assembly.audioAnalyzing = false;
                render();
            }
        }

        async function applySmartAudioRecommendations() {
            const audioProfile = state.assembly.audioProfile;
            if (!audioProfile) {
                showToast('No audio recommendations available. Analyze content first.', 'error');
                return;
            }

            // Apply music recommendation
            if (audioProfile.music && audioProfile.music.topPick) {
                const topPick = audioProfile.music.topPick;
                state.assembly.music.enabled = true;
                state.assembly.music.trackId = topPick.id;

                // Apply fade settings from profile
                if (audioProfile.music.fadeIn) {
                    state.assembly.music.fadeIn = audioProfile.music.fadeIn / 1000; // Convert ms to seconds
                }
                if (audioProfile.music.fadeOut) {
                    state.assembly.music.fadeOut = audioProfile.music.fadeOut / 1000;
                }
            }

            // Apply mix settings
            if (audioProfile.mix) {
                state.assembly.audioMix = state.assembly.audioMix || {};
                state.assembly.audioMix.voiceVolume = audioProfile.mix.voiceVolume;
                state.assembly.music.volume = audioProfile.mix.musicVolume;

                // Apply auto-duck settings
                if (audioProfile.mix.autoDuck !== undefined) {
                    state.assembly.audioMix.ducking = audioProfile.mix.autoDuck;
                }
            }

            // Apply SFX style
            if (audioProfile.sfx && audioProfile.sfx.style) {
                // Map SFX style to transition sound
                const sfxStyleMap = {
                    'subtle': 'whoosh-soft',
                    'cinematic': 'whoosh-heavy',
                    'tech': 'glitch',
                    'horror': 'whoosh-dark',
                    'powerful': 'sub-drop',
                    'playful': 'swoosh-magical',
                    'action': 'whoosh-fast',
                    'clean': 'whoosh-medium',
                    'minimal': null,
                    'comedic': 'boing'
                };
                state.assembly.transitionSound = sfxStyleMap[audioProfile.sfx.style] || 'whoosh-soft';
            }

            // Apply ambience
            if (audioProfile.ambience && audioProfile.ambience.primaryAmbience) {
                state.assembly.ambienceLayer = audioProfile.ambience.primaryAmbience;
            }

            // Apply audio mood
            if (audioProfile.genre) {
                // Map genre to audio mood
                const genreMoodMap = {
                    'horror': 'dark',
                    'thriller': 'tense',
                    'documentary': 'contemplative',
                    'educational': 'professional',
                    'tech': 'energetic',
                    'corporate': 'professional',
                    'motivational': 'epic',
                    'lifestyle': 'intimate',
                    'cinematic': 'epic',
                    'comedy': 'energetic',
                    'gaming': 'energetic',
                    'romance': 'intimate',
                    'action': 'energetic',
                    'news': 'professional'
                };
                const suggestedMood = genreMoodMap[audioProfile.genre];
                if (suggestedMood && !state.assembly.audioMood) {
                    state.assembly.audioMood = suggestedMood;
                }
            }

            scheduleAutoSave();

            // CRITICAL: Update preview music BEFORE render to avoid race condition
            await updatePreviewMusic();

            render();
            showToast('Smart Audio recommendations applied!', 'success');
        }

        // ==========================================
        // MUSIC BROWSER - Phase 3
        // ==========================================

        async function openMusicBrowser() {
            state.assembly.musicBrowser.isOpen = true;
            state.assembly.musicBrowser.loading = true;
            state.assembly.musicBrowser.activeSource = 'pixabay'; // 'pixabay' | 'freesound'
            render();

            try {
                // Load Pixabay tracks (with real URLs) and categories
                const [categoriesResult, pixabayResult] = await Promise.all([
                    firebase.functions().httpsCallable('getMusicCategories')({}),
                    firebase.functions().httpsCallable('searchPixabayMusic')({
                        filters: { page: 1, perPage: 20 }
                    })
                ]);

                if (categoriesResult.data.success) {
                    state.assembly.musicBrowser.categories = categoriesResult.data.categories;
                }

                if (pixabayResult.data.success) {
                    state.assembly.musicBrowser.results = pixabayResult.data.results;
                    state.assembly.musicBrowser.total = pixabayResult.data.total;
                }
            } catch (error) {
                console.error('[openMusicBrowser] Error:', error);
                showToast('Failed to load music library', 'error');
            } finally {
                state.assembly.musicBrowser.loading = false;
                render();
            }
        }

        // Audio preview player for music browser
        let audioPreviewPlayer = null;
        let currentPreviewTrackId = null;

        function previewMusicTrack(trackId, previewUrl, event) {
            event.stopPropagation();

            // If same track is playing, stop it
            if (currentPreviewTrackId === trackId && audioPreviewPlayer && !audioPreviewPlayer.paused) {
                audioPreviewPlayer.pause();
                currentPreviewTrackId = null;
                render();
                return;
            }

            // Stop any existing preview
            if (audioPreviewPlayer) {
                audioPreviewPlayer.pause();
                audioPreviewPlayer = null;
            }

            // Play new preview
            audioPreviewPlayer = new Audio(previewUrl);
            audioPreviewPlayer.volume = 0.5;
            currentPreviewTrackId = trackId;

            audioPreviewPlayer.play().catch(err => {
                console.error('Preview playback failed:', err);
                showToast('Unable to preview audio', 'error');
            });

            audioPreviewPlayer.onended = () => {
                currentPreviewTrackId = null;
                render();
            };

            render();
        }

        function stopMusicPreview() {
            if (audioPreviewPlayer) {
                audioPreviewPlayer.pause();
                audioPreviewPlayer = null;
            }
            currentPreviewTrackId = null;
        }

        function closeMusicBrowser() {
            stopMusicPreview(); // Stop any playing preview
            state.assembly.musicBrowser.isOpen = false;
            render();
        }

        async function searchMusicLibrary(query) {
            state.assembly.musicBrowser.searchQuery = query;
            state.assembly.musicBrowser.loading = true;
            state.assembly.musicBrowser.page = 1;
            stopMusicPreview();
            render();

            try {
                // Use Pixabay for tracks with real URLs
                const searchMusic = firebase.functions().httpsCallable('searchPixabayMusic');
                const result = await searchMusic({
                    query: query,
                    filters: {
                        category: state.assembly.musicBrowser.selectedCategory,
                        page: 1,
                        perPage: 20
                    }
                });

                if (result.data.success) {
                    state.assembly.musicBrowser.results = result.data.results;
                    state.assembly.musicBrowser.total = result.data.total;
                }
            } catch (error) {
                console.error('[searchMusicLibrary] Error:', error);
            } finally {
                state.assembly.musicBrowser.loading = false;
                render();
            }
        }

        async function filterMusicByCategory(category) {
            state.assembly.musicBrowser.selectedCategory = category;
            state.assembly.musicBrowser.loading = true;
            state.assembly.musicBrowser.page = 1;
            stopMusicPreview();
            render();

            try {
                const searchMusic = firebase.functions().httpsCallable('searchPixabayMusic');
                const result = await searchMusic({
                    query: state.assembly.musicBrowser.searchQuery,
                    filters: {
                        category: category,
                        page: 1,
                        perPage: 20
                    }
                });

                if (result.data.success) {
                    state.assembly.musicBrowser.results = result.data.results;
                    state.assembly.musicBrowser.total = result.data.total;
                }
            } catch (error) {
                console.error('[filterMusicByCategory] Error:', error);
            } finally {
                state.assembly.musicBrowser.loading = false;
                render();
            }
        }

        async function searchFreesoundAudio(query, type = 'all') {
            state.assembly.musicBrowser.loading = true;
            stopMusicPreview();
            render();

            try {
                const searchFn = firebase.functions().httpsCallable('searchFreesoundAudio');
                const result = await searchFn({
                    query: query,
                    filters: {
                        type: type,
                        page: 1,
                        perPage: 20
                    }
                });

                if (result.data.success) {
                    state.assembly.musicBrowser.results = result.data.results;
                    state.assembly.musicBrowser.total = result.data.total;
                }
            } catch (error) {
                console.error('[searchFreesoundAudio] Error:', error);
            } finally {
                state.assembly.musicBrowser.loading = false;
                render();
            }
        }

        async function switchAudioSource(source) {
            state.assembly.musicBrowser.activeSource = source;
            state.assembly.musicBrowser.loading = true;
            state.assembly.musicBrowser.searchQuery = '';
            state.assembly.musicBrowser.selectedCategory = null;
            stopMusicPreview();
            render();

            try {
                if (source === 'pixabay') {
                    // Load Pixabay music tracks
                    const result = await firebase.functions().httpsCallable('searchPixabayMusic')({
                        filters: { page: 1, perPage: 20 }
                    });
                    if (result.data.success) {
                        state.assembly.musicBrowser.results = result.data.results;
                        state.assembly.musicBrowser.total = result.data.total;
                    }
                } else if (source === 'freesound') {
                    // Load Freesound sound effects
                    const result = await firebase.functions().httpsCallable('searchFreesoundAudio')({
                        query: 'sound effect transition',
                        filters: { type: 'sfx', page: 1, perPage: 20 }
                    });
                    if (result.data.success) {
                        state.assembly.musicBrowser.results = result.data.results;
                        state.assembly.musicBrowser.total = result.data.total;
                    }
                } else if (source === 'ambience') {
                    // Load ambience tracks from Freesound
                    const result = await firebase.functions().httpsCallable('searchFreesoundAudio')({
                        query: 'ambient background atmosphere',
                        filters: { type: 'ambience', page: 1, perPage: 20 }
                    });
                    if (result.data.success) {
                        state.assembly.musicBrowser.results = result.data.results;
                        state.assembly.musicBrowser.total = result.data.total;
                    }
                }
            } catch (error) {
                console.error('[switchAudioSource] Error:', error);
                showToast('Failed to load audio library', 'error');
            } finally {
                state.assembly.musicBrowser.loading = false;
                render();
            }
        }

        function selectMusicFromBrowser(trackId) {
            // Find the track in the results
            const track = state.assembly.musicBrowser.results.find(t => t.id === trackId);
            if (track) {
                stopMusicPreview();

                // Ensure track has a playable URL
                const trackWithUrl = {
                    ...track,
                    url: track.previewUrl || track.url // Use previewUrl if available
                };

                // Add to music library if not already present
                const existingIndex = state.assembly.musicLibrary.findIndex(t => t.id === trackId);
                if (existingIndex >= 0) {
                    state.assembly.musicLibrary[existingIndex] = trackWithUrl;
                } else {
                    state.assembly.musicLibrary.push(trackWithUrl);
                }

                // Select the track
                state.assembly.music.trackId = trackId;
                state.assembly.music.enabled = true;

                closeMusicBrowser();
                scheduleAutoSave();
                updatePreviewMusic(); // Update the preview engine with new music
                showToast(`Selected: ${track.name}`, 'success');
            }
        }

        function formatTrackDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return mins + ':' + (secs < 10 ? '0' : '') + secs;
        }

        function renderMusicBrowserModal() {
            const browser = state.assembly.musicBrowser;
            if (!browser.isOpen) return '';

            let html = '';
            html += '<div onclick="closeMusicBrowser()" style="position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 1001; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(8px);">';
            html += '<div onclick="event.stopPropagation()" style="background: linear-gradient(135deg, #1a1a2e, #16213e); border: 1px solid rgba(139,92,246,0.3); border-radius: 1rem; width: 90%; max-width: 800px; max-height: 85vh; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 25px 50px rgba(0,0,0,0.5);">';

            // Header
            html += '<div style="padding: 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: space-between;">';
            html += '<div style="display: flex; align-items: center; gap: 0.75rem;">';
            html += '<span style="font-size: 1.5rem;"></span>';
            html += '<div>';
            html += '<div style="font-size: 1.1rem; font-weight: 700; color: white;">Audio Library</div>';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">' + browser.total + ' royalty-free tracks</div>';
            html += '</div>';
            html += '</div>';
            html += '<button onclick="closeMusicBrowser()" style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 1rem;"></button>';
            html += '</div>';

            // Source Tabs
            const activeSource = browser.activeSource || 'pixabay';
            html += '<div style="display: flex; border-bottom: 1px solid rgba(255,255,255,0.1);">';

            // Pixabay Tab (Music)
            html += '<button onclick="switchAudioSource(\'pixabay\')" style="flex: 1; padding: 0.75rem; background: ' + (activeSource === 'pixabay' ? 'rgba(0,171,108,0.15)' : 'transparent') + '; border: none; border-bottom: 2px solid ' + (activeSource === 'pixabay' ? '#00ab6c' : 'transparent') + '; color: ' + (activeSource === 'pixabay' ? '#00ab6c' : 'rgba(255,255,255,0.6)') + '; font-size: 0.8rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.4rem; transition: all 0.2s;">';
            html += ' Background Music';
            html += '</button>';

            // Freesound Tab (SFX)
            html += '<button onclick="switchAudioSource(\'freesound\')" style="flex: 1; padding: 0.75rem; background: ' + (activeSource === 'freesound' ? 'rgba(255,107,53,0.15)' : 'transparent') + '; border: none; border-bottom: 2px solid ' + (activeSource === 'freesound' ? '#ff6b35' : 'transparent') + '; color: ' + (activeSource === 'freesound' ? '#ff6b35' : 'rgba(255,255,255,0.6)') + '; font-size: 0.8rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.4rem; transition: all 0.2s;">';
            html += ' Sound Effects';
            html += '</button>';

            // Ambience Tab
            html += '<button onclick="switchAudioSource(\'ambience\')" style="flex: 1; padding: 0.75rem; background: ' + (activeSource === 'ambience' ? 'rgba(139,92,246,0.15)' : 'transparent') + '; border: none; border-bottom: 2px solid ' + (activeSource === 'ambience' ? '#8b5cf6' : 'transparent') + '; color: ' + (activeSource === 'ambience' ? '#8b5cf6' : 'rgba(255,255,255,0.6)') + '; font-size: 0.8rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.4rem; transition: all 0.2s;">';
            html += ' Ambience';
            html += '</button>';

            html += '</div>';

            // Search & Filters
            html += '<div style="padding: 1rem; border-bottom: 1px solid rgba(255,255,255,0.1);">';

            // Search input
            html += '<div style="margin-bottom: 0.75rem;">';
            html += '<input type="text" placeholder="Search music..." value="' + (browser.searchQuery || '') + '" onchange="searchMusicLibrary(this.value)" style="width: 100%; padding: 0.75rem 1rem; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.85rem;" oninput="this.setAttribute(\'value\', this.value)">';
            html += '</div>';

            // Category chips
            html += '<div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">';
            html += '<button onclick="filterMusicByCategory(null)" style="padding: 0.4rem 0.75rem; border-radius: 2rem; border: 1px solid ' + (!browser.selectedCategory ? '#8b5cf6' : 'rgba(255,255,255,0.2)') + '; background: ' + (!browser.selectedCategory ? 'rgba(139,92,246,0.2)' : 'transparent') + '; color: ' + (!browser.selectedCategory ? '#a78bfa' : 'rgba(255,255,255,0.6)') + '; font-size: 0.7rem; cursor: pointer;">All</button>';

            (browser.categories || []).forEach(function(cat) {
                const isSelected = browser.selectedCategory === cat.id;
                html += '<button onclick="filterMusicByCategory(\'' + cat.id + '\')" style="padding: 0.4rem 0.75rem; border-radius: 2rem; border: 1px solid ' + (isSelected ? '#8b5cf6' : 'rgba(255,255,255,0.2)') + '; background: ' + (isSelected ? 'rgba(139,92,246,0.2)' : 'transparent') + '; color: ' + (isSelected ? '#a78bfa' : 'rgba(255,255,255,0.6)') + '; font-size: 0.7rem; cursor: pointer;">';
                html += cat.icon + ' ' + cat.name + ' (' + cat.count + ')';
                html += '</button>';
            });
            html += '</div>';
            html += '</div>';

            // Results
            html += '<div style="flex: 1; overflow-y: auto; padding: 1rem;">';

            if (browser.loading) {
                html += '<div style="display: flex; align-items: center; justify-content: center; padding: 3rem; gap: 0.75rem;">';
                html += '<div class="animate-spin" style="width: 24px; height: 24px; border: 2px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%;"></div>';
                html += '<span style="color: rgba(255,255,255,0.6);">Loading music...</span>';
                html += '</div>';
            } else if (browser.results.length === 0) {
                html += '<div style="text-align: center; padding: 3rem; color: rgba(255,255,255,0.5);">';
                html += '<div style="font-size: 2rem; margin-bottom: 0.5rem;"></div>';
                html += '<div>No tracks found. Try a different search.</div>';
                html += '</div>';
            } else {
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 1rem;">';

                browser.results.forEach(function(track) {
                    const isSelected = state.assembly.music.trackId === track.id;
                    const isPlaying = currentPreviewTrackId === track.id;
                    const hasPreview = track.previewUrl || track.url;

                    html += '<div onclick="selectMusicFromBrowser(\'' + track.id + '\')" style="background: ' + (isSelected ? 'rgba(139,92,246,0.2)' : 'rgba(255,255,255,0.03)') + '; border: 1px solid ' + (isSelected ? '#8b5cf6' : 'rgba(255,255,255,0.1)') + '; border-radius: 0.75rem; padding: 1rem; cursor: pointer; transition: all 0.2s;" onmouseenter="this.style.borderColor=\'rgba(139,92,246,0.5)\'" onmouseleave="this.style.borderColor=\'' + (isSelected ? '#8b5cf6' : 'rgba(255,255,255,0.1)') + '\'">';

                    // Track icon & name with play preview button
                    html += '<div style="display: flex; align-items: flex-start; gap: 0.75rem; margin-bottom: 0.75rem;">';

                    // Play/Preview button
                    if (hasPreview) {
                        const previewUrl = track.previewUrl || track.url;
                        html += '<button onclick="previewMusicTrack(\'' + track.id + '\', \'' + previewUrl.replace(/'/g, "\\'") + '\', event)" style="width: 40px; height: 40px; background: linear-gradient(135deg, ' + (isPlaying ? '#10b981, #059669' : '#8b5cf6, #6366f1') + '); border-radius: 0.5rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; border: none; cursor: pointer; transition: all 0.2s;" title="' + (isPlaying ? 'Stop preview' : 'Preview track') + '">';
                        html += '<span style="font-size: 1.1rem; color: white;">' + (isPlaying ? '' : '') + '</span>';
                        html += '</button>';
                    } else {
                        html += '<div style="width: 40px; height: 40px; background: linear-gradient(135deg, #6b7280, #4b5563); border-radius: 0.5rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">';
                        html += '<span style="font-size: 1.1rem;"></span>';
                        html += '</div>';
                    }

                    html += '<div style="flex: 1; min-width: 0;">';
                    html += '<div style="font-size: 0.85rem; font-weight: 600; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + track.name + '</div>';
                    html += '<div style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">' + (track.artist || track.mood || track.category || '') + '</div>';
                    html += '</div>';
                    if (isSelected) {
                        html += '<span style="color: #10b981; font-size: 1rem;"></span>';
                    }
                    html += '</div>';

                    // Track metadata with source badge
                    html += '<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">';
                    if (track.source) {
                        const sourceColors = {
                            'pixabay': '#00ab6c',
                            'freesound': '#ff6b35',
                            'curated': '#8b5cf6'
                        };
                        html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.4rem; background: ' + (sourceColors[track.source] || '#6b7280') + '; color: white; border-radius: 0.25rem; font-weight: 600;">' + track.source.toUpperCase() + '</span>';
                    }
                    if (track.duration) {
                        html += '<span style="font-size: 0.6rem; padding: 0.2rem 0.4rem; background: rgba(255,255,255,0.1); border-radius: 0.25rem; color: rgba(255,255,255,0.6);"> ' + formatTrackDuration(track.duration) + '</span>';
                    }
                    if (track.bpm) {
                        html += '<span style="font-size: 0.6rem; padding: 0.2rem 0.4rem; background: rgba(255,255,255,0.1); border-radius: 0.25rem; color: rgba(255,255,255,0.6);"> ' + track.bpm + ' BPM</span>';
                    }
                    if (track.energy) {
                        const energyPercent = Math.round(track.energy * 100);
                        html += '<span style="font-size: 0.6rem; padding: 0.2rem 0.4rem; background: rgba(255,255,255,0.1); border-radius: 0.25rem; color: rgba(255,255,255,0.6);"> ' + energyPercent + '%</span>';
                    }
                    html += '</div>';

                    // Tags
                    if (track.tags && track.tags.length > 0) {
                        html += '<div style="margin-top: 0.5rem; display: flex; gap: 0.25rem; flex-wrap: wrap;">';
                        track.tags.slice(0, 3).forEach(function(tag) {
                            html += '<span style="font-size: 0.55rem; padding: 0.15rem 0.35rem; background: rgba(139,92,246,0.15); color: #a78bfa; border-radius: 0.2rem;">' + tag + '</span>';
                        });
                        html += '</div>';
                    }

                    html += '</div>';
                });

                html += '</div>';
            }

            html += '</div>';

            // Footer
            html += '<div style="padding: 1rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);"> Preview  Click to select  All tracks are royalty-free</div>';
            html += '<button onclick="closeMusicBrowser()" style="padding: 0.5rem 1rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: rgba(255,255,255,0.7); font-size: 0.75rem; cursor: pointer;">Close</button>';
            html += '</div>';

            html += '</div>';
            html += '</div>';

            return html;
        }

        // Phase 3D: Audio Intelligence Functions
        function setAudioMood(mood) {
            state.assembly.audioMood = mood || null;

            // Show mood-specific feedback
            const moodNames = {
                'epic': 'Epic - Orchestral swells & wide dynamics',
                'intimate': 'Intimate - Soft piano & gentle pads',
                'mysterious': 'Mysterious - Dark drones & tension',
                'energetic': 'Energetic - Driving drums & momentum',
                'contemplative': 'Contemplative - Ambient & reflective',
                'tense': 'Tense - Building pressure & suspense',
                'hopeful': 'Hopeful - Uplifting & inspiring',
                'professional': 'Professional - Clean & polished',
                'nostalgic': 'Nostalgic - Warm vintage tones',
                'dark': 'Dark - Ominous & heavy'
            };

            if (mood) {
                showToast(`Audio mood: ${moodNames[mood] || mood}`, 'success');
            } else {
                showToast('Audio mood: Auto (from genre)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        function setVoiceProfile(profile) {
            state.assembly.voiceProfile = profile || null;

            const profileNames = {
                'narrator-warm': 'Warm Narrator',
                'narrator-authoritative': 'Authoritative',
                'narrator-intimate': 'Intimate',
                'narrator-energetic': 'Energetic',
                'documentary': 'Documentary',
                'cinematic-trailer': 'Cinematic Trailer',
                'podcast': 'Podcast'
            };

            if (profile) {
                showToast(`Voice style: ${profileNames[profile] || profile}`, 'success');
            } else {
                showToast('Voice style: Auto (from genre)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        function setTransitionSound(sound) {
            state.assembly.transitionSound = sound || null;

            if (sound) {
                const soundNames = {
                    'whoosh-soft': 'Soft Whoosh',
                    'whoosh-medium': 'Medium Whoosh',
                    'whoosh-hard': 'Hard Whoosh',
                    'swoosh-magical': 'Magical Swoosh',
                    'glitch': 'Glitch',
                    'tape-stop': 'Tape Stop',
                    'sub-drop': 'Sub Drop'
                };
                showToast(`Transition sound: ${soundNames[sound] || sound}`, 'success');
            } else {
                showToast('Transition sounds disabled', 'info');
            }

            scheduleAutoSave();
            render();
        }

        function setAmbienceLayer(ambience) {
            state.assembly.ambienceLayer = ambience || null;

            if (ambience) {
                const ambienceNames = {
                    'nature-forest': 'Forest ambience',
                    'nature-ocean': 'Ocean waves',
                    'nature-rain': 'Rain sounds',
                    'nature-night': 'Night atmosphere',
                    'urban-city': 'City sounds',
                    'urban-cafe': 'Caf ambience',
                    'urban-office': 'Office atmosphere',
                    'space-scifi': 'Space/Sci-Fi atmosphere'
                };
                showToast(`Ambience: ${ambienceNames[ambience] || ambience}`, 'success');
            } else {
                showToast('Ambience layer disabled', 'info');
            }

            scheduleAutoSave();
            render();
        }

        // ==========================================
        // PHASE 5: BEAT SYNCHRONIZATION FUNCTIONS
        // ==========================================

        function setBeatSyncMode(mode) {
            if (!state.assembly.beatSync) {
                state.assembly.beatSync = { syncMode: 'balanced', analyzing: false };
            }
            state.assembly.beatSync.syncMode = mode;

            // Clear previous suggestions when mode changes
            state.assembly.beatSync.suggestions = null;
            state.assembly.beatSync.summary = null;

            showToast(`Beat sync mode: ${mode}`, 'info');
            scheduleAutoSave();
            render();
        }

        async function analyzeBeatSync() {
            const selectedTrack = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music.trackId);
            const scenes = state.script.scenes || [];

            if (!selectedTrack || scenes.length === 0) {
                showToast('Select music and ensure scenes exist', 'error');
                return;
            }

            if (!state.assembly.beatSync) {
                state.assembly.beatSync = { syncMode: 'balanced', analyzing: false };
            }

            state.assembly.beatSync.analyzing = true;
            render();

            try {
                const bpm = selectedTrack.bpm || 120;
                const duration = selectedTrack.duration || 180;
                const syncMode = state.assembly.beatSync.syncMode || 'balanced';

                // Step 1: Generate beat map
                const generateBeatMap = functions.httpsCallable('generateBeatMap');
                const beatMapResult = await generateBeatMap({
                    trackId: selectedTrack.id,
                    bpm: bpm,
                    duration: duration,
                    timeSignature: '4/4',
                    musicStyle: state.content.genre || 'corporate'
                });

                if (!beatMapResult.data.success) {
                    throw new Error('Failed to generate beat map');
                }

                const beatMap = beatMapResult.data.beatMap;
                state.assembly.beatSync.beatMap = beatMap;

                // Step 2: Get cut suggestions
                const suggestCuts = functions.httpsCallable('suggestBeatSyncCuts');
                const suggestResult = await suggestCuts({
                    scenes: scenes.map(s => ({ id: s.id, duration: s.duration || 5 })),
                    beatMap: beatMap,
                    syncMode: syncMode,
                    preserveMinDuration: 3000,
                    preserveMaxAdjustment: 2000
                });

                if (!suggestResult.data.success) {
                    throw new Error('Failed to generate sync suggestions');
                }

                state.assembly.beatSync.suggestions = suggestResult.data.suggestions;
                state.assembly.beatSync.summary = suggestResult.data.summary;

                const score = suggestResult.data.summary.overallScore;
                if (score >= 80) {
                    showToast(`Excellent alignment! ${score}% score`, 'success');
                } else if (score >= 60) {
                    showToast(`Good alignment: ${score}% score`, 'success');
                } else {
                    showToast(`Alignment analyzed: ${score}% score`, 'info');
                }

            } catch (error) {
                console.error('Beat sync analysis failed:', error);
                showToast('Beat sync analysis failed', 'error');
            } finally {
                state.assembly.beatSync.analyzing = false;
                render();
            }
        }

        async function applyBeatSyncSuggestions() {
            const beatSync = state.assembly.beatSync;

            if (!beatSync || !beatSync.suggestions || beatSync.suggestions.length === 0) {
                showToast('No beat sync suggestions to apply', 'error');
                return;
            }

            try {
                // Apply suggestions locally to scene durations
                const scenes = state.script.scenes || [];
                let appliedCount = 0;

                beatSync.suggestions.forEach(suggestion => {
                    if (suggestion.quality === 'keep') return;

                    const scene = scenes.find(s => s.id === suggestion.sceneId);
                    if (scene) {
                        // Store original duration before modifying
                        scene.originalDuration = scene.duration;
                        // Apply new duration (convert from ms to seconds)
                        scene.duration = Math.round(suggestion.suggestedDuration / 100) / 10;
                        scene.beatSynced = true;
                        scene.syncQuality = suggestion.quality;
                        appliedCount++;
                    }
                });

                // Mark as applied
                state.assembly.beatSync.applied = true;

                // If project is saved, persist to backend
                if (state.project.id) {
                    try {
                        const applySync = functions.httpsCallable('applyBeatSync');
                        await applySync({
                            projectId: state.project.id,
                            suggestions: beatSync.suggestions,
                            applyAll: true
                        });
                    } catch (backendError) {
                        console.warn('Backend sync apply failed, but local changes applied:', backendError);
                    }
                }

                showToast(`Applied beat sync to ${appliedCount} scenes`, 'success');

                // Update preview engine if running
                if (previewEngine) {
                    previewEngine.scenes = scenes.map((scene, i) => ({
                        ...previewEngine.scenes[i],
                        duration: scene.duration
                    }));
                    previewEngine.calculateTotalDuration();
                }

                scheduleAutoSave();
                render();

            } catch (error) {
                console.error('Apply beat sync failed:', error);
                showToast('Failed to apply beat sync', 'error');
            }
        }

        function resetBeatSync() {
            const scenes = state.script.scenes || [];

            // Restore original durations
            scenes.forEach(scene => {
                if (scene.beatSynced && scene.originalDuration) {
                    scene.duration = scene.originalDuration;
                    delete scene.beatSynced;
                    delete scene.originalDuration;
                    delete scene.syncQuality;
                }
            });

            // Reset beat sync state
            state.assembly.beatSync = {
                syncMode: state.assembly.beatSync?.syncMode || 'balanced',
                analyzing: false,
                beatMap: null,
                suggestions: null,
                summary: null,
                applied: false
            };

            showToast('Beat sync reset to original durations', 'info');
            scheduleAutoSave();
            render();
        }

        async function getAudioRecommendationsForProject() {
            try {
                const getRecommendations = functions.httpsCallable('creationWizardGetAudioRecommendations');
                const result = await getRecommendations({
                    genre: state.content.genre,
                    mood: state.assembly.audioMood || state.storyboard.visualStyle?.mood,
                    productionMode: state.content.productionMode,
                    sceneEnergy: 'medium',
                    hasVoiceover: true
                });

                if (result.data.success) {
                    return result.data.recommendations;
                }
            } catch (error) {
                console.error('Failed to get audio recommendations:', error);
            }
            return null;
        }

        // Phase 3E: Smart Assembly Intelligence Functions
        function setAssemblyPreset(preset) {
            state.assembly.assemblyPreset = preset || null;

            const presetNames = {
                'youtube-engaging': 'YouTube Engaging - Hook-driven, pattern breaks',
                'tiktok-viral': 'TikTok Viral - Rapid cuts, trending style',
                'cinematic-film': 'Cinematic Film - Motivated cuts, film language',
                'documentary': 'Documentary - Evidence-based, interview rhythm',
                'music-video': 'Music Video - Beat-synced, creative transitions',
                'commercial-ad': 'Commercial/Ad - Feature highlights, CTA timing',
                'educational': 'Educational - Concept reinforcement, retention',
                'asmr-relaxation': 'ASMR/Relaxation - Slow dissolves, ambient'
            };

            if (preset) {
                showToast(`Assembly preset: ${presetNames[preset] || preset}`, 'success');
            } else {
                showToast('Assembly preset: Auto (from genre)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        function setPacingProfile(profile) {
            state.assembly.pacingProfile = profile || null;

            const profileNames = {
                'rapid-fire': 'Rapid Fire (1-2s cuts)',
                'fast': 'Fast (2-3s cuts)',
                'dynamic': 'Dynamic (varies with content)',
                'balanced': 'Balanced (3-5s cuts)',
                'contemplative': 'Contemplative (5-8s cuts)',
                'cinematic': 'Cinematic (6-12s cuts)',
                'episodic': 'Episodic (structured rhythm)'
            };

            if (profile) {
                showToast(`Pacing: ${profileNames[profile] || profile}`, 'success');
            } else {
                showToast('Pacing: Auto (from preset)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        function setBeatSyncMode(mode) {
            state.assembly.beatSyncMode = mode || 'off';

            const modeNames = {
                'off': 'Beat sync disabled',
                'subtle': 'Subtle - Cut on musical phrases',
                'moderate': 'Moderate - Cut on measures',
                'aggressive': 'Aggressive - Cut on beats',
                'music-video': 'Music Video - Every beat triggers cut'
            };

            showToast(`Beat sync: ${modeNames[mode] || mode}`, 'success');

            scheduleAutoSave();
            render();
        }

        function setPatternInterrupt(strategy) {
            state.assembly.patternInterrupt = strategy || null;

            const strategyNames = {
                'youtube': 'YouTube - Pattern breaks every 45-60s',
                'tiktok': 'TikTok - High frequency every 3-5s',
                'instagram': 'Instagram - Medium frequency 15-20s',
                'cinema': 'Cinema - Story beat driven',
                'documentary': 'Documentary - Slower 90-120s',
                'minimal': 'Minimal - Rare interrupts'
            };

            if (strategy) {
                showToast(`Pattern interrupts: ${strategyNames[strategy] || strategy}`, 'success');
            } else {
                showToast('Pattern interrupts: Auto (from platform)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        function setBRollStrategy(strategy) {
            state.assembly.bRollStrategy = strategy || null;

            const strategyNames = {
                'aggressive': 'Aggressive - 50-70% B-roll coverage',
                'moderate': 'Moderate - 30-50% B-roll coverage',
                'minimal': 'Minimal - 10-30% B-roll coverage',
                'talking-head': 'Talking Head Focus - Minimal cutaways',
                'montage': 'Montage Heavy - 70%+ visual sequences'
            };

            if (strategy) {
                showToast(`B-Roll: ${strategyNames[strategy] || strategy}`, 'success');
            } else {
                showToast('B-Roll strategy: Auto (from genre)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        async function getAssemblyRecommendationsForProject() {
            showToast('Analyzing project for assembly recommendations...', 'info');

            try {
                const functions = firebase.functions();
                const buildPlan = functions.httpsCallable('creationWizardBuildAssemblyPlan');
                const result = await buildPlan({
                    genre: state.content.genre,
                    platform: state.export?.platform || 'youtube',
                    duration: calculateTotalDuration(),
                    sceneCount: (state.script.scenes || []).length,
                    mood: state.assembly.audioMood || state.storyboard.visualStyle?.mood,
                    preset: state.assembly.assemblyPreset,
                    hasMusic: state.assembly.music?.enabled,
                    tempo: state.assembly.music?.tempo || 120
                });

                if (result.data.success && result.data.plan) {
                    const plan = result.data.plan;

                    // Apply recommendations
                    if (plan.preset && !state.assembly.assemblyPreset) {
                        state.assembly.assemblyPreset = plan.preset;
                    }
                    if (plan.pacing && !state.assembly.pacingProfile) {
                        state.assembly.pacingProfile = plan.pacing.profile;
                    }
                    if (plan.beatSync && !state.assembly.beatSyncMode) {
                        state.assembly.beatSyncMode = plan.beatSync.mode;
                    }

                    showToast(`AI recommendations applied! Preset: ${plan.preset || 'custom'}`, 'success');
                    render();
                } else {
                    showToast('Using default assembly settings', 'info');
                }
            } catch (error) {
                console.error('Failed to get assembly recommendations:', error);
                showToast('Could not get AI recommendations', 'error');
            }
        }

        function calculateTotalDuration() {
            const scenes = state.script.scenes || [];
            return scenes.reduce((total, scene) => total + (scene.duration || 5), 0);
        }

        // Phase 3F: Narrative Structure Intelligence Functions
        function setNarrativePreset(preset) {
            state.content.narrativePreset = preset || null;

            const presetNames = {
                'youtube-standard': 'YouTube Standard - Hook-driven with pattern breaks',
                'tiktok-viral': 'TikTok Viral - Rapid hook, payoff at 80%',
                'cinematic-short': 'Cinematic Short - Character-focused drama',
                'documentary-feature': 'Documentary - Evidence-based structure',
                'series-episode': 'Series Episode - Cliffhanger ending',
                'commercial-spot': 'Commercial - Problem-solution with CTA',
                'music-video-narrative': 'Music Video - Beat-synced narrative',
                'thriller-short': 'Thriller - Twist-driven tension',
                'horror-short': 'Horror - Scare-paced structure',
                'inspirational': 'Inspirational - Transformation arc'
            };

            if (preset) {
                showToast(`Narrative preset: ${presetNames[preset] || preset}`, 'success');
            } else {
                showToast('Narrative preset: Auto (from genre)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        function setStoryArc(arc) {
            state.content.storyArc = arc || null;

            const arcNames = {
                'three-act': 'Three-Act Structure (Hollywood)',
                'five-act': 'Five-Act Structure (Shakespeare)',
                'heros-journey': "Hero's Journey (Campbell)",
                'dan-harmon-circle': 'Story Circle (Dan Harmon)',
                'freytags-pyramid': "Freytag's Pyramid",
                'kishotenketsu': 'Kishotenketsu (East Asian)',
                'youtube-retention': 'YouTube Retention Structure',
                'tiktok-viral': 'TikTok Viral Structure',
                'problem-solution': 'Problem-Solution',
                'before-after-bridge': 'Before-After-Bridge',
                'inverted-pyramid': 'Inverted Pyramid (News)',
                'documentary-observational': 'Documentary Observational'
            };

            if (arc) {
                showToast(`Story arc: ${arcNames[arc] || arc}`, 'success');
            } else {
                showToast('Story arc: Auto (from preset)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        function setEmotionalJourney(journey) {
            state.content.emotionalJourney = journey || null;

            const journeyNames = {
                'triumph': 'Triumph - Low to high emotional arc',
                'redemption': 'Redemption - Fall then rise',
                'cinderella': 'Cinderella - Rise, fall, rise pattern',
                'tragedy': 'Tragedy - High to low arc',
                'thriller': 'Thriller - Tension with peaks',
                'mystery': 'Mystery - Curiosity building',
                'comedy': 'Comedy - Ups and downs, happy ending',
                'horror': 'Horror - Dread building with shocks',
                'educational': 'Educational - Steady engagement',
                'meditative': 'Meditative - Calm throughout'
            };

            if (journey) {
                showToast(`Emotional arc: ${journeyNames[journey] || journey}`, 'success');
            } else {
                showToast('Emotional arc: Auto (from genre)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        function setTensionCurve(curve) {
            state.content.tensionCurve = curve || null;

            const curveNames = {
                'steady-build': 'Steady Build - Continuous increase',
                'waves': 'Waves - Build and release cycles',
                'slow-burn': 'Slow Burn - Gradual to explosive',
                'flat-with-spikes': 'Spikes - Calm with sudden peaks',
                'escalating-steps': 'Steps - Stepped increases',
                'rollercoaster': 'Rollercoaster - Extreme ups/downs',
                'double-peak': 'Double Peak - Two climaxes'
            };

            if (curve) {
                showToast(`Tension style: ${curveNames[curve] || curve}`, 'success');
            } else {
                showToast('Tension style: Auto (from preset)', 'info');
            }

            scheduleAutoSave();
            render();
        }

        async function analyzeNarrativePacing() {
            const scenes = state.script.scenes || [];
            if (scenes.length === 0) {
                showToast('Generate a script first to analyze narrative pacing', 'info');
                return;
            }

            showToast('Analyzing narrative structure...', 'info');

            try {
                const functions = firebase.functions();
                const analyzePacing = functions.httpsCallable('creationWizardAnalyzeNarrativePacing');
                const result = await analyzePacing({
                    scenes: scenes.map(s => ({ id: s.id, duration: s.duration || 5 })),
                    genre: state.content.genre,
                    preset: state.content.narrativePreset,
                    targetDuration: calculateTotalDuration()
                });

                if (result.data.success) {
                    const { structure, analysis, overallRecommendations } = result.data;

                    // Store the analysis for display
                    state.content.narrativeAnalysis = {
                        structure,
                        analysis,
                        recommendations: overallRecommendations
                    };

                    // Apply the recommended structure if not already set
                    if (!state.content.storyArc && structure.arc) {
                        state.content.storyArc = structure.arc;
                    }
                    if (!state.content.emotionalJourney && structure.emotionalJourney) {
                        state.content.emotionalJourney = structure.emotionalJourney;
                    }

                    // Show summary
                    const suggestions = analysis.filter(a => a.suggestions && a.suggestions.length > 0);
                    if (suggestions.length > 0) {
                        showToast(`Analyzed! ${suggestions.length} scenes have pacing suggestions`, 'success');
                    } else {
                        showToast(`Perfect! All ${scenes.length} scenes align with ${structure.arc} structure`, 'success');
                    }

                    render();
                } else {
                    showToast('Analysis complete - using current structure', 'info');
                }
            } catch (error) {
                console.error('Failed to analyze narrative:', error);
                showToast('Could not analyze narrative structure', 'error');
            }
        }

        async function getNarrativeRecommendationsForProject() {
            try {
                const functions = firebase.functions();
                const buildStructure = functions.httpsCallable('creationWizardBuildNarrativeStructure');
                const result = await buildStructure({
                    genre: state.content.genre,
                    duration: calculateTotalDuration(),
                    platform: state.export?.platform || 'youtube',
                    preset: state.content.narrativePreset,
                    sceneCount: (state.script.scenes || []).length,
                    mood: state.assembly.audioMood || state.storyboard.visualStyle?.mood
                });

                if (result.data.success) {
                    return result.data.structure;
                }
            } catch (error) {
                console.error('Failed to get narrative recommendations:', error);
            }
            return null;
        }

        // Helper functions to update preview settings
        function updatePreviewTransitions() {
            if (!previewEngine || !state.preview.isReady) return;
            // Update transition settings in preview engine scenes
            previewEngine.scenes.forEach(scene => {
                const transition = state.assembly.transitions[scene.id] || { type: 'cut' };
                scene.transition = transition.type;
                scene.transitionDuration = transition.duration || 0.5;
            });
        }

        async function updatePreviewMusic() {
            if (!previewEngine || !state.preview.isReady) return;

            if (state.assembly.music.enabled && state.assembly.music.trackId) {
                const track = state.assembly.musicLibrary.find(t => t.id === state.assembly.music.trackId);
                // Use url or previewUrl - tracks from Pixabay have previewUrl
                const audioUrl = track?.url || track?.previewUrl;
                if (audioUrl) {
                    try {
                        await previewEngine.setBackgroundMusic(audioUrl, state.assembly.music.volume / 100);
                        console.log('[updatePreviewMusic] Playing:', track.name, 'from', audioUrl.substring(0, 50) + '...');
                    } catch (e) {
                        console.error('Failed to update music:', e);
                    }
                } else {
                    console.warn('[updatePreviewMusic] No audio URL for track:', track?.name);
                }
            } else {
                // Disable music
                previewEngine.stopBackgroundMusic();
            }
        }

        async function saveAssemblySettings() {
            try {
                const updateAssembly = firebase.functions().httpsCallable('creationWizardUpdateAssembly');
                await updateAssembly({
                    projectId: state.project.id,
                    assembly: {
                        status: 'ready',
                        sceneOrder: state.assembly.sceneOrder,
                        transitions: state.assembly.transitions,
                        music: state.assembly.music,
                        captions: state.assembly.captions,
                        audioMix: state.assembly.audioMix
                    }
                });
                state.assembly.status = 'ready';
                showToast('Assembly settings saved!', 'success');
                saveProject();
                render();
            } catch (error) {
                console.error('Failed to save assembly:', error);
                showToast('Failed to save assembly settings', 'error');
            }
        }

        // ==========================================
        // 7.10.1 VIDEO PREVIEW ENGINE CONTROLS
        // ==========================================

        let previewEngine = null;

        async function initializePreviewEngine() {
            const canvas = document.getElementById('preview-canvas');
            if (!canvas) {
                console.error('Preview canvas not found');
                return;
            }

            // Update state to show loading
            state.preview.loadProgress = 1;
            render();

            // Create the engine
            previewEngine = new VideoPreviewEngine(canvas, {
                width: 1280,
                height: 720,
                onTimeUpdate: (time) => {
                    state.preview.currentTime = time;

                    // Update scrubber without full re-render
                    const scrubber = document.getElementById('preview-scrubber');
                    if (scrubber) {
                        scrubber.value = time;
                        const percent = (time / state.preview.totalDuration) * 100;
                        scrubber.style.background = `linear-gradient(to right, #8b5cf6 0%, #8b5cf6 ${percent}%, rgba(255,255,255,0.2) ${percent}%, rgba(255,255,255,0.2) 100%)`;
                    }

                    // Update time display without full re-render
                    const timeDisplay = document.getElementById('preview-time-display');
                    if (timeDisplay) {
                        timeDisplay.textContent = `${formatDuration(time)} / ${formatDuration(state.preview.totalDuration)}`;
                    }

                    // Update scene progress bar
                    updateSceneProgress(time);
                },
                onSceneChange: (sceneIndex) => {
                    state.preview.currentSceneIndex = sceneIndex;
                    highlightTimelineScene(sceneIndex);
                    updateCurrentSceneIndicator(sceneIndex);
                    // NO render() - prevents flickering during playback
                },
                onEnded: () => {
                    state.preview.isPlaying = false;
                    state.preview.currentTime = 0;
                    updatePreviewPlayButton(false);
                    // NO render() - selective update only
                },
                onLoadProgress: (progress) => {
                    state.preview.loadProgress = progress;
                    updatePreviewLoadProgress(progress);
                    // NO render() - selective update only
                },
                onReady: () => {
                    state.preview.isReady = true;
                    state.preview.loadProgress = 100;
                    updatePreviewLoadProgress(100);
                    updatePreviewPlayButton(false);
                    // NO render() - selective update only
                }
            });

            // Build scenes array from current state
            const scenes = buildPreviewScenes();
            state.preview.totalDuration = scenes.reduce((sum, s) => sum + (s.duration || 8), 0);

            try {
                await previewEngine.loadScenes(scenes);

                // Set caption settings - unified style-aware system
                const captions = state.assembly.captions;
                previewEngine.captionsEnabled = captions.enabled;
                previewEngine.captionStyle = captions.style;
                previewEngine.captionPosition = captions.position;
                previewEngine.captionSize = captions.size || 1;
                // Enhanced settings (Phase 2)
                previewEngine.captionMode = captions.mode || 'word';
                previewEngine.captionFontFamily = captions.fontFamily || 'Montserrat';
                previewEngine.captionFillColor = captions.fillColor || '#FFFFFF';
                previewEngine.captionStrokeColor = captions.strokeColor || '#000000';
                previewEngine.captionStrokeWidth = captions.strokeWidth || 2;
                previewEngine.captionEffect = captions.effect || 'none';
                previewEngine.captionHighlightColor = captions.highlightColor || '#FBBF24';

                // Set music if enabled
                if (state.assembly.music.enabled && state.assembly.music.trackId) {
                    const track = state.assembly.musicLibrary.find(t => t.id === state.assembly.music.trackId);
                    const audioUrl = track?.url || track?.previewUrl;
                    if (audioUrl) {
                        await previewEngine.setBackgroundMusic(audioUrl, state.assembly.music.volume / 100);
                    }
                }

            } catch (error) {
                console.error('Failed to initialize preview:', error);
                showToast('Failed to load preview', 'error');
                state.preview.loadProgress = 0;
                render();
            }
        }

        function buildPreviewScenes() {
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            return sceneOrder.map(sceneId => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = storyboardScenes.find(s => s.sceneId === sceneId);
                const transition = state.assembly.transitions[sceneId] || { type: 'cut' };

                if (!scriptScene) return null;

                return {
                    id: sceneId,
                    type: animScene?.videoUrl ? 'video' : (storyboardScene?.source === 'stock-video' ? 'video' : 'image'),
                    imageUrl: storyboardScene?.imageUrl,
                    videoUrl: animScene?.videoUrl || (storyboardScene?.source === 'stock-video' ? storyboardScene?.videoUrl : null),
                    duration: scriptScene.duration || 8,
                    voiceoverUrl: animScene?.voiceoverUrl,
                    voiceoverDuration: animScene?.voiceoverDuration,
                    voiceoverOffset: scriptScene.voiceoverOffset || 0,
                    caption: scriptScene.narration,
                    transition: transition.type,
                    transitionDuration: transition.duration || 0.5,
                    kenBurns: {
                        startZoom: 1.0,
                        endZoom: 1.15,
                        startX: 0.5 + (Math.random() - 0.5) * 0.1,
                        startY: 0.5 + (Math.random() - 0.5) * 0.1,
                        endX: 0.5 + (Math.random() - 0.5) * 0.1,
                        endY: 0.5 + (Math.random() - 0.5) * 0.1
                    }
                };
            }).filter(Boolean);
        }

        function togglePreviewPlayback() {
            if (!previewEngine || !state.preview.isReady) return;

            if (state.preview.isPlaying) {
                previewEngine.pause();
                state.preview.isPlaying = false;
            } else {
                previewEngine.play();
                state.preview.isPlaying = true;
            }
            updatePreviewPlayButton(state.preview.isPlaying);
            // NO render() - selective update prevents flickering
        }

        function stopPreview() {
            if (!previewEngine || !state.preview.isReady) return;

            previewEngine.pause();
            previewEngine.seek(0);
            state.preview.isPlaying = false;
            state.preview.currentTime = 0;
            state.preview.currentSceneIndex = 0;
            updatePreviewPlayButton(false);
            highlightTimelineScene(0);
            updateCurrentSceneIndicator(0);
            // NO render() - selective update prevents flickering
        }

        function seekPreview(time) {
            if (!previewEngine || !state.preview.isReady) return;

            const newTime = parseFloat(time);
            previewEngine.seek(newTime);
            state.preview.currentTime = newTime;
        }

        function updateScrubberPreview(time) {
            // Visual feedback while dragging - update time display
            state.preview.currentTime = parseFloat(time);
            const timeDisplay = document.querySelector('[style*="font-family: monospace"]');
            if (timeDisplay) {
                timeDisplay.textContent = `${formatDuration(parseFloat(time))} / ${formatDuration(state.preview.totalDuration)}`;
            }
        }

        function setPreviewVolume(volume) {
            state.preview.volume = parseInt(volume);
            if (previewEngine) {
                previewEngine.voiceVolume = volume / 100;
            }
        }

        function prevPreviewScene() {
            if (!previewEngine || !state.preview.isReady) return;
            if (state.preview.currentSceneIndex > 0) {
                const newIndex = state.preview.currentSceneIndex - 1;
                const scenes = previewEngine.scenes;
                if (scenes[newIndex]) {
                    previewEngine.seek(scenes[newIndex].startTime);
                    state.preview.currentSceneIndex = newIndex;
                    state.preview.currentTime = scenes[newIndex].startTime;
                    highlightTimelineScene(newIndex);
                    updateCurrentSceneIndicator(newIndex);
                    // NO render() - selective update prevents flickering
                }
            }
        }

        function nextPreviewScene() {
            if (!previewEngine || !state.preview.isReady) return;
            const scriptScenes = state.script.scenes || [];
            if (state.preview.currentSceneIndex < scriptScenes.length - 1) {
                const newIndex = state.preview.currentSceneIndex + 1;
                const scenes = previewEngine.scenes;
                if (scenes[newIndex]) {
                    previewEngine.seek(scenes[newIndex].startTime);
                    state.preview.currentSceneIndex = newIndex;
                    state.preview.currentTime = scenes[newIndex].startTime;
                    highlightTimelineScene(newIndex);
                    updateCurrentSceneIndicator(newIndex);
                    // NO render() - selective update prevents flickering
                }
            }
        }

        function seekToScene(sceneId) {
            if (!previewEngine || !state.preview.isReady) return;

            const sceneIndex = previewEngine.scenes.findIndex(s => s.id === sceneId);
            if (sceneIndex >= 0) {
                const scene = previewEngine.scenes[sceneIndex];
                previewEngine.seek(scene.startTime);
                state.preview.currentSceneIndex = sceneIndex;
                state.preview.currentTime = scene.startTime;
                render();
            }
        }

        function highlightTimelineScene(sceneIndex) {
            // Highlight the currently playing scene in the timeline
            const timelineScenes = document.querySelectorAll('.timeline-scene');
            timelineScenes.forEach((el, idx) => {
                const progressFill = el.querySelector('.scene-progress-fill');
                if (idx === sceneIndex) {
                    el.style.borderColor = 'rgba(139, 92, 246, 0.8)';
                    el.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.4)';
                    el.style.background = 'rgba(139, 92, 246, 0.1)';
                    el.dataset.playing = 'true';
                } else {
                    el.style.borderColor = 'rgba(255,255,255,0.1)';
                    el.style.boxShadow = 'none';
                    el.style.background = 'rgba(255,255,255,0.03)';
                    delete el.dataset.playing;
                    // Reset progress bar for non-current scenes
                    if (progressFill) progressFill.style.width = '0%';
                }
            });
        }

        function updateSceneProgress(currentTime) {
            if (!previewEngine || !state.preview.isReady) return;

            const scenes = previewEngine.scenes;
            const currentSceneIndex = state.preview.currentSceneIndex;
            const currentScene = scenes[currentSceneIndex];

            if (!currentScene) return;

            // Calculate progress within the current scene
            const sceneStartTime = currentScene.startTime;
            const sceneDuration = currentScene.duration || 8;
            const timeInScene = currentTime - sceneStartTime;
            const progress = Math.min(100, Math.max(0, (timeInScene / sceneDuration) * 100));

            // Update the progress bar for the current scene
            const currentSceneEl = document.querySelector(`.timeline-scene[data-scene-index="${currentSceneIndex}"]`);
            if (currentSceneEl) {
                const progressFill = currentSceneEl.querySelector('.scene-progress-fill');
                if (progressFill) {
                    progressFill.style.width = `${progress}%`;
                }
            }
        }

        // ==========================================
        // SELECTIVE DOM UPDATE FUNCTIONS (Prevent Flickering)
        // These functions update specific UI elements without full re-render
        // ==========================================

        function updatePreviewPlayButton(isPlaying) {
            // Update Assembly step play button (uses text characters)
            const playBtn = document.getElementById('preview-play-btn');
            if (playBtn) {
                playBtn.innerHTML = isPlaying ? '' : '';
            }

            // Update center play overlay visibility
            const playOverlay = document.getElementById('preview-play-overlay');
            if (playOverlay) {
                playOverlay.style.opacity = isPlaying ? '0' : '1';
                playOverlay.style.pointerEvents = isPlaying ? 'none' : 'auto';
                playOverlay.style.background = 'rgba(0,0,0,0.3)';
            }

            // Update Timeline step play button if on that step (uses text characters)
            const timelinePlayBtn = document.getElementById('timeline-play-btn');
            if (timelinePlayBtn) {
                timelinePlayBtn.innerHTML = isPlaying ? '' : '';
            }
        }

        function updatePreviewLoadProgress(progress) {
            // Update loading indicator
            const loadingOverlay = document.getElementById('preview-loading-overlay');
            if (loadingOverlay) {
                if (progress >= 100) {
                    loadingOverlay.style.display = 'none';
                } else {
                    loadingOverlay.style.display = 'flex';
                    const progressText = loadingOverlay.querySelector('.loading-progress-text');
                    if (progressText) {
                        progressText.textContent = `Loading... ${Math.round(progress)}%`;
                    }
                }
            }

            // Update progress bar if exists
            const progressBar = document.getElementById('preview-load-bar');
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
        }

        function updateCurrentSceneIndicator(sceneIndex) {
            // Update scene info panel with current scene narration
            const sceneInfo = document.getElementById('current-scene-info');
            if (sceneInfo && state.script.scenes) {
                const scene = state.script.scenes[sceneIndex];
                if (scene) {
                    const narrationPreview = (scene.narration || 'No scene loaded').substring(0, 35);
                    const ellipsis = scene.narration?.length > 35 ? '...' : '';
                    sceneInfo.textContent = `Scene ${sceneIndex + 1}: "${narrationPreview}${ellipsis}"`;
                }
            }
        }

        // Cleanup preview when leaving Assembly step
        function cleanupPreviewEngine() {
            if (previewEngine) {
                previewEngine.pause();
                previewEngine.destroy();
                previewEngine = null;
            }
            state.preview.isReady = false;
            state.preview.isPlaying = false;
            state.preview.loadProgress = 0;
        }

        // Keyboard shortcuts for preview playback (works on Edit and Export step)
        document.addEventListener('keydown', function(e) {
            // Only handle when on Edit and Export step (step 6) and preview is ready
            if (state.currentStep !== 6 || !state.preview.isReady) return;

            // Don't handle if user is typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

            // Use preview functions on the editor step
            const isTimeline = false; // Timeline mode removed

            switch(e.code) {
                case 'Space':
                    e.preventDefault();
                    isTimeline ? toggleTimelinePlayback() : togglePreviewPlayback();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift+Left: Previous scene
                        prevPreviewScene();
                    } else {
                        // Left: Seek back 5 seconds
                        const newTime = Math.max(0, state.preview.currentTime - 5);
                        if (isTimeline) {
                            previewEngine?.seek(newTime);
                            state.preview.currentTime = newTime;
                            updateTimelinePlayhead(newTime);
                        } else {
                            seekPreview(newTime);
                        }
                    }
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift+Right: Next scene
                        nextPreviewScene();
                    } else {
                        // Right: Seek forward 5 seconds
                        const newTime = Math.min(state.preview.totalDuration, state.preview.currentTime + 5);
                        if (isTimeline) {
                            previewEngine?.seek(newTime);
                            state.preview.currentTime = newTime;
                            updateTimelinePlayhead(newTime);
                        } else {
                            seekPreview(newTime);
                        }
                    }
                    break;
                case 'Home':
                    e.preventDefault();
                    if (isTimeline) {
                        seekTimelineStart();
                    } else {
                        seekPreview(0);
                    }
                    break;
                case 'End':
                    e.preventDefault();
                    if (isTimeline) {
                        seekTimelineEnd();
                    } else {
                        seekPreview(state.preview.totalDuration - 0.1);
                    }
                    break;
                case 'KeyM':
                    e.preventDefault();
                    // Toggle mute
                    if (state.preview.volume > 0) {
                        state.preview.previousVolume = state.preview.volume;
                        setPreviewVolume(0);
                    } else {
                        setPreviewVolume(state.preview.previousVolume || 100);
                    }
                    render();
                    break;

                // Edit shortcuts (only on Export step timeline)
                case 'KeyZ':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (e.shiftKey) {
                            redoEdit();
                        } else {
                            undoEdit();
                        }
                    }
                    break;
                case 'KeyY':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        redoEdit();
                    }
                    break;
                case 'KeyS':
                    if (!e.ctrlKey && !e.metaKey && isTimeline) {
                        e.preventDefault();
                        splitClipAtPlayhead();
                    }
                    break;
                case 'KeyD':
                    if ((e.ctrlKey || e.metaKey) && isTimeline) {
                        e.preventDefault();
                        duplicateSelectedClip();
                    }
                    break;
                case 'Delete':
                case 'Backspace':
                    if (isTimeline && state.timeline.selectedClipId !== null) {
                        e.preventDefault();
                        deleteSelectedClip();
                    }
                    break;
            }
        });

        // ==========================================
        // 7.11 STEP 7: EXPORT
        // ==========================================

        const EXPORT_QUALITIES = {
            '720p': { name: '720p HD', description: 'Good quality, smaller file', icon: '' },
            '1080p': { name: '1080p Full HD', description: 'High quality, recommended', icon: '' },
            '4k': { name: '4K Ultra HD', description: 'Maximum quality, large file', icon: '' }
        };

        // ==========================================
        // FULL-SCREEN EDITOR LAYOUT (Step 7)
        // ==========================================

        function renderFullScreenEditor() {
            const exportState = state.export || {};
            const isExporting = exportState.status === 'exporting' || exportState.status === 'processing';
            const isCompleted = exportState.status === 'completed';
            const isFailed = exportState.status === 'failed' || exportState.status === 'error';
            const progress = exportState.progress || 0;

            // Calculate video summary
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const animatedCount = animationScenes.filter(s => s.videoUrl).length;
            const imageCount = storyboardScenes.filter(s => s.imageUrl).length;
            const totalDuration = scriptScenes.reduce((sum, s) => sum + (s.duration || 8), 0);
            const platform = PLATFORM_PRESETS[state.platform.selected] || {};

            const { zoom, scrollLeft, selectedClipId, snapToGrid } = state.timeline;
            const { isReady, isPlaying, currentTime } = state.preview;
            const timelineWidth = totalDuration * zoom;

            const canExport = animatedCount > 0 || imageCount > 0;
            const selectedQuality = state.export.selectedQuality || '1080p';

            // If exporting, completed, or failed - show overlay modal
            if (isExporting || isCompleted || isFailed) {
                return renderFullScreenEditorWithModal(exportState, isExporting, isCompleted, isFailed, progress);
            }

            return `
                <div class="fullscreen-editor" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100vw;
                    height: 100vh;
                    background: #0a0a0f;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    z-index: 1000;
                ">
                    <!-- Top Bar -->
                    <div style="
                        height: 50px;
                        min-height: 50px;
                        background: rgba(20, 20, 30, 0.95);
                        border-bottom: 1px solid rgba(255,255,255,0.1);
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        padding: 0 1rem;
                    ">
                        <!-- Left: Back Button -->
                        <button onclick="goToStep(6)" style="
                            padding: 0.5rem 1rem;
                            border-radius: 0.4rem;
                            border: 1px solid rgba(255,255,255,0.2);
                            background: transparent;
                            color: white;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            gap: 0.5rem;
                            font-size: 0.85rem;
                        ">
                            <span></span> Back to Assembly
                        </button>

                        <!-- Center: Project Info -->
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="font-size: 0.9rem; font-weight: 600; color: white;">Timeline Editor</span>
                            <span style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">${formatDuration(totalDuration)}</span>
                        </div>

                        <!-- Right: Export Controls -->
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <!-- Quality Selector -->
                            <select onchange="setExportQuality(this.value)" style="
                                padding: 0.4rem 0.6rem;
                                border-radius: 0.3rem;
                                border: 1px solid rgba(255,255,255,0.2);
                                background: rgba(0,0,0,0.3);
                                color: white;
                                font-size: 0.8rem;
                                cursor: pointer;
                            ">
                                ${Object.entries(EXPORT_QUALITIES).map(([id, q]) => `
                                    <option value="${id}" ${selectedQuality === id ? 'selected' : ''}>${q.icon} ${id}</option>
                                `).join('')}
                            </select>

                            <!-- Export Button -->
                            <button onclick="startExport()" ${!canExport ? 'disabled' : ''} style="
                                padding: 0.5rem 1.5rem;
                                border-radius: 0.4rem;
                                border: none;
                                background: ${canExport ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'};
                                color: ${canExport ? 'white' : 'rgba(255,255,255,0.4)'};
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: ${canExport ? 'pointer' : 'not-allowed'};
                                display: flex;
                                align-items: center;
                                gap: 0.5rem;
                            ">
                                <span></span> Export
                            </button>
                        </div>
                    </div>

                    <!-- Main Content Area -->
                    <div style="
                        flex: 1;
                        display: grid;
                        grid-template-columns: 1fr 280px;
                        min-height: 0;
                        overflow: hidden;
                    ">
                        <!-- Left: Preview Player -->
                        <div style="
                            display: flex;
                            flex-direction: column;
                            background: #000;
                            padding: 1rem;
                            min-height: 0;
                            overflow: hidden;
                        ">
                            <!-- Preview Container -->
                            <div style="
                                flex: 1;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                min-height: 0;
                            ">
                                <div style="
                                    position: relative;
                                    width: 100%;
                                    max-width: calc((100vh - 280px) * 16 / 9);
                                    aspect-ratio: 16/9;
                                    background: #111;
                                    border-radius: 0.5rem;
                                    overflow: hidden;
                                ">
                                    <canvas id="timeline-preview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>

                                    <!-- Play overlay -->
                                    ${!isReady ? `
                                        <div style="position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.7);">
                                            <button onclick="initializeTimelinePreview()" style="padding: 1rem 2rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; font-size: 1rem;">
                                                <span style="font-size: 1.5rem;"></span> Load Preview
                                            </button>
                                        </div>
                                    ` : (!isPlaying ? `
                                        <div onclick="toggleTimelinePlayback()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; cursor: pointer; background: rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0'">
                                            <div style="width: 70px; height: 70px; background: rgba(139, 92, 246, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(0,0,0,0.4);">
                                                <span style="font-size: 2rem; margin-left: 5px;"></span>
                                            </div>
                                        </div>
                                    ` : '')}
                                </div>
                            </div>

                            <!-- Transport Controls -->
                            <div style="
                                height: 50px;
                                min-height: 50px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 1rem;
                                background: rgba(0,0,0,0.5);
                                border-radius: 0.5rem;
                                margin-top: 0.75rem;
                                padding: 0 1rem;
                            ">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <button onclick="seekTimelineStart()" ${!isReady ? 'disabled' : ''} style="width: 32px; height: 32px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                    <button onclick="toggleTimelinePlayback()" ${!isReady ? 'disabled' : ''} style="width: 44px; height: 44px; border-radius: 50%; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 1.1rem;">${isPlaying ? '' : ''}</button>
                                    <button onclick="seekTimelineEnd()" ${!isReady ? 'disabled' : ''} style="width: 32px; height: 32px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                </div>

                                <!-- Time Display -->
                                <div style="font-family: monospace; font-size: 1.1rem; color: white; background: rgba(0,0,0,0.5); padding: 0.4rem 0.75rem; border-radius: 0.25rem;">
                                    ${formatTimecode(currentTime)} <span style="color: rgba(255,255,255,0.4);">/</span> ${formatTimecode(totalDuration)}
                                </div>

                                <div style="flex: 1;"></div>

                                <!-- Volume -->
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.9rem;">${state.preview.volume > 0 ? '' : ''}</span>
                                    <input type="range" min="0" max="100" value="${state.preview.volume || 100}" onchange="setTimelineVolume(this.value)" style="width: 80px; height: 4px; cursor: pointer;">
                                </div>
                            </div>
                        </div>

                        <!-- Right: Sidebar -->
                        <div style="
                            background: rgba(15, 15, 25, 0.95);
                            border-left: 1px solid rgba(255,255,255,0.1);
                            display: flex;
                            flex-direction: column;
                            overflow-y: auto;
                        ">
                            ${renderFullScreenClipInspector(selectedClipId, scriptScenes, animationScenes)}
                            ${renderFullScreenExportSettings(canExport, animatedCount, imageCount, scriptScenes.length)}
                        </div>
                    </div>

                    <!-- Bottom: Professional Timeline -->
                    ${renderProfessionalTimeline(scriptScenes, animationScenes, totalDuration, zoom, snapToGrid, selectedClipId, currentTime, isReady)}
                </div>
            `;
        }

        function renderFullScreenEditorWithModal(exportState, isExporting, isCompleted, isFailed, progress) {
            // Base editor layout with modal overlay
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const totalDuration = scriptScenes.reduce((sum, s) => sum + (s.duration || 8), 0);

            let modalContent = '';

            if (isExporting) {
                modalContent = `
                    <div style="text-align: center; padding: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                        <h2 style="color: white; margin-bottom: 0.5rem;">Exporting Video...</h2>
                        <p style="color: rgba(255,255,255,0.6); margin-bottom: 1.5rem;">
                            ${exportState.stage || 'Processing your video'}
                        </p>
                        <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin-bottom: 0.5rem;">
                            <div style="width: ${progress}%; height: 100%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); transition: width 0.3s;"></div>
                        </div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.5);">${Math.round(progress)}% complete</div>
                    </div>
                `;
            } else if (isCompleted && exportState.outputUrl) {
                modalContent = `
                    <div style="text-align: center; padding: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                        <h2 style="color: white; margin-bottom: 0.5rem;">Export Complete!</h2>
                        <p style="color: rgba(255,255,255,0.6); margin-bottom: 1.5rem;">Your video is ready to download</p>
                        <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                            <a href="${exportState.outputUrl}" download style="
                                padding: 0.75rem 1.5rem;
                                border-radius: 0.5rem;
                                background: linear-gradient(135deg, #8b5cf6, #06b6d4);
                                color: white;
                                text-decoration: none;
                                font-weight: 600;
                                display: flex;
                                align-items: center;
                                gap: 0.5rem;
                            "> Download Video</a>
                            <button onclick="resetExport()" style="
                                padding: 0.75rem 1.5rem;
                                border-radius: 0.5rem;
                                border: 1px solid rgba(255,255,255,0.3);
                                background: transparent;
                                color: white;
                                cursor: pointer;
                                font-weight: 600;
                            ">Export Another</button>
                        </div>
                    </div>
                `;
            } else if (isFailed) {
                modalContent = `
                    <div style="text-align: center; padding: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                        <h2 style="color: #ef4444; margin-bottom: 0.5rem;">Export Failed</h2>
                        <p style="color: rgba(255,255,255,0.6); margin-bottom: 1.5rem;">
                            ${exportState.error || 'An error occurred during export'}
                        </p>
                        <button onclick="resetExport()" style="
                            padding: 0.75rem 1.5rem;
                            border-radius: 0.5rem;
                            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
                            color: white;
                            border: none;
                            cursor: pointer;
                            font-weight: 600;
                        ">Try Again</button>
                    </div>
                `;
            }

            return `
                <div class="fullscreen-editor" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100vw;
                    height: 100vh;
                    background: #0a0a0f;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    z-index: 1000;
                ">
                    <!-- Darkened background -->
                    <div style="position: absolute; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1001;">
                        <div style="
                            background: rgba(30, 30, 45, 0.98);
                            border: 1px solid rgba(255,255,255,0.1);
                            border-radius: 1rem;
                            min-width: 400px;
                            max-width: 500px;
                            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                        ">
                            ${modalContent}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderFullScreenClipInspector(selectedClipId, scriptScenes, animationScenes) {
            if (!selectedClipId) {
                return `
                    <div style="padding: 1rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.8rem; font-weight: 600; color: white; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.4rem;">
                            <span></span> Clip Inspector
                        </div>
                        <div style="text-align: center; padding: 1.5rem 0.5rem; color: rgba(255,255,255,0.4); font-size: 0.75rem;">
                            Select a clip in the timeline
                        </div>
                    </div>
                `;
            }

            const scriptScene = scriptScenes.find(s => s.id === selectedClipId);
            const animScene = animationScenes.find(s => s.sceneId === selectedClipId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === selectedClipId);
            const transition = state.assembly.transitions[selectedClipId] || { type: 'cut' };

            if (!scriptScene) return '';

            const sceneIndex = scriptScenes.findIndex(s => s.id === selectedClipId) + 1;

            return `
                <div style="padding: 1rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.8rem; font-weight: 600; color: white; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.4rem;">
                        <span></span> Scene ${sceneIndex}
                    </div>

                    <!-- Thumbnail -->
                    <div style="width: 100%; aspect-ratio: 16/9; background: rgba(0,0,0,0.3); border-radius: 0.3rem; overflow: hidden; margin-bottom: 0.6rem;">
                        ${storyboardScene?.imageUrl ? `<img src="${storyboardScene.imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">` : '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3); font-size: 0.7rem;">No image</div>'}
                    </div>

                    <!-- Properties -->
                    <div style="display: flex; flex-direction: column; gap: 0.5rem; font-size: 0.7rem;">
                        <div>
                            <label style="color: rgba(255,255,255,0.5); display: block; margin-bottom: 0.15rem;">Duration</label>
                            <div style="display: flex; align-items: center; gap: 0.4rem;">
                                <input type="number" value="${scriptScene.duration || 8}" min="1" max="60" step="0.5"
                                       onchange="updateClipDuration(${selectedClipId}, this.value)"
                                       style="flex: 1; padding: 0.35rem; border-radius: 0.2rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: white; font-size: 0.75rem;">
                                <span style="color: rgba(255,255,255,0.5);">sec</span>
                            </div>
                        </div>

                        <div>
                            <label style="color: rgba(255,255,255,0.5); display: block; margin-bottom: 0.15rem;">Transition</label>
                            <select onchange="updateClipTransition(${selectedClipId}, this.value)"
                                    style="width: 100%; padding: 0.35rem; border-radius: 0.2rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: white; font-size: 0.75rem;">
                                ${(state.assembly.transitionTypes || []).map(t => `
                                    <option value="${t.id}" ${transition.type === t.id ? 'selected' : ''}>${t.name}</option>
                                `).join('')}
                            </select>
                        </div>

                        <div style="display: flex; gap: 0.4rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="flex: 1;">
                                <span style="color: rgba(255,255,255,0.5);">Voice</span>
                                <div style="color: ${animScene?.voiceoverUrl ? '#10b981' : 'rgba(255,255,255,0.4)'}; margin-top: 0.1rem;">
                                    ${animScene?.voiceoverUrl ? '' : ''}
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <span style="color: rgba(255,255,255,0.5);">Video</span>
                                <div style="color: ${animScene?.videoUrl ? '#10b981' : (storyboardScene?.source === 'stock-video' ? '#06b6d4' : '#f59e0b')}; margin-top: 0.1rem;">
                                    ${animScene?.videoUrl ? ' Anim' : (storyboardScene?.source === 'stock-video' ? ' Stock' : ' Img')}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderFullScreenExportSettings(canExport, animatedCount, imageCount, totalScenes) {
            return `
                <div style="padding: 1rem; flex: 1;">
                    <div style="font-size: 0.8rem; font-weight: 600; color: white; margin-bottom: 0.6rem; display: flex; align-items: center; gap: 0.4rem;">
                        <span></span> Video Summary
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem; font-size: 0.7rem; margin-bottom: 0.75rem;">
                        <div style="padding: 0.4rem; background: rgba(255,255,255,0.03); border-radius: 0.2rem;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.65rem;">Scenes</div>
                            <div style="color: white;">${totalScenes}</div>
                        </div>
                        <div style="padding: 0.4rem; background: rgba(255,255,255,0.03); border-radius: 0.2rem;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.65rem;">Animated</div>
                            <div style="color: ${animatedCount === totalScenes ? '#10b981' : animatedCount > 0 ? '#06b6d4' : 'rgba(255,255,255,0.4)'};">${animatedCount}/${totalScenes}</div>
                        </div>
                        <div style="padding: 0.4rem; background: rgba(255,255,255,0.03); border-radius: 0.2rem;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.65rem;">Images</div>
                            <div style="color: ${imageCount === totalScenes ? '#10b981' : imageCount > 0 ? '#06b6d4' : '#f59e0b'};">${imageCount}/${totalScenes}</div>
                        </div>
                        <div style="padding: 0.4rem; background: rgba(255,255,255,0.03); border-radius: 0.2rem;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.65rem;">Ready</div>
                            <div style="color: ${canExport ? '#10b981' : '#f59e0b'};">${canExport ? 'Yes' : 'No'}</div>
                        </div>
                    </div>

                    ${!canExport ? `
                        <div style="padding: 0.4rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.2rem; font-size: 0.7rem; color: #ef4444;">
                            Generate images first
                        </div>
                    ` : animatedCount < totalScenes ? `
                        <div style="padding: 0.4rem; background: rgba(6, 182, 212, 0.1); border: 1px solid rgba(6, 182, 212, 0.3); border-radius: 0.2rem; font-size: 0.7rem; color: #06b6d4;">
                            ${animatedCount === 0 ? 'Ken Burns on images' : `${totalScenes - animatedCount} scene(s) use Ken Burns`}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // ==========================================
        // PROFESSIONAL TIMELINE COMPONENT
        // ==========================================

        function renderProfessionalTimeline(scriptScenes, animationScenes, totalDuration, zoom, snapToGrid, selectedClipId, currentTime, isReady) {
            const timelineWidth = totalDuration * zoom;
            const trackLabelWidth = 100;

            return `
                <div class="pro-timeline" style="
                    height: 280px;
                    min-height: 280px;
                    background: linear-gradient(180deg, rgba(15, 15, 25, 0.98) 0%, rgba(10, 10, 18, 0.99) 100%);
                    border-top: 1px solid rgba(139, 92, 246, 0.3);
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 -4px 20px rgba(0,0,0,0.4);
                ">
                    <!-- Timeline Toolbar -->
                    <div style="
                        height: 40px;
                        min-height: 40px;
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        padding: 0 1rem;
                        background: linear-gradient(90deg, rgba(139, 92, 246, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
                        border-bottom: 1px solid rgba(255,255,255,0.08);
                    ">
                        <!-- Left: Transport & Edit Tools -->
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <!-- Transport -->
                            <div style="display: flex; align-items: center; gap: 0.25rem; padding-right: 0.5rem; border-right: 1px solid rgba(255,255,255,0.15);">
                                <button onclick="seekTimelineStart()" title="Go to Start" style="width: 28px; height: 28px; border-radius: 4px; border: none; background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-size: 0.75rem; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.15)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'"></button>
                                <button onclick="toggleTimelinePlayback()" title="Play/Pause" style="width: 32px; height: 32px; border-radius: 6px; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.9rem; box-shadow: ${isReady ? '0 2px 8px rgba(139,92,246,0.4)' : 'none'};">${state.preview.isPlaying ? '' : ''}</button>
                                <button onclick="seekTimelineEnd()" title="Go to End" style="width: 28px; height: 28px; border-radius: 4px; border: none; background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-size: 0.75rem; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.15)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'"></button>
                            </div>

                            <!-- Edit Tools -->
                            <div style="display: flex; align-items: center; gap: 0.25rem;">
                                <button onclick="undoEdit()" ${!editHistory.canUndo() ? 'disabled' : ''} title="Undo (Ctrl+Z)" style="width: 28px; height: 28px; border-radius: 4px; border: none; background: ${editHistory.canUndo() ? 'rgba(255,255,255,0.08)' : 'transparent'}; color: ${editHistory.canUndo() ? 'white' : 'rgba(255,255,255,0.25)'}; cursor: ${editHistory.canUndo() ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                <button onclick="redoEdit()" ${!editHistory.canRedo() ? 'disabled' : ''} title="Redo (Ctrl+Y)" style="width: 28px; height: 28px; border-radius: 4px; border: none; background: ${editHistory.canRedo() ? 'rgba(255,255,255,0.08)' : 'transparent'}; color: ${editHistory.canRedo() ? 'white' : 'rgba(255,255,255,0.25)'}; cursor: ${editHistory.canRedo() ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.15); margin: 0 0.25rem;"></div>
                                <button onclick="splitClipAtPlayhead()" ${!isReady ? 'disabled' : ''} title="Split at Playhead (S)" style="padding: 0.35rem 0.6rem; border-radius: 4px; border: none; background: ${isReady ? 'rgba(255,255,255,0.08)' : 'transparent'}; color: ${isReady ? 'white' : 'rgba(255,255,255,0.25)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.75rem; display: flex; align-items: center; gap: 0.3rem;"><span></span> Split</button>
                                <button onclick="deleteSelectedClip()" ${!selectedClipId ? 'disabled' : ''} title="Delete Selected (Del)" style="padding: 0.35rem 0.6rem; border-radius: 4px; border: none; background: ${selectedClipId ? 'rgba(239,68,68,0.15)' : 'transparent'}; color: ${selectedClipId ? '#f87171' : 'rgba(255,255,255,0.25)'}; cursor: ${selectedClipId ? 'pointer' : 'not-allowed'}; font-size: 0.75rem; display: flex; align-items: center; gap: 0.3rem;"><span></span> Delete</button>
                            </div>
                        </div>

                        <!-- Center: Timeline Title & Time -->
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 1rem;"></span>
                                <span style="font-size: 0.85rem; font-weight: 600; color: white;">Timeline</span>
                            </div>
                            <div style="font-family: 'SF Mono', Monaco, monospace; font-size: 0.85rem; color: #8b5cf6; background: rgba(139,92,246,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; border: 1px solid rgba(139,92,246,0.2);">
                                ${formatTimecode(currentTime)} <span style="color: rgba(255,255,255,0.3);">/</span> ${formatTimecode(totalDuration)}
                            </div>
                        </div>

                        <!-- Right: Zoom & View Controls -->
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <label style="display: flex; align-items: center; gap: 0.4rem; cursor: pointer; font-size: 0.75rem; color: rgba(255,255,255,0.7); padding: 0.3rem 0.5rem; background: ${snapToGrid ? 'rgba(139,92,246,0.15)' : 'transparent'}; border-radius: 4px; border: 1px solid ${snapToGrid ? 'rgba(139,92,246,0.3)' : 'transparent'};">
                                <input type="checkbox" ${snapToGrid ? 'checked' : ''} onchange="toggleTimelineSnap(this.checked)" style="cursor: pointer; accent-color: #8b5cf6;">
                                <span>Snap</span>
                            </label>
                            <div style="display: flex; align-items: center; gap: 0.3rem; background: rgba(0,0,0,0.3); border-radius: 6px; padding: 0.2rem;">
                                <button onclick="zoomTimeline(-10)" title="Zoom Out" style="width: 26px; height: 26px; border-radius: 4px; border: none; background: transparent; color: white; cursor: pointer; font-size: 0.9rem; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'"></button>
                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 50px; text-align: center; font-family: monospace;">${zoom}px/s</div>
                                <button onclick="zoomTimeline(10)" title="Zoom In" style="width: 26px; height: 26px; border-radius: 4px; border: none; background: transparent; color: white; cursor: pointer; font-size: 0.9rem; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">+</button>
                            </div>
                            <button onclick="fitTimelineToView()" title="Fit to View" style="padding: 0.35rem 0.6rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 0.75rem; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">Fit</button>
                        </div>
                    </div>

                    <!-- Timeline Content Area -->
                    <div id="timeline-scroll-container" style="flex: 1; overflow-x: auto; overflow-y: hidden; position: relative;" onscroll="handleTimelineScroll(this)">
                        <div style="position: relative; min-width: ${Math.max(timelineWidth + 150, 900)}px; height: 100%; display: flex;">

                            <!-- Track Labels Column -->
                            <div style="width: ${trackLabelWidth}px; min-width: ${trackLabelWidth}px; flex-shrink: 0; background: rgba(0,0,0,0.4); border-right: 1px solid rgba(255,255,255,0.1); position: sticky; left: 0; z-index: 10;">
                                <!-- Time Ruler Label -->
                                <div style="height: 28px; border-bottom: 1px solid rgba(255,255,255,0.1);"></div>

                                <!-- Video Track Label -->
                                <div style="height: 75px; display: flex; align-items: center; padding: 0 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.05); background: linear-gradient(90deg, rgba(139,92,246,0.08) 0%, transparent 100%);">
                                    <div style="flex: 1; display: flex; flex-direction: column; gap: 0.2rem;">
                                        <div style="display: flex; align-items: center; gap: 0.4rem;">
                                            <span style="font-size: 0.9rem;"></span>
                                            <span style="font-size: 0.75rem; font-weight: 600; color: white;">Video</span>
                                        </div>
                                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">${scriptScenes.length} clips</span>
                                    </div>
                                    <button onclick="toggleTrackMute('video')" title="Mute Track" style="width: 22px; height: 22px; border-radius: 3px; border: none; background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.6rem;"></button>
                                </div>

                                <!-- Voice Track Label -->
                                <div style="height: 50px; display: flex; align-items: center; padding: 0 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.05); background: linear-gradient(90deg, rgba(6,182,212,0.08) 0%, transparent 100%);">
                                    <div style="flex: 1; display: flex; flex-direction: column; gap: 0.2rem;">
                                        <div style="display: flex; align-items: center; gap: 0.4rem;">
                                            <span style="font-size: 0.9rem;"></span>
                                            <span style="font-size: 0.75rem; font-weight: 600; color: white;">Voice</span>
                                        </div>
                                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">Narration</span>
                                    </div>
                                    <button onclick="toggleTrackMute('voice')" title="Mute Track" style="width: 22px; height: 22px; border-radius: 3px; border: none; background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.6rem;"></button>
                                </div>

                                <!-- Music Track Label -->
                                <div style="height: 40px; display: flex; align-items: center; padding: 0 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.05); background: linear-gradient(90deg, rgba(16,185,129,0.08) 0%, transparent 100%);">
                                    <div style="flex: 1; display: flex; flex-direction: column; gap: 0.1rem;">
                                        <div style="display: flex; align-items: center; gap: 0.4rem;">
                                            <span style="font-size: 0.85rem;"></span>
                                            <span style="font-size: 0.75rem; font-weight: 600; color: white;">Music</span>
                                        </div>
                                    </div>
                                    <button onclick="toggleTrackMute('music')" title="Mute Track" style="width: 22px; height: 22px; border-radius: 3px; border: none; background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.6rem;"></button>
                                </div>

                                <!-- Caption Track Label -->
                                <div style="height: 35px; display: flex; align-items: center; padding: 0 0.5rem; background: linear-gradient(90deg, rgba(245,158,11,0.08) 0%, transparent 100%);">
                                    <div style="flex: 1; display: flex; align-items: center; gap: 0.4rem;">
                                        <span style="font-size: 0.85rem;"></span>
                                        <span style="font-size: 0.75rem; font-weight: 600; color: white;">Captions</span>
                                    </div>
                                    <div style="width: 8px; height: 8px; border-radius: 50%; background: ${state.assembly.captions?.enabled ? '#10b981' : 'rgba(255,255,255,0.2)'};"></div>
                                </div>
                            </div>

                            <!-- Tracks Content Area -->
                            <div style="flex: 1; position: relative;">
                                <!-- Time Ruler -->
                                ${renderProTimeRuler(totalDuration, zoom)}

                                <!-- Playhead -->
                                <div id="timeline-playhead" style="position: absolute; top: 0; left: ${currentTime * zoom}px; width: 2px; height: 100%; z-index: 50; pointer-events: none;">
                                    <!-- Playhead Head -->
                                    <div style="position: absolute; top: 0; left: -7px; width: 16px; height: 16px; background: linear-gradient(180deg, #ef4444, #dc2626); border-radius: 3px 3px 0 0; display: flex; align-items: center; justify-content: center;">
                                        <div style="width: 0; height: 0; border-left: 4px solid transparent; border-right: 4px solid transparent; border-top: 5px solid white; margin-top: 2px;"></div>
                                    </div>
                                    <!-- Playhead Line -->
                                    <div style="position: absolute; top: 16px; left: 0; width: 2px; height: calc(100% - 16px); background: linear-gradient(180deg, #ef4444 0%, rgba(239,68,68,0.6) 100%); box-shadow: 0 0 8px rgba(239,68,68,0.5);"></div>
                                </div>

                                <!-- Tracks -->
                                <div style="position: absolute; top: 28px; left: 0; right: 0; bottom: 0;">
                                    ${renderProVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId)}
                                    ${renderProVoiceTrack(scriptScenes, animationScenes, zoom)}
                                    ${renderProMusicTrack(totalDuration, zoom)}
                                    ${renderProCaptionTrack(scriptScenes, animationScenes, zoom)}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderProTimeRuler(totalDuration, zoom) {
            let tickInterval = 1;
            if (zoom < 15) tickInterval = 10;
            else if (zoom < 30) tickInterval = 5;
            else if (zoom < 60) tickInterval = 2;
            else tickInterval = 1;

            let rulerHtml = `<div style="height: 28px; background: rgba(0,0,0,0.3); border-bottom: 1px solid rgba(255,255,255,0.15); position: relative; cursor: pointer;" onclick="seekTimelineFromRuler(event)">`;

            for (let t = 0; t <= totalDuration; t += tickInterval) {
                const x = t * zoom;
                const isMajor = t % (tickInterval * 5) === 0 || tickInterval >= 5;

                rulerHtml += `
                    <div style="position: absolute; left: ${x}px; bottom: 0; height: ${isMajor ? '12px' : '6px'}; width: 1px; background: rgba(255,255,255,${isMajor ? '0.4' : '0.15'});"></div>
                    ${isMajor ? `<span style="position: absolute; left: ${x + 4}px; top: 4px; font-size: 0.65rem; color: rgba(255,255,255,0.5); font-family: monospace;">${formatTimecode(t)}</span>` : ''}
                `;
            }

            rulerHtml += `</div>`;
            return rulerHtml;
        }

        function renderProVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 75px; position: relative; background: linear-gradient(180deg, rgba(139,92,246,0.06) 0%, rgba(139,92,246,0.02) 100%); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                const transition = state.assembly.transitions?.[sceneId] || { type: 'cut' };

                if (!scriptScene) return;

                const duration = scriptScene.duration || 8;
                const width = duration * zoom;
                const x = currentTime * zoom;
                const isSelected = selectedClipId === sceneId;
                const hasVideo = animScene?.videoUrl || (storyboardScene?.source === 'stock-video' && storyboardScene?.videoUrl);
                const imageUrl = storyboardScene?.imageUrl;

                // Transition indicator (diamond) between clips
                if (index > 0 && transition.type !== 'cut') {
                    trackHtml += `
                        <div style="position: absolute; left: ${x - 8}px; top: 50%; transform: translateY(-50%); z-index: 5;">
                            <div style="width: 14px; height: 14px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 2px; transform: rotate(45deg); box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>
                        </div>
                    `;
                }

                trackHtml += `
                    <div class="timeline-clip pro-clip" data-clip-id="${sceneId}"
                         onclick="selectTimelineClip(${sceneId}, 'video')"
                         style="
                            position: absolute;
                            left: ${x + 2}px;
                            top: 4px;
                            width: ${width - 4}px;
                            height: 67px;
                            background: ${isSelected
                                ? 'linear-gradient(180deg, rgba(139,92,246,0.5) 0%, rgba(139,92,246,0.3) 100%)'
                                : 'linear-gradient(180deg, rgba(139,92,246,0.25) 0%, rgba(139,92,246,0.15) 100%)'};
                            border: 2px solid ${isSelected ? '#a78bfa' : 'rgba(139,92,246,0.4)'};
                            border-radius: 6px;
                            overflow: hidden;
                            cursor: pointer;
                            display: flex;
                            transition: all 0.15s ease;
                            box-shadow: ${isSelected ? '0 0 12px rgba(139,92,246,0.4), inset 0 1px 0 rgba(255,255,255,0.1)' : 'inset 0 1px 0 rgba(255,255,255,0.05)'};
                        "
                        onmouseover="this.style.borderColor='${isSelected ? '#a78bfa' : 'rgba(139,92,246,0.6)'}'"
                        onmouseout="this.style.borderColor='${isSelected ? '#a78bfa' : 'rgba(139,92,246,0.4)'}'"
                    >
                        <!-- Thumbnail -->
                        <div style="width: 60px; min-width: 60px; height: 100%; background: rgba(0,0,0,0.4); border-right: 1px solid rgba(255,255,255,0.1); pointer-events: none;">
                            ${imageUrl
                                ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" draggable="false">`
                                : `<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3); font-size: 1.2rem;"></div>`
                            }
                        </div>
                        <!-- Info Panel -->
                        <div style="flex: 1; padding: 0.4rem 0.5rem; min-width: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;">
                            <div>
                                <div style="font-size: 0.75rem; color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    Scene ${index + 1}
                                </div>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.5); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 2px;">
                                    ${scriptScene.narration?.substring(0, 25) || 'No narration'}${scriptScene.narration?.length > 25 ? '...' : ''}
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.4rem;">
                                <span style="font-size: 0.65rem; color: rgba(255,255,255,0.6); background: rgba(0,0,0,0.3); padding: 0.15rem 0.35rem; border-radius: 3px;">${duration}s</span>
                                <span style="font-size: 0.6rem; color: ${hasVideo ? '#10b981' : '#f59e0b'}; background: ${hasVideo ? 'rgba(16,185,129,0.15)' : 'rgba(245,158,11,0.15)'}; padding: 0.15rem 0.35rem; border-radius: 3px;">
                                    ${hasVideo ? ' video' : ' img'}
                                </span>
                            </div>
                        </div>
                        <!-- Selection Handles -->
                        ${isSelected ? `
                            <div style="position: absolute; left: 0; top: 0; width: 6px; height: 100%; background: linear-gradient(180deg, #a78bfa, #8b5cf6); cursor: ew-resize; border-radius: 6px 0 0 6px;" onmousedown="startTrimClip(${sceneId}, 'left', event)"></div>
                            <div style="position: absolute; right: 0; top: 0; width: 6px; height: 100%; background: linear-gradient(180deg, #a78bfa, #8b5cf6); cursor: ew-resize; border-radius: 0 6px 6px 0;" onmousedown="startTrimClip(${sceneId}, 'right', event)"></div>
                        ` : ''}
                    </div>
                `;

                currentTime += duration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderProVoiceTrack(scriptScenes, animationScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 50px; position: relative; background: linear-gradient(180deg, rgba(6,182,212,0.06) 0%, rgba(6,182,212,0.02) 100%); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach(sceneId => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const sceneDuration = scriptScene.duration || 8;
                const hasVoiceover = animScene?.voiceoverUrl;
                const voiceoverDuration = animScene?.voiceoverDuration || sceneDuration * 0.85;
                const voiceoverOffset = scriptScene.voiceoverOffset || 0;
                const width = voiceoverDuration * zoom;
                const x = (currentTime + voiceoverOffset) * zoom;

                if (hasVoiceover) {
                    // Format duration for display
                    const durationDisplay = voiceoverDuration.toFixed(1) + 's';
                    const hasOffset = voiceoverOffset > 0.1;

                    trackHtml += `
                        <div style="
                            position: absolute;
                            left: ${x + 2}px;
                            top: 5px;
                            width: ${width - 2}px;
                            height: 40px;
                            background: linear-gradient(180deg, rgba(6,182,212,0.35) 0%, rgba(6,182,212,0.2) 100%);
                            border: 1px solid rgba(6,182,212,0.5);
                            border-radius: 5px;
                            overflow: hidden;
                            box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
                        ">
                            <!-- Duration indicator -->
                            <div style="position: absolute; top: 2px; right: 4px; font-size: 0.55rem; color: rgba(6,182,212,0.9); font-weight: 600; z-index: 1;">
                                ${durationDisplay}
                            </div>
                            ${hasOffset ? `
                                <div style="position: absolute; top: 2px; left: 4px; font-size: 0.5rem; color: rgba(255,255,255,0.5); z-index: 1;">
                                    +${voiceoverOffset.toFixed(1)}s
                                </div>
                            ` : ''}
                            <!-- Waveform Visualization -->
                            <svg width="100%" height="100%" viewBox="0 0 200 40" preserveAspectRatio="none" style="opacity: 0.8;">
                                <defs>
                                    <linearGradient id="waveGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#06b6d4;stop-opacity:0.9" />
                                        <stop offset="50%" style="stop-color:#0891b2;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#06b6d4;stop-opacity:0.9" />
                                    </linearGradient>
                                </defs>
                                ${generateDetailedWaveformPath()}
                            </svg>
                        </div>
                    `;
                }

                currentTime += sceneDuration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderProMusicTrack(totalDuration, zoom) {
            const musicEnabled = state.assembly.music?.enabled;
            const musicTrack = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music?.trackId);
            const width = totalDuration * zoom;

            let trackHtml = `<div style="height: 40px; position: relative; background: linear-gradient(180deg, rgba(16,185,129,0.06) 0%, rgba(16,185,129,0.02) 100%); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            if (musicEnabled && musicTrack) {
                trackHtml += `
                    <div style="
                        position: absolute;
                        left: 2px;
                        top: 4px;
                        width: ${width - 4}px;
                        height: 32px;
                        background: linear-gradient(90deg, rgba(16,185,129,0.25) 0%, rgba(16,185,129,0.15) 50%, rgba(16,185,129,0.25) 100%);
                        border: 1px solid rgba(16,185,129,0.4);
                        border-radius: 5px;
                        display: flex;
                        align-items: center;
                        padding: 0 0.6rem;
                        gap: 0.5rem;
                        overflow: hidden;
                    ">
                        <span style="font-size: 0.9rem;"></span>
                        <span style="font-size: 0.7rem; color: #34d399; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${musicTrack.name || 'Background Music'}
                        </span>
                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-left: auto;">
                            ${state.assembly.music?.volume || 30}%
                        </span>
                        <!-- Repeating pattern indicator -->
                        <div style="position: absolute; right: 0; top: 0; bottom: 0; width: 60px; background: linear-gradient(90deg, transparent, rgba(16,185,129,0.3)); display: flex; align-items: center; justify-content: center;">
                            <span style="font-size: 0.6rem; color: rgba(255,255,255,0.5);"></span>
                        </div>
                    </div>
                `;
            } else {
                trackHtml += `
                    <div style="position: absolute; left: 2px; top: 4px; right: 2px; height: 32px; border: 1px dashed rgba(16,185,129,0.3); border-radius: 5px; display: flex; align-items: center; justify-content: center;">
                        <span style="font-size: 0.65rem; color: rgba(255,255,255,0.3);">No background music</span>
                    </div>
                `;
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderProCaptionTrack(scriptScenes, animationScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);
            const captionsEnabled = state.assembly.captions?.enabled;

            let currentTime = 0;
            let trackHtml = `<div style="height: 35px; position: relative; background: linear-gradient(180deg, rgba(245,158,11,0.06) 0%, rgba(245,158,11,0.02) 100%);">`;

            if (captionsEnabled) {
                sceneOrder.forEach(sceneId => {
                    const scriptScene = scriptScenes.find(s => s.id === sceneId);
                    const animScene = animationScenes.find(s => s.sceneId === sceneId);
                    if (!scriptScene) return;

                    const sceneDuration = scriptScene.duration || 8;
                    // Use voiceover timing to sync with voice track
                    const voiceoverDuration = animScene?.voiceoverDuration || sceneDuration * 0.85;
                    const voiceoverOffset = scriptScene.voiceoverOffset || 0;
                    const width = voiceoverDuration * zoom;
                    const x = (currentTime + voiceoverOffset) * zoom;
                    const caption = scriptScene.narration?.substring(0, 25) || '';
                    const durationDisplay = voiceoverDuration.toFixed(1) + 's';

                    trackHtml += `
                        <div style="
                            position: absolute;
                            left: ${x + 2}px;
                            top: 4px;
                            width: ${width - 4}px;
                            height: 27px;
                            background: linear-gradient(180deg, rgba(245,158,11,0.25) 0%, rgba(245,158,11,0.15) 100%);
                            border: 1px solid rgba(245,158,11,0.4);
                            border-radius: 4px;
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            padding: 0 0.4rem;
                            overflow: hidden;
                        ">
                            <span style="font-size: 0.55rem; color: rgba(255,255,255,0.8); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-style: italic; flex: 1;">
                                "${caption}${caption.length >= 25 ? '...' : ''}"
                            </span>
                            <span style="font-size: 0.5rem; color: rgba(245,158,11,0.8); font-weight: 600; margin-left: 4px;">
                                ${durationDisplay}
                            </span>
                        </div>
                    `;

                    currentTime += sceneDuration;
                });
            } else {
                trackHtml += `
                    <div style="position: absolute; left: 2px; top: 4px; right: 2px; height: 27px; border: 1px dashed rgba(245,158,11,0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center;">
                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.3);">Captions disabled</span>
                    </div>
                `;
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function generateDetailedWaveformPath() {
            // Generate a more detailed, realistic waveform
            let pathTop = 'M0,20 ';
            let pathBottom = 'M0,20 ';

            for (let x = 0; x <= 200; x += 2) {
                const amplitude = 6 + Math.random() * 10;
                const noise = Math.sin(x * 0.3) * 3 + Math.cos(x * 0.7) * 2;
                const y1 = 20 - amplitude - noise;
                const y2 = 20 + amplitude + noise;
                pathTop += `L${x},${Math.max(2, y1)} `;
                pathBottom += `L${x},${Math.min(38, y2)} `;
            }

            return `
                <path d="${pathTop}" fill="none" stroke="url(#waveGradient)" stroke-width="1.5"/>
                <path d="${pathBottom}" fill="none" stroke="url(#waveGradient)" stroke-width="1.5"/>
            `;
        }

        function toggleTrackMute(trackName) {
            // Placeholder for track mute functionality
            showToast(`${trackName} track mute toggled`, 'info');
        }

        // Compact track renderers for full-screen editor (kept for backwards compatibility)
        function renderCompactVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 50px; position: relative; background: rgba(139, 92, 246, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const duration = scriptScene.duration || 8;
                const width = duration * zoom;
                const x = currentTime * zoom;
                const isSelected = selectedClipId === sceneId;
                const hasVideo = animScene?.videoUrl || (storyboardScene?.source === 'stock-video' && storyboardScene?.videoUrl);
                const imageUrl = storyboardScene?.imageUrl;

                trackHtml += `
                    <div class="timeline-clip" data-clip-id="${sceneId}"
                         onclick="selectTimelineClip(${sceneId}, 'video')"
                         style="position: absolute; left: ${x}px; top: 3px; width: ${width - 2}px; height: 44px; background: ${isSelected ? 'rgba(139, 92, 246, 0.4)' : 'rgba(139, 92, 246, 0.2)'}; border: 2px solid ${isSelected ? '#8b5cf6' : 'rgba(139, 92, 246, 0.5)'}; border-radius: 3px; overflow: hidden; cursor: grab; display: flex; transition: all 0.15s;">
                        <!-- Thumbnail -->
                        <div style="width: 40px; height: 100%; flex-shrink: 0; background: rgba(0,0,0,0.3); pointer-events: none;">
                            ${imageUrl ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" draggable="false">` : ''}
                        </div>
                        <!-- Info -->
                        <div style="flex: 1; padding: 0.2rem 0.3rem; min-width: 0; pointer-events: none;">
                            <div style="font-size: 0.6rem; color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                Scene ${index + 1}
                            </div>
                            <div style="font-size: 0.5rem; color: rgba(255,255,255,0.6); display: flex; gap: 0.2rem; margin-top: 1px;">
                                <span>${duration}s</span>
                                ${hasVideo ? '<span style="color: #10b981;"></span>' : '<span style="color: #f59e0b;">img</span>'}
                            </div>
                        </div>
                    </div>
                `;

                currentTime += duration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderCompactVoiceTrack(scriptScenes, animationScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 32px; position: relative; background: rgba(6, 182, 212, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach(sceneId => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const sceneDuration = scriptScene.duration || 8;
                const hasVoiceover = animScene?.voiceoverUrl;
                const voiceoverDuration = animScene?.voiceoverDuration || sceneDuration * 0.8;
                const width = voiceoverDuration * zoom;
                const x = currentTime * zoom;

                if (hasVoiceover) {
                    trackHtml += `
                        <div style="position: absolute; left: ${x}px; top: 4px; width: ${width}px; height: 24px; background: rgba(6, 182, 212, 0.3); border: 1px solid rgba(6, 182, 212, 0.5); border-radius: 2px; overflow: hidden;">
                            <svg width="100%" height="18" viewBox="0 0 100 18" preserveAspectRatio="none" style="opacity: 0.6; margin-top: 2px;">
                                ${generateSimpleWaveformPath()}
                            </svg>
                        </div>
                    `;
                }

                currentTime += sceneDuration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderCompactMusicTrack(totalDuration, zoom) {
            const musicEnabled = state.assembly.music?.enabled;
            const musicTrack = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music?.trackId);
            const width = totalDuration * zoom;

            let trackHtml = `<div style="height: 24px; position: relative; background: rgba(16, 185, 129, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            if (musicEnabled && musicTrack) {
                trackHtml += `
                    <div style="position: absolute; left: 0; top: 3px; width: ${width}px; height: 18px; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 2px; display: flex; align-items: center; padding: 0 0.4rem;">
                        <span style="font-size: 0.6rem; color: #10b981; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                             ${musicTrack.name || 'Music'}
                        </span>
                    </div>
                `;
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderCompactCaptionTrack(scriptScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);
            const captionsEnabled = state.assembly.captions?.enabled;

            let currentTime = 0;
            let trackHtml = `<div style="height: 24px; position: relative; background: rgba(245, 158, 11, 0.05);">`;

            if (captionsEnabled) {
                sceneOrder.forEach(sceneId => {
                    const scriptScene = scriptScenes.find(s => s.id === sceneId);
                    if (!scriptScene) return;

                    const duration = scriptScene.duration || 8;
                    const width = duration * zoom;
                    const x = currentTime * zoom;
                    const caption = scriptScene.narration?.substring(0, 15) || '';

                    trackHtml += `
                        <div style="position: absolute; left: ${x}px; top: 3px; width: ${width - 3}px; height: 18px; background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 2px; display: flex; align-items: center; padding: 0 0.25rem; overflow: hidden;">
                            <span style="font-size: 0.5rem; color: rgba(255,255,255,0.7); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${caption}${caption.length >= 15 ? '...' : ''}
                            </span>
                        </div>
                    `;

                    currentTime += duration;
                });
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function resetExport() {
            state.export = {
                status: null,
                progress: 0,
                outputUrl: null,
                error: null,
                selectedQuality: state.export.selectedQuality || '1080p'
            };
            render();
        }

        function renderStep7Export() {
            const exportState = state.export || {};
            const isExporting = exportState.status === 'exporting' || exportState.status === 'processing';
            const isCompleted = exportState.status === 'completed';
            const isFailed = exportState.status === 'failed' || exportState.status === 'error';
            const progress = exportState.progress || 0;

            // Calculate video summary
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const animatedCount = animationScenes.filter(s => s.videoUrl).length;
            const imageCount = storyboardScenes.filter(s => s.imageUrl).length;
            const totalDuration = scriptScenes.reduce((sum, s) => sum + (s.duration || 8), 0);
            const platform = PLATFORM_PRESETS[state.platform.selected] || {};

            let html = '<div class="fade-in">';

            // Header
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div style="flex: 1;">
                            <div class="content-card-title">Timeline Editor & Export</div>
                            <div class="content-card-subtitle">Fine-tune your video and export  ${formatDuration(totalDuration)}</div>
                        </div>
                    </div>
                </div>
            `;

            // Main content based on state
            if (isExporting) {
                html += renderExportProgress(exportState);
            } else if (isCompleted && exportState.outputUrl) {
                html += renderExportComplete(exportState);
            } else if (isFailed) {
                html += renderExportFailed(exportState);
            } else {
                // Show Timeline Editor + Export Settings
                html += renderTimelineEditor(scriptScenes, animationScenes, totalDuration);
                html += renderExportPanel(scriptScenes, animatedCount, imageCount, totalDuration, platform);
            }

            // Navigation (only back button on export step)
            html += `
                <div class="nav-buttons">
                    <button class="nav-button nav-button-back" onclick="goToStep(6)">
                        <span></span>
                        <span>Back</span>
                    </button>
                    <div></div>
                </div>
            `;

            html += '</div>';
            return html;
        }

        // ==========================================
        // TIMELINE EDITOR
        // ==========================================

        function renderTimelineEditor(scriptScenes, animationScenes, totalDuration) {
            const { zoom, scrollLeft, selectedClipId, snapToGrid } = state.timeline;
            const timelineWidth = totalDuration * zoom;
            const { isReady, isPlaying, currentTime } = state.preview;

            return `
                <div class="content-card" style="padding: 0; margin-top: 1rem; overflow: hidden;">
                    <!-- Preview + Controls Row -->
                    <div style="display: grid; grid-template-columns: 1fr 300px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <!-- Main Preview -->
                        <div style="padding: 1rem; background: #000;">
                            <div style="position: relative; width: 100%; aspect-ratio: 16/9; background: #111; border-radius: 0.5rem; overflow: hidden;">
                                <canvas id="timeline-preview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>

                                <!-- Play overlay -->
                                ${!isReady ? `
                                    <div style="position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.7);">
                                        <button onclick="initializeTimelinePreview()" style="padding: 1rem 2rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; font-size: 1rem;">
                                            <span style="font-size: 1.5rem;"></span> Load Preview
                                        </button>
                                    </div>
                                ` : (!isPlaying ? `
                                    <div onclick="toggleTimelinePlayback()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; cursor: pointer; background: rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0'">
                                        <div style="width: 70px; height: 70px; background: rgba(139, 92, 246, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(0,0,0,0.4);">
                                            <span style="font-size: 2rem; margin-left: 5px;"></span>
                                        </div>
                                    </div>
                                ` : '')}
                            </div>

                            <!-- Transport Controls -->
                            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 0.75rem; padding: 0 0.5rem;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <button onclick="seekTimelineStart()" ${!isReady ? 'disabled' : ''} style="width: 32px; height: 32px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                    <button onclick="toggleTimelinePlayback()" ${!isReady ? 'disabled' : ''} style="width: 40px; height: 40px; border-radius: 50%; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 1rem;">${isPlaying ? '' : ''}</button>
                                    <button onclick="seekTimelineEnd()" ${!isReady ? 'disabled' : ''} style="width: 32px; height: 32px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                </div>

                                <!-- Time Display -->
                                <div style="font-family: monospace; font-size: 1.1rem; color: white; background: rgba(0,0,0,0.5); padding: 0.4rem 0.75rem; border-radius: 0.25rem;">
                                    ${formatTimecode(currentTime)} <span style="color: rgba(255,255,255,0.4);">/</span> ${formatTimecode(totalDuration)}
                                </div>

                                <div style="flex: 1;"></div>

                                <!-- Volume -->
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.9rem;">${state.preview.volume > 0 ? '' : ''}</span>
                                    <input type="range" min="0" max="100" value="${state.preview.volume || 100}" onchange="setTimelineVolume(this.value)" style="width: 80px; height: 4px; cursor: pointer;">
                                </div>
                            </div>
                        </div>

                        <!-- Clip Inspector -->
                        ${renderClipInspector(selectedClipId, scriptScenes, animationScenes)}
                    </div>

                    <!-- Timeline Container -->
                    <div style="background: rgba(0,0,0,0.3);">
                        <!-- Timeline Header with Zoom Controls -->
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 1rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <div style="font-size: 0.85rem; font-weight: 600; color: white; display: flex; align-items: center; gap: 0.5rem;">
                                <span></span> Timeline
                            </div>
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <!-- Snap Toggle -->
                                <label style="display: flex; align-items: center; gap: 0.4rem; cursor: pointer; font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                                    <input type="checkbox" ${snapToGrid ? 'checked' : ''} onchange="toggleTimelineSnap(this.checked)" style="cursor: pointer;">
                                    Snap
                                </label>

                                <!-- Zoom Controls -->
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <button onclick="zoomTimeline(-10)" style="width: 24px; height: 24px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 0.9rem;"></button>
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6); min-width: 50px; text-align: center;">${zoom}px/s</span>
                                    <button onclick="zoomTimeline(10)" style="width: 24px; height: 24px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 0.9rem;">+</button>
                                </div>

                                <!-- Fit Button -->
                                <button onclick="fitTimelineToView()" style="padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 0.7rem;">Fit</button>
                            </div>
                        </div>

                        <!-- Edit Toolbar -->
                        ${renderEditToolbar()}

                        <!-- Timeline Tracks -->
                        <div id="timeline-scroll-container" style="overflow-x: auto; overflow-y: hidden;" onscroll="handleTimelineScroll(this)">
                            <div style="position: relative; min-width: ${Math.max(timelineWidth + 100, 800)}px;">
                                <!-- Time Ruler -->
                                ${renderTimeRuler(totalDuration, zoom)}

                                <!-- Playhead -->
                                <div id="timeline-playhead" style="position: absolute; top: 30px; left: ${80 + (currentTime * zoom)}px; width: 2px; height: calc(100% - 30px); background: #ef4444; z-index: 100; pointer-events: none;">
                                    <div style="position: absolute; top: -8px; left: -6px; width: 14px; height: 14px; background: #ef4444; border-radius: 2px; transform: rotate(45deg);"></div>
                                </div>

                                <!-- Track Labels + Tracks -->
                                <div style="display: flex;">
                                    <!-- Track Labels -->
                                    <div style="width: 80px; flex-shrink: 0; background: rgba(0,0,0,0.3); border-right: 1px solid rgba(255,255,255,0.1);">
                                        <div style="height: 60px; display: flex; align-items: center; padding-left: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.7); border-bottom: 1px solid rgba(255,255,255,0.05);"> Video</div>
                                        <div style="height: 40px; display: flex; align-items: center; padding-left: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.7); border-bottom: 1px solid rgba(255,255,255,0.05);"> Voice</div>
                                        <div style="height: 30px; display: flex; align-items: center; padding-left: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.7); border-bottom: 1px solid rgba(255,255,255,0.05);"> Music</div>
                                        <div style="height: 30px; display: flex; align-items: center; padding-left: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.7);"> Captions</div>
                                    </div>

                                    <!-- Tracks Content -->
                                    <div style="flex: 1; position: relative;">
                                        ${renderVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId)}
                                        ${renderVoiceTrack(scriptScenes, animationScenes, zoom)}
                                        ${renderMusicTrack(totalDuration, zoom)}
                                        ${renderCaptionTrack(scriptScenes, zoom)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderTimeRuler(totalDuration, zoom) {
            // Calculate tick interval based on zoom level
            let tickInterval = 1; // seconds
            if (zoom < 20) tickInterval = 10;
            else if (zoom < 40) tickInterval = 5;
            else if (zoom < 80) tickInterval = 2;
            else tickInterval = 1;

            let rulerHtml = `<div style="height: 30px; margin-left: 80px; background: rgba(0,0,0,0.4); border-bottom: 1px solid rgba(255,255,255,0.2); position: relative; cursor: pointer;" onclick="seekTimelineFromRuler(event)">`;

            for (let t = 0; t <= totalDuration; t += tickInterval) {
                const x = t * zoom;
                const isMajor = t % (tickInterval * 5) === 0 || tickInterval >= 5;
                rulerHtml += `
                    <div style="position: absolute; left: ${x}px; top: 0; height: ${isMajor ? '100%' : '50%'}; width: 1px; background: rgba(255,255,255,${isMajor ? '0.4' : '0.15'});"></div>
                    ${isMajor ? `<span style="position: absolute; left: ${x + 4}px; top: 4px; font-size: 0.65rem; color: rgba(255,255,255,0.6);">${formatTimecode(t)}</span>` : ''}
                `;
            }

            rulerHtml += `</div>`;
            return rulerHtml;
        }

        function renderVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 60px; position: relative; background: rgba(139, 92, 246, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const duration = scriptScene.duration || 8;
                const width = duration * zoom;
                const x = currentTime * zoom;
                const isSelected = selectedClipId === sceneId;
                const hasVideo = animScene?.videoUrl || (storyboardScene?.source === 'stock-video' && storyboardScene?.videoUrl);
                const imageUrl = storyboardScene?.imageUrl;

                trackHtml += `
                    <div class="timeline-clip" data-clip-id="${sceneId}"
                         onclick="selectTimelineClip(${sceneId}, 'video')"
                         onmousedown="startDragClip(${sceneId}, event)"
                         style="position: absolute; left: ${x}px; top: 4px; width: ${width - 2}px; height: 52px; background: ${isSelected ? 'rgba(139, 92, 246, 0.4)' : 'rgba(139, 92, 246, 0.2)'}; border: 2px solid ${isSelected ? '#8b5cf6' : 'rgba(139, 92, 246, 0.5)'}; border-radius: 4px; overflow: hidden; cursor: grab; display: flex; transition: all 0.15s;">
                        <!-- Thumbnail -->
                        <div style="width: 50px; height: 100%; flex-shrink: 0; background: rgba(0,0,0,0.3); pointer-events: none;">
                            ${imageUrl ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" draggable="false">` : ''}
                        </div>
                        <!-- Info -->
                        <div style="flex: 1; padding: 0.25rem 0.4rem; min-width: 0; pointer-events: none;">
                            <div style="font-size: 0.65rem; color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                Scene ${index + 1}
                            </div>
                            <div style="font-size: 0.55rem; color: rgba(255,255,255,0.6); display: flex; gap: 0.3rem; margin-top: 2px;">
                                <span>${duration}s</span>
                                ${hasVideo ? '<span style="color: #10b981;"></span>' : '<span style="color: #f59e0b;">img</span>'}
                            </div>
                        </div>
                        <!-- Resize Handles -->
                        ${isSelected ? `
                            <div class="clip-handle clip-handle-left" onmousedown="startTrimClip(${sceneId}, 'left', event)" style="position: absolute; left: 0; top: 0; width: 6px; height: 100%; background: #8b5cf6; cursor: ew-resize;"></div>
                            <div class="clip-handle clip-handle-right" onmousedown="startTrimClip(${sceneId}, 'right', event)" style="position: absolute; right: 0; top: 0; width: 6px; height: 100%; background: #8b5cf6; cursor: ew-resize;"></div>
                        ` : ''}
                    </div>
                `;

                currentTime += duration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderVoiceTrack(scriptScenes, animationScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 40px; position: relative; background: rgba(6, 182, 212, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach(sceneId => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const sceneDuration = scriptScene.duration || 8;
                const hasVoiceover = animScene?.voiceoverUrl;
                const voiceoverDuration = animScene?.voiceoverDuration || sceneDuration * 0.8;
                const width = voiceoverDuration * zoom;
                const x = currentTime * zoom;

                if (hasVoiceover) {
                    trackHtml += `
                        <div style="position: absolute; left: ${x}px; top: 6px; width: ${width}px; height: 28px; background: rgba(6, 182, 212, 0.3); border: 1px solid rgba(6, 182, 212, 0.5); border-radius: 3px; overflow: hidden;">
                            <!-- Waveform placeholder -->
                            <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
                                <svg width="100%" height="20" viewBox="0 0 100 20" preserveAspectRatio="none" style="opacity: 0.6;">
                                    ${generateSimpleWaveformPath()}
                                </svg>
                            </div>
                        </div>
                    `;
                }

                currentTime += sceneDuration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderMusicTrack(totalDuration, zoom) {
            const musicEnabled = state.assembly.music?.enabled;
            const musicTrack = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music?.trackId);
            const width = totalDuration * zoom;

            let trackHtml = `<div style="height: 30px; position: relative; background: rgba(16, 185, 129, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            if (musicEnabled && musicTrack) {
                trackHtml += `
                    <div style="position: absolute; left: 0; top: 4px; width: ${width}px; height: 22px; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 3px; display: flex; align-items: center; padding: 0 0.5rem;">
                        <span style="font-size: 0.65rem; color: #10b981; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                             ${musicTrack.name || 'Background Music'}
                        </span>
                    </div>
                `;
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderCaptionTrack(scriptScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);
            const captionsEnabled = state.assembly.captions?.enabled;

            let currentTime = 0;
            let trackHtml = `<div style="height: 30px; position: relative; background: rgba(245, 158, 11, 0.05);">`;

            if (captionsEnabled) {
                sceneOrder.forEach(sceneId => {
                    const scriptScene = scriptScenes.find(s => s.id === sceneId);
                    if (!scriptScene) return;

                    const duration = scriptScene.duration || 8;
                    const width = duration * zoom;
                    const x = currentTime * zoom;
                    const caption = scriptScene.narration?.substring(0, 20) || '';

                    trackHtml += `
                        <div style="position: absolute; left: ${x}px; top: 4px; width: ${width - 4}px; height: 22px; background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 3px; display: flex; align-items: center; padding: 0 0.3rem; overflow: hidden;">
                            <span style="font-size: 0.55rem; color: rgba(255,255,255,0.7); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${caption}${caption.length >= 20 ? '...' : ''}
                            </span>
                        </div>
                    `;

                    currentTime += duration;
                });
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderClipInspector(selectedClipId, scriptScenes, animationScenes) {
            if (!selectedClipId) {
                return `
                    <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-left: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Clip Inspector
                        </div>
                        <div style="text-align: center; padding: 2rem 1rem; color: rgba(255,255,255,0.4); font-size: 0.8rem;">
                            Select a clip to view details
                        </div>
                    </div>
                `;
            }

            const scriptScene = scriptScenes.find(s => s.id === selectedClipId);
            const animScene = animationScenes.find(s => s.sceneId === selectedClipId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === selectedClipId);
            const transition = state.assembly.transitions[selectedClipId] || { type: 'cut' };

            if (!scriptScene) return '';

            const sceneIndex = scriptScenes.findIndex(s => s.id === selectedClipId) + 1;

            return `
                <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-left: 1px solid rgba(255,255,255,0.1); overflow-y: auto;">
                    <div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Scene ${sceneIndex}
                    </div>

                    <!-- Thumbnail -->
                    <div style="width: 100%; aspect-ratio: 16/9; background: rgba(0,0,0,0.3); border-radius: 0.4rem; overflow: hidden; margin-bottom: 0.75rem;">
                        ${storyboardScene?.imageUrl ? `<img src="${storyboardScene.imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">` : '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3); font-size: 0.8rem;">No image</div>'}
                    </div>

                    <!-- Properties -->
                    <div style="display: flex; flex-direction: column; gap: 0.6rem; font-size: 0.75rem;">
                        <div>
                            <label style="color: rgba(255,255,255,0.5); display: block; margin-bottom: 0.2rem;">Duration</label>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="number" value="${scriptScene.duration || 8}" min="1" max="60" step="0.5"
                                       onchange="updateClipDuration(${selectedClipId}, this.value)"
                                       style="flex: 1; padding: 0.4rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: white; font-size: 0.8rem;">
                                <span style="color: rgba(255,255,255,0.5);">sec</span>
                            </div>
                        </div>

                        <div>
                            <label style="color: rgba(255,255,255,0.5); display: block; margin-bottom: 0.2rem;">Transition</label>
                            <select onchange="updateClipTransition(${selectedClipId}, this.value)"
                                    style="width: 100%; padding: 0.4rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: white; font-size: 0.8rem;">
                                ${(state.assembly.transitionTypes || []).map(t => `
                                    <option value="${t.id}" ${transition.type === t.id ? 'selected' : ''}>${t.name}</option>
                                `).join('')}
                            </select>
                        </div>

                        <div style="display: flex; gap: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="flex: 1;">
                                <span style="color: rgba(255,255,255,0.5);">Voiceover</span>
                                <div style="color: ${animScene?.voiceoverUrl ? '#10b981' : 'rgba(255,255,255,0.4)'}; margin-top: 0.2rem;">
                                    ${animScene?.voiceoverUrl ? ' Ready' : ' None'}
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <span style="color: rgba(255,255,255,0.5);">Video</span>
                                <div style="color: ${animScene?.videoUrl ? '#10b981' : (storyboardScene?.source === 'stock-video' ? '#06b6d4' : '#f59e0b')}; margin-top: 0.2rem;">
                                    ${animScene?.videoUrl ? ' Animated' : (storyboardScene?.source === 'stock-video' ? ' Stock' : ' Image')}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function generateSimpleWaveformPath() {
            // Generate a simple random waveform pattern
            let path = 'M0,10 ';
            for (let x = 0; x <= 100; x += 2) {
                const y = 10 + (Math.random() - 0.5) * 14;
                path += `L${x},${y} `;
            }
            return `<path d="${path}" fill="none" stroke="#06b6d4" stroke-width="1"/>`;
        }

        function formatTimecode(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const frames = Math.floor((seconds % 1) * 30);
            return `${mins}:${secs.toString().padStart(2, '0')}:${frames.toString().padStart(2, '0')}`;
        }

        function renderExportPanel(scriptScenes, animatedCount, imageCount, totalDuration, platform) {
            const selectedQuality = state.export.selectedQuality || '1080p';
            const canExport = animatedCount > 0 || imageCount > 0;
            const hasAllContent = animatedCount === scriptScenes.length || imageCount === scriptScenes.length;

            return `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                    <!-- Left: Video Summary -->
                    <div class="content-card" style="padding: 1rem;">
                        <div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Video Summary
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.8rem;">
                            <div style="padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.25rem;">
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Platform</div>
                                <div style="color: white;">${platform.icon || ''} ${platform.name || 'YouTube'}</div>
                            </div>
                            <div style="padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.25rem;">
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Duration</div>
                                <div style="color: white;">${formatDuration(totalDuration)}</div>
                            </div>
                            <div style="padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.25rem;">
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Images</div>
                                <div style="color: ${imageCount === scriptScenes.length ? '#10b981' : imageCount > 0 ? '#06b6d4' : '#f59e0b'};">${imageCount}/${scriptScenes.length}</div>
                            </div>
                            <div style="padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.25rem;">
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Animated</div>
                                <div style="color: ${animatedCount === scriptScenes.length ? '#10b981' : animatedCount > 0 ? '#06b6d4' : 'rgba(255,255,255,0.4)'};">${animatedCount}/${scriptScenes.length}</div>
                            </div>
                        </div>

                        ${!canExport ? `
                            <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.25rem; font-size: 0.75rem; color: #ef4444;">
                                Generate images in Storyboard step first
                            </div>
                        ` : animatedCount < scriptScenes.length ? `
                            <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(6, 182, 212, 0.1); border: 1px solid rgba(6, 182, 212, 0.3); border-radius: 0.25rem; font-size: 0.75rem; color: #06b6d4;">
                                ${animatedCount === 0 ? 'Using Ken Burns effect on images (animation optional)' : `${scriptScenes.length - animatedCount} scene(s) will use Ken Burns effect`}
                            </div>
                        ` : ''}
                    </div>

                    <!-- Right: Export Button -->
                    <div class="content-card" style="padding: 1rem;">
                        <div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Export Settings
                        </div>

                        <!-- Quality Selection (compact) -->
                        <div style="display: flex; gap: 0.4rem; margin-bottom: 0.75rem;">
                            ${Object.entries(EXPORT_QUALITIES).map(([id, q]) => `
                                <button onclick="setExportQuality('${id}')"
                                        style="flex: 1; padding: 0.5rem; border-radius: 0.4rem; border: 1px solid ${selectedQuality === id ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.15)'}; background: ${selectedQuality === id ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.03)'}; color: white; cursor: pointer; font-size: 0.75rem;">
                                    ${q.icon} ${id}
                                </button>
                            `).join('')}
                        </div>

                        <!-- Export Button -->
                        <button onclick="startExport()"
                                ${!canExport ? 'disabled' : ''}
                                style="width: 100%; padding: 0.9rem; border-radius: 0.5rem; border: none; background: ${canExport ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: ${canExport ? 'white' : 'rgba(255,255,255,0.4)'}; font-size: 0.95rem; font-weight: 700; cursor: ${canExport ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <span></span> Export Video
                        </button>
                    </div>
                </div>
            `;
        }

        // ==========================================
        // TIMELINE CONTROL FUNCTIONS
        // ==========================================

        async function initializeTimelinePreview() {
            const canvas = document.getElementById('timeline-preview-canvas');
            if (!canvas) {
                console.error('Timeline preview canvas not found');
                return;
            }

            // Reuse the preview engine from Assembly step or create new one
            state.preview.loadProgress = 1;
            render();

            // Create the engine if it doesn't exist
            if (!previewEngine) {
                previewEngine = new VideoPreviewEngine(canvas, {
                    width: 1280,
                    height: 720,
                    onTimeUpdate: (time) => {
                        state.preview.currentTime = time;
                        updateTimelinePlayhead(time);
                    },
                    onSceneChange: (sceneIndex) => {
                        state.preview.currentSceneIndex = sceneIndex;
                    },
                    onEnded: () => {
                        state.preview.isPlaying = false;
                        state.preview.currentTime = 0;
                        render();
                    },
                    onLoadProgress: (progress) => {
                        state.preview.loadProgress = progress;
                        render();
                    },
                    onReady: () => {
                        state.preview.isReady = true;
                        state.preview.loadProgress = 100;
                        state.timeline.isInitialized = true;
                        render();
                    }
                });

                const scenes = buildPreviewScenes();
                state.preview.totalDuration = scenes.reduce((sum, s) => sum + (s.duration || 8), 0);

                try {
                    await previewEngine.loadScenes(scenes);
                    previewEngine.captionsEnabled = state.assembly.captions?.enabled;
                    previewEngine.captionStyle = state.assembly.captions?.style;
                    previewEngine.captionPosition = state.assembly.captions?.position;
                    previewEngine.captionSize = state.assembly.captions?.size || 1;

                    if (state.assembly.music?.enabled && state.assembly.music?.trackId) {
                        const track = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music?.trackId);
                        const audioUrl = track?.url || track?.previewUrl;
                        if (audioUrl) {
                            await previewEngine.setBackgroundMusic(audioUrl, state.assembly.music.volume / 100);
                        }
                    }
                } catch (error) {
                    console.error('Failed to initialize timeline preview:', error);
                    showToast('Failed to load preview', 'error');
                    state.preview.loadProgress = 0;
                    render();
                }
            } else {
                // Engine already exists, just update canvas reference
                previewEngine.canvas = canvas;
                previewEngine.ctx = canvas.getContext('2d');
                previewEngine._renderFrame();
                state.preview.isReady = true;
                state.timeline.isInitialized = true;
                render();
            }
        }

        function toggleTimelinePlayback() {
            if (!previewEngine || !state.preview.isReady) return;

            if (state.preview.isPlaying) {
                previewEngine.pause();
                state.preview.isPlaying = false;
            } else {
                previewEngine.play();
                state.preview.isPlaying = true;
            }
            render();
        }

        function seekTimelineStart() {
            if (!previewEngine || !state.preview.isReady) return;
            previewEngine.seek(0);
            state.preview.currentTime = 0;
            updateTimelinePlayhead(0);
        }

        function seekTimelineEnd() {
            if (!previewEngine || !state.preview.isReady) return;
            const endTime = state.preview.totalDuration - 0.1;
            previewEngine.seek(endTime);
            state.preview.currentTime = endTime;
            updateTimelinePlayhead(endTime);
        }

        function seekTimelineFromRuler(event) {
            if (!previewEngine || !state.preview.isReady) return;

            const ruler = event.currentTarget;
            const rect = ruler.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const time = x / state.timeline.zoom;
            const clampedTime = Math.max(0, Math.min(time, state.preview.totalDuration));

            previewEngine.seek(clampedTime);
            state.preview.currentTime = clampedTime;
            updateTimelinePlayhead(clampedTime);
        }

        function setTimelineVolume(volume) {
            state.preview.volume = parseInt(volume);
            if (previewEngine) {
                previewEngine.voiceVolume = volume / 100;
            }
        }

        function zoomTimeline(delta) {
            const newZoom = Math.max(10, Math.min(200, state.timeline.zoom + delta));
            state.timeline.zoom = newZoom;
            render();
        }

        function fitTimelineToView() {
            const container = document.getElementById('timeline-scroll-container');
            if (!container) return;

            const containerWidth = container.clientWidth - 100; // Account for labels
            const totalDuration = state.preview.totalDuration || state.script.scenes.reduce((sum, s) => sum + (s.duration || 8), 0);

            if (totalDuration > 0) {
                state.timeline.zoom = Math.max(10, Math.floor(containerWidth / totalDuration));
                render();
            }
        }

        function toggleTimelineSnap(enabled) {
            state.timeline.snapToGrid = enabled;
        }

        function handleTimelineScroll(container) {
            state.timeline.scrollLeft = container.scrollLeft;
        }

        function selectTimelineClip(clipId, track) {
            state.timeline.selectedClipId = clipId;
            state.timeline.selectedTrack = track;

            // Also seek to the clip's start time
            if (previewEngine && state.preview.isReady) {
                const scene = previewEngine.scenes.find(s => s.id === clipId);
                if (scene) {
                    previewEngine.seek(scene.startTime);
                    state.preview.currentTime = scene.startTime;
                    updateTimelinePlayhead(scene.startTime);
                }
            }

            render();
        }

        function updateClipDuration(clipId, newDuration) {
            const duration = parseFloat(newDuration);
            if (isNaN(duration) || duration < 1 || duration > 60) return;

            const scene = state.script.scenes.find(s => s.id === clipId);
            if (scene) {
                scene.duration = duration;
                saveProject();

                // Update preview engine if initialized
                if (previewEngine && state.preview.isReady) {
                    const previewScene = previewEngine.scenes.find(s => s.id === clipId);
                    if (previewScene) {
                        previewScene.duration = duration;
                        previewEngine._calculateTiming();
                    }
                    state.preview.totalDuration = previewEngine.totalDuration;
                }

                render();
            }
        }

        function updateClipTransition(clipId, transitionType) {
            state.assembly.transitions[clipId] = { type: transitionType };
            saveProject();

            // Update preview engine
            if (previewEngine && state.preview.isReady) {
                const scene = previewEngine.scenes.find(s => s.id === clipId);
                if (scene) {
                    scene.transition = transitionType;
                }
            }

            render();
        }

        function updateTimelinePlayhead(time) {
            const playhead = document.getElementById('timeline-playhead');
            if (playhead) {
                const x = 80 + (time * state.timeline.zoom);
                playhead.style.left = `${x}px`;
            }

            // Auto-scroll timeline to keep playhead visible
            const container = document.getElementById('timeline-scroll-container');
            if (container && state.preview.isPlaying) {
                const playheadX = time * state.timeline.zoom;
                const scrollLeft = container.scrollLeft;
                const containerWidth = container.clientWidth - 80;

                if (playheadX < scrollLeft || playheadX > scrollLeft + containerWidth - 50) {
                    container.scrollLeft = Math.max(0, playheadX - 100);
                }
            }
        }

        // ==========================================
        // TIMELINE EDITING OPERATIONS
        // ==========================================

        // Edit History for Undo/Redo
        class EditHistory {
            constructor(maxHistory = 50) {
                this.history = [];
                this.position = -1;
                this.maxHistory = maxHistory;
            }

            push(state) {
                // Remove any redo history
                this.history = this.history.slice(0, this.position + 1);
                this.history.push(JSON.parse(JSON.stringify(state)));
                this.position++;

                // Limit history size
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.position--;
                }
            }

            undo() {
                if (this.position > 0) {
                    this.position--;
                    return JSON.parse(JSON.stringify(this.history[this.position]));
                }
                return null;
            }

            redo() {
                if (this.position < this.history.length - 1) {
                    this.position++;
                    return JSON.parse(JSON.stringify(this.history[this.position]));
                }
                return null;
            }

            canUndo() {
                return this.position > 0;
            }

            canRedo() {
                return this.position < this.history.length - 1;
            }
        }

        const editHistory = new EditHistory();

        function saveEditState() {
            editHistory.push({
                scenes: state.script.scenes,
                sceneOrder: state.assembly.sceneOrder,
                transitions: state.assembly.transitions
            });
        }

        function undoEdit() {
            const previousState = editHistory.undo();
            if (previousState) {
                state.script.scenes = previousState.scenes;
                state.assembly.sceneOrder = previousState.sceneOrder;
                state.assembly.transitions = previousState.transitions;
                saveProject();
                rebuildPreviewScenes();
                render();
                showToast('Undo', 'info');
            }
        }

        function redoEdit() {
            const nextState = editHistory.redo();
            if (nextState) {
                state.script.scenes = nextState.scenes;
                state.assembly.sceneOrder = nextState.sceneOrder;
                state.assembly.transitions = nextState.transitions;
                saveProject();
                rebuildPreviewScenes();
                render();
                showToast('Redo', 'info');
            }
        }

        function rebuildPreviewScenes() {
            if (previewEngine && state.preview.isReady) {
                const scenes = buildPreviewScenes();
                state.preview.totalDuration = scenes.reduce((sum, s) => sum + (s.duration || 8), 0);
                previewEngine.scenes = scenes.map((scene, index) => ({
                    ...scene,
                    index,
                    startTime: 0,
                    endTime: 0
                }));
                previewEngine._calculateTiming();
            }
        }

        // Split clip at playhead
        function splitClipAtPlayhead() {
            if (!state.preview.isReady) return;

            const currentTime = state.preview.currentTime;
            const scenes = previewEngine?.scenes || [];

            // Find which scene contains the current time
            const sceneIndex = scenes.findIndex(s =>
                currentTime >= s.startTime && currentTime < s.startTime + s.duration
            );

            if (sceneIndex === -1) return;

            const scene = scenes[sceneIndex];
            const splitPoint = currentTime - scene.startTime;

            // Don't split if too close to edges
            if (splitPoint < 1 || splitPoint > scene.duration - 1) {
                showToast('Cannot split here - too close to edge', 'warning');
                return;
            }

            saveEditState();

            // Find the original scene
            const originalScene = state.script.scenes.find(s => s.id === scene.id);
            if (!originalScene) return;

            // Create new scene ID
            const newSceneId = Math.max(...state.script.scenes.map(s => s.id)) + 1;

            // Create the new scene (second half)
            const newScene = {
                ...JSON.parse(JSON.stringify(originalScene)),
                id: newSceneId,
                duration: originalScene.duration - splitPoint
            };

            // Update original scene duration (first half)
            originalScene.duration = splitPoint;

            // Add new scene to script
            const originalIndex = state.script.scenes.findIndex(s => s.id === scene.id);
            state.script.scenes.splice(originalIndex + 1, 0, newScene);

            // Update scene order
            const orderIndex = state.assembly.sceneOrder.indexOf(scene.id);
            if (orderIndex !== -1) {
                state.assembly.sceneOrder.splice(orderIndex + 1, 0, newSceneId);
            } else {
                state.assembly.sceneOrder = state.script.scenes.map(s => s.id);
            }

            // Copy storyboard data for new scene
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === scene.id);
            if (storyboardScene) {
                state.storyboard.scenes.push({
                    ...JSON.parse(JSON.stringify(storyboardScene)),
                    sceneId: newSceneId
                });
            }

            // Copy animation data for new scene
            const animScene = state.animation.scenes.find(s => s.sceneId === scene.id);
            if (animScene) {
                state.animation.scenes.push({
                    ...JSON.parse(JSON.stringify(animScene)),
                    sceneId: newSceneId
                });
            }

            saveProject();
            rebuildPreviewScenes();
            render();
            showToast('Clip split at playhead', 'success');
        }

        // Delete selected clip
        function deleteSelectedClip() {
            const clipId = state.timeline.selectedClipId;
            if (!clipId) {
                showToast('No clip selected', 'warning');
                return;
            }

            // Prevent deleting if only one scene
            if (state.script.scenes.length <= 1) {
                showToast('Cannot delete the only scene', 'warning');
                return;
            }

            saveEditState();

            // Remove from script scenes
            state.script.scenes = state.script.scenes.filter(s => s.id !== clipId);

            // Remove from scene order
            state.assembly.sceneOrder = state.assembly.sceneOrder.filter(id => id !== clipId);
            if (state.assembly.sceneOrder.length === 0) {
                state.assembly.sceneOrder = state.script.scenes.map(s => s.id);
            }

            // Remove from storyboard
            state.storyboard.scenes = state.storyboard.scenes.filter(s => s.sceneId !== clipId);

            // Remove from animation
            state.animation.scenes = state.animation.scenes.filter(s => s.sceneId !== clipId);

            // Remove transition
            delete state.assembly.transitions[clipId];

            // Clear selection
            state.timeline.selectedClipId = null;

            saveProject();
            rebuildPreviewScenes();
            render();
            showToast('Clip deleted', 'success');
        }

        // Duplicate selected clip
        function duplicateSelectedClip() {
            const clipId = state.timeline.selectedClipId;
            if (!clipId) {
                showToast('No clip selected', 'warning');
                return;
            }

            saveEditState();

            const originalScene = state.script.scenes.find(s => s.id === clipId);
            if (!originalScene) return;

            // Create new scene ID
            const newSceneId = Math.max(...state.script.scenes.map(s => s.id)) + 1;

            // Create duplicate scene
            const newScene = {
                ...JSON.parse(JSON.stringify(originalScene)),
                id: newSceneId
            };

            // Add after original in script
            const originalIndex = state.script.scenes.findIndex(s => s.id === clipId);
            state.script.scenes.splice(originalIndex + 1, 0, newScene);

            // Add after original in order
            const orderIndex = state.assembly.sceneOrder.indexOf(clipId);
            if (orderIndex !== -1) {
                state.assembly.sceneOrder.splice(orderIndex + 1, 0, newSceneId);
            } else {
                state.assembly.sceneOrder = state.script.scenes.map(s => s.id);
            }

            // Copy storyboard data
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === clipId);
            if (storyboardScene) {
                state.storyboard.scenes.push({
                    ...JSON.parse(JSON.stringify(storyboardScene)),
                    sceneId: newSceneId
                });
            }

            // Copy animation data
            const animScene = state.animation.scenes.find(s => s.sceneId === clipId);
            if (animScene) {
                state.animation.scenes.push({
                    ...JSON.parse(JSON.stringify(animScene)),
                    sceneId: newSceneId
                });
            }

            // Copy transition
            const transition = state.assembly.transitions[clipId];
            if (transition) {
                state.assembly.transitions[newSceneId] = { ...transition };
            }

            // Select the new clip
            state.timeline.selectedClipId = newSceneId;

            saveProject();
            rebuildPreviewScenes();
            render();
            showToast('Clip duplicated', 'success');
        }

        // Move clip in order (reorder)
        function moveClipInTimeline(clipId, direction) {
            const order = state.assembly.sceneOrder.length > 0
                ? [...state.assembly.sceneOrder]
                : state.script.scenes.map(s => s.id);

            const currentIndex = order.indexOf(clipId);
            const newIndex = currentIndex + direction;

            if (newIndex < 0 || newIndex >= order.length) return;

            saveEditState();

            // Swap positions
            [order[currentIndex], order[newIndex]] = [order[newIndex], order[currentIndex]];
            state.assembly.sceneOrder = order;

            saveProject();
            rebuildPreviewScenes();
            render();
        }

        // Trim clip (adjust duration)
        let trimState = null;

        function startTrimClip(clipId, handle, event) {
            event.stopPropagation();
            event.preventDefault();

            const scene = state.script.scenes.find(s => s.id === clipId);
            if (!scene) return;

            saveEditState();

            trimState = {
                clipId,
                handle, // 'left' or 'right'
                startX: event.clientX,
                originalDuration: scene.duration || 8,
                minDuration: 1,
                maxDuration: 60
            };

            document.addEventListener('mousemove', handleTrimMove);
            document.addEventListener('mouseup', handleTrimEnd);
        }

        function handleTrimMove(event) {
            if (!trimState) return;

            const deltaX = event.clientX - trimState.startX;
            const deltaTime = deltaX / state.timeline.zoom;

            let newDuration;
            if (trimState.handle === 'right') {
                newDuration = trimState.originalDuration + deltaTime;
            } else {
                // Left handle - trimming from start would need more complex logic
                // For now, just adjust duration
                newDuration = trimState.originalDuration - deltaTime;
            }

            // Clamp duration
            newDuration = Math.max(trimState.minDuration, Math.min(trimState.maxDuration, newDuration));

            // Update scene duration
            const scene = state.script.scenes.find(s => s.id === trimState.clipId);
            if (scene) {
                scene.duration = Math.round(newDuration * 10) / 10; // Round to 0.1s
                rebuildPreviewScenes();
                render();
            }
        }

        function handleTrimEnd() {
            if (trimState) {
                saveProject();
                showToast('Clip trimmed', 'success');
            }
            trimState = null;
            document.removeEventListener('mousemove', handleTrimMove);
            document.removeEventListener('mouseup', handleTrimEnd);
        }

        // Drag to reorder clips
        let dragState = null;

        function startDragClip(clipId, event) {
            // Don't start drag if clicking on handles
            if (event.target.classList.contains('clip-handle')) return;

            event.preventDefault();

            dragState = {
                clipId,
                startX: event.clientX,
                startY: event.clientY,
                isDragging: false
            };

            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
        }

        function handleDragMove(event) {
            if (!dragState) return;

            const deltaX = Math.abs(event.clientX - dragState.startX);
            const deltaY = Math.abs(event.clientY - dragState.startY);

            // Start dragging after moving 5px
            if (!dragState.isDragging && (deltaX > 5 || deltaY > 5)) {
                dragState.isDragging = true;
                document.body.style.cursor = 'grabbing';
            }

            if (dragState.isDragging) {
                // Show drop indicator
                updateDropIndicator(event);
            }
        }

        function handleDragEnd(event) {
            if (dragState && dragState.isDragging) {
                // Calculate drop position
                const dropIndex = calculateDropIndex(event);
                if (dropIndex !== -1) {
                    reorderClip(dragState.clipId, dropIndex);
                }
            }

            // Cleanup
            document.body.style.cursor = '';
            removeDropIndicator();
            dragState = null;
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
        }

        function updateDropIndicator(event) {
            // Get timeline container
            const container = document.querySelector('#timeline-scroll-container');
            if (!container) return;

            const rect = container.getBoundingClientRect();
            const x = event.clientX - rect.left + container.scrollLeft - 80;

            // Calculate which position this corresponds to
            let indicator = document.getElementById('drop-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'drop-indicator';
                indicator.style.cssText = 'position: absolute; top: 34px; width: 3px; height: 56px; background: #8b5cf6; z-index: 200; pointer-events: none; border-radius: 2px;';
                container.querySelector('div').appendChild(indicator);
            }

            // Find the x position to show indicator
            const order = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : state.script.scenes.map(s => s.id);

            let accumulatedX = 0;
            let indicatorX = 0;

            for (let i = 0; i <= order.length; i++) {
                if (i < order.length) {
                    const scene = state.script.scenes.find(s => s.id === order[i]);
                    const width = (scene?.duration || 8) * state.timeline.zoom;

                    if (x < accumulatedX + width / 2) {
                        indicatorX = accumulatedX;
                        break;
                    }
                    accumulatedX += width;
                } else {
                    indicatorX = accumulatedX;
                }
            }

            indicator.style.left = `${80 + indicatorX}px`;
        }

        function removeDropIndicator() {
            const indicator = document.getElementById('drop-indicator');
            if (indicator) indicator.remove();
        }

        function calculateDropIndex(event) {
            const container = document.querySelector('#timeline-scroll-container');
            if (!container) return -1;

            const rect = container.getBoundingClientRect();
            const x = event.clientX - rect.left + container.scrollLeft - 80;

            const order = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : state.script.scenes.map(s => s.id);

            let accumulatedX = 0;

            for (let i = 0; i <= order.length; i++) {
                if (i < order.length) {
                    const scene = state.script.scenes.find(s => s.id === order[i]);
                    const width = (scene?.duration || 8) * state.timeline.zoom;

                    if (x < accumulatedX + width / 2) {
                        return i;
                    }
                    accumulatedX += width;
                } else {
                    return order.length;
                }
            }

            return order.length;
        }

        function reorderClip(clipId, newIndex) {
            const order = state.assembly.sceneOrder.length > 0
                ? [...state.assembly.sceneOrder]
                : state.script.scenes.map(s => s.id);

            const currentIndex = order.indexOf(clipId);
            if (currentIndex === -1 || currentIndex === newIndex || currentIndex === newIndex - 1) return;

            saveEditState();

            // Remove from current position
            order.splice(currentIndex, 1);

            // Adjust new index if we removed from before it
            const adjustedIndex = currentIndex < newIndex ? newIndex - 1 : newIndex;

            // Insert at new position
            order.splice(adjustedIndex, 0, clipId);

            state.assembly.sceneOrder = order;
            saveProject();
            rebuildPreviewScenes();
            render();
            showToast('Clip reordered', 'success');
        }

        // Add edit toolbar to timeline header
        function renderEditToolbar() {
            const hasSelection = state.timeline.selectedClipId !== null;
            const canUndo = editHistory.canUndo();
            const canRedo = editHistory.canRedo();

            return `
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: rgba(0,0,0,0.2); border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <!-- Undo/Redo -->
                    <button onclick="undoEdit()" ${!canUndo ? 'disabled' : ''} title="Undo (Ctrl+Z)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${canUndo ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${canUndo ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Undo
                    </button>
                    <button onclick="redoEdit()" ${!canRedo ? 'disabled' : ''} title="Redo (Ctrl+Y)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${canRedo ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${canRedo ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Redo
                    </button>

                    <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2); margin: 0 0.25rem;"></div>

                    <!-- Clip Operations -->
                    <button onclick="splitClipAtPlayhead()" ${!state.preview.isReady ? 'disabled' : ''} title="Split at Playhead (S)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${state.preview.isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${state.preview.isReady ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Split
                    </button>
                    <button onclick="duplicateSelectedClip()" ${!hasSelection ? 'disabled' : ''} title="Duplicate (Ctrl+D)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${hasSelection ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${hasSelection ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Duplicate
                    </button>
                    <button onclick="deleteSelectedClip()" ${!hasSelection ? 'disabled' : ''} title="Delete (Del)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid ${hasSelection ? 'rgba(239, 68, 68, 0.4)' : 'rgba(255,255,255,0.2)'}; background: ${hasSelection ? 'rgba(239, 68, 68, 0.1)' : 'transparent'}; color: ${hasSelection ? '#ef4444' : 'rgba(255,255,255,0.3)'}; cursor: ${hasSelection ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Delete
                    </button>

                    <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2); margin: 0 0.25rem;"></div>

                    <!-- Move -->
                    <button onclick="moveClipInTimeline(state.timeline.selectedClipId, -1)" ${!hasSelection ? 'disabled' : ''} title="Move Left"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${hasSelection ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${hasSelection ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Move
                    </button>
                    <button onclick="moveClipInTimeline(state.timeline.selectedClipId, 1)" ${!hasSelection ? 'disabled' : ''} title="Move Right"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${hasSelection ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${hasSelection ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                        Move 
                    </button>
                </div>
            `;
        }

        function renderExportSettings(scriptScenes, animatedCount, totalDuration, platform) {
            const selectedQuality = state.export.selectedQuality || '1080p';
            const selectedRenderQuality = state.export.selectedRenderQuality || 'balanced';

            // Render quality options for speed vs quality tradeoff
            const RENDER_QUALITY_OPTIONS = {
                fast: {
                    name: 'Fast',
                    icon: '',
                    description: 'Quick export (~50% faster)',
                    time: Math.ceil(totalDuration * 0.8 / 60)
                },
                balanced: {
                    name: 'Balanced',
                    icon: '',
                    description: 'Good speed & quality (recommended)',
                    time: Math.ceil(totalDuration * 1.5 / 60)
                },
                best: {
                    name: 'Best Quality',
                    icon: '',
                    description: 'Highest quality, slower',
                    time: Math.ceil(totalDuration * 3 / 60)
                }
            };

            return `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                    <!-- Left: Video Summary -->
                    <div class="content-card" style="padding: 1.25rem;">
                        <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Video Summary
                        </div>

                        <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Platform</span>
                                <span style="color: white; font-size: 0.85rem;">${platform.icon || ''} ${platform.name || 'YouTube'}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Aspect Ratio</span>
                                <span style="color: white; font-size: 0.85rem;">${state.platform.aspectRatio || '16:9'}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Total Scenes</span>
                                <span style="color: white; font-size: 0.85rem;">${scriptScenes.length} scenes</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Animated Scenes</span>
                                <span style="color: ${animatedCount === scriptScenes.length ? '#10b981' : '#f59e0b'}; font-size: 0.85rem;">
                                    ${animatedCount}/${scriptScenes.length} ${animatedCount === scriptScenes.length ? '' : ''}
                                </span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Duration</span>
                                <span style="color: white; font-size: 0.85rem;">${formatDuration(totalDuration)}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Background Music</span>
                                <span style="color: white; font-size: 0.85rem;">${state.assembly.music?.enabled ? ' Enabled' : ' Disabled'}</span>
                            </div>
                        </div>

                        ${animatedCount < scriptScenes.length ? `
                            <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 0.5rem;">
                                <div style="font-size: 0.8rem; color: #f59e0b;">
                                     ${scriptScenes.length - animatedCount} scene(s) don't have animated videos. They will use static images.
                                </div>
                            </div>
                        ` : ''}
                    </div>

                    <!-- Right: Export Settings -->
                    <div class="content-card" style="padding: 1.25rem;">
                        <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Export Settings
                        </div>

                        <!-- Quality Selection -->
                        <div style="margin-bottom: 1.25rem;">
                            <label style="display: block; font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Video Quality</label>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                ${Object.entries(EXPORT_QUALITIES).map(([id, q]) => `
                                    <button onclick="setExportQuality('${id}')"
                                            style="padding: 0.75rem; border-radius: 0.5rem; border: 1px solid ${selectedQuality === id ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.15)'}; background: ${selectedQuality === id ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.03)'}; color: white; cursor: pointer; text-align: left; display: flex; align-items: center; gap: 0.75rem;">
                                        <span style="font-size: 1.25rem;">${q.icon}</span>
                                        <div>
                                            <div style="font-size: 0.9rem; font-weight: 600;">${q.name}</div>
                                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">${q.description}</div>
                                        </div>
                                        ${selectedQuality === id ? '<span style="margin-left: auto; color: #8b5cf6;"></span>' : ''}
                                    </button>
                                `).join('')}
                            </div>
                        </div>

                        <!-- Render Speed Selection -->
                        <div style="margin-bottom: 1.25rem;">
                            <label style="display: block; font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Render Speed</label>
                            <div style="display: flex; gap: 0.5rem;">
                                ${Object.entries(RENDER_QUALITY_OPTIONS).map(([id, rq]) => `
                                    <button onclick="setRenderQuality('${id}')"
                                            style="flex: 1; padding: 0.6rem 0.5rem; border-radius: 0.5rem; border: 1px solid ${selectedRenderQuality === id ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.15)'}; background: ${selectedRenderQuality === id ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.03)'}; color: white; cursor: pointer; text-align: center;">
                                        <div style="font-size: 1.1rem;">${rq.icon}</div>
                                        <div style="font-size: 0.8rem; font-weight: 600; margin-top: 0.25rem;">${rq.name}</div>
                                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-top: 0.15rem;">~${rq.time} min</div>
                                    </button>
                                `).join('')}
                            </div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-top: 0.5rem; text-align: center;">
                                ${RENDER_QUALITY_OPTIONS[selectedRenderQuality].description}
                            </div>
                        </div>

                        <!-- Estimated Info -->
                        <div style="padding: 0.75rem; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem; margin-bottom: 1.25rem;">
                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.25rem;">Estimated Processing Time</div>
                            <div style="font-size: 1rem; color: white; font-weight: 600;">~${Math.ceil(totalDuration * 2 / 60)} minutes</div>
                        </div>

                        <!-- Export Button -->
                        <button onclick="startExport()"
                                ${animatedCount === 0 ? 'disabled' : ''}
                                style="width: 100%; padding: 1rem; border-radius: 0.75rem; border: none; background: ${animatedCount > 0 ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: ${animatedCount > 0 ? 'white' : 'rgba(255,255,255,0.4)'}; font-size: 1rem; font-weight: 700; cursor: ${animatedCount > 0 ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <span></span>
                            <span>Start Export</span>
                        </button>

                        ${animatedCount === 0 ? `
                            <div style="text-align: center; margin-top: 0.75rem; font-size: 0.8rem; color: rgba(255,255,255,0.5);">
                                Complete the Animation step before exporting
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function renderExportProgress(exportState) {
            const progress = exportState.progress || 0;
            const currentStage = exportState.currentStage || 'Starting export...';
            const scenesCompleted = exportState.scenesCompleted || 0;
            const scenesTotal = exportState.scenesTotal || 0;
            const sceneStatuses = exportState.sceneStatuses || [];

            // Render scene indicators if we have scene data
            let sceneIndicatorsHtml = '';
            if (scenesTotal > 0) {
                sceneIndicatorsHtml = `
                    <div style="display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
                        ${Array.from({ length: scenesTotal }, (_, i) => {
                            const sceneStatus = sceneStatuses[i];
                            const status = sceneStatus?.status || 'queued';
                            const isComplete = status === 'complete';
                            const isFailed = status === 'failed';
                            const isRendering = status === 'rendering';
                            const isQueued = status === 'queued' || status === 'processing';

                            let bgColor = 'rgba(255,255,255,0.1)'; // queued (dimmed)
                            let icon = (i + 1);
                            let extraStyle = '';

                            if (isComplete) {
                                bgColor = 'rgba(34, 197, 94, 0.4)';
                                icon = '';
                                extraStyle = 'border: 2px solid rgba(34, 197, 94, 0.6);';
                            } else if (isFailed) {
                                bgColor = 'rgba(239, 68, 68, 0.4)';
                                icon = '';
                                extraStyle = 'border: 2px solid rgba(239, 68, 68, 0.6);';
                            } else if (isRendering) {
                                bgColor = 'rgba(139, 92, 246, 0.4)';
                                extraStyle = 'animation: pulse 2s infinite; border: 2px solid rgba(139, 92, 246, 0.6);';
                            }

                            return `
                                <div style="width: 2.5rem; height: 2.5rem; border-radius: 50%; background: ${bgColor};
                                            display: flex; align-items: center; justify-content: center;
                                            font-size: 0.85rem; font-weight: 600; color: white;
                                            transition: all 0.3s ease; ${extraStyle}">
                                    ${icon}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="color: rgba(255,255,255,0.6); font-size: 0.85rem; margin-bottom: 1rem;">
                        ${scenesCompleted} of ${scenesTotal} scenes complete
                    </div>
                `;
            }

            return `
                <div class="content-card" style="text-align: center; padding: 3rem 2rem; margin-top: 1rem;">
                    <div style="font-size: 4rem; margin-bottom: 1.5rem;">
                        <div class="animate-pulse" style="display: inline-block;"></div>
                    </div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                        Rendering Your Video
                    </div>
                    <div id="export-stage-text" style="color: rgba(255,255,255,0.7); margin-bottom: 1.5rem; font-size: 1rem;">
                        ${currentStage}
                    </div>

                    <!-- Scene Indicators -->
                    ${sceneIndicatorsHtml}

                    <!-- Progress Bar -->
                    <div style="width: 100%; max-width: 400px; margin: 0 auto 1.5rem;">
                        <div style="height: 12px; background: rgba(255,255,255,0.1); border-radius: 6px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);">
                            <div id="export-progress-bar" style="height: 100%; width: ${progress}%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); border-radius: 6px; transition: width 0.5s ease; box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 0.75rem; font-size: 0.9rem;">
                            <span style="color: rgba(255,255,255,0.5);">Progress</span>
                            <span id="export-progress-text" style="color: #8b5cf6; font-weight: 700;">${progress}%</span>
                        </div>
                    </div>

                    <!-- Processing indicator -->
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-bottom: 1.5rem;">
                        <div class="animate-spin" style="width: 1rem; height: 1rem; border: 2px solid rgba(139, 92, 246, 0.3); border-top-color: #8b5cf6; border-radius: 50%;"></div>
                        <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Processing on server...</span>
                    </div>

                    <!-- Cancel Button -->
                    <button onclick="cancelExport()"
                            style="padding: 0.6rem 1.5rem; border-radius: 0.5rem; border: 1px solid rgba(239, 68, 68, 0.4); background: rgba(239, 68, 68, 0.1); color: #ef4444; cursor: pointer; font-size: 0.85rem;">
                        Cancel Export
                    </button>

                    <div style="margin-top: 1.5rem; color: rgba(255,255,255,0.4); font-size: 0.75rem;">
                        Please don't close this page while exporting
                    </div>
                </div>
            `;
        }

        function renderExportComplete(exportState) {
            const outputUrl = exportState.outputUrl;
            const fileName = exportState.fileName || 'video.webm';
            const hasVideo = outputUrl && outputUrl.length > 0;

            // Calculate video stats
            const totalScenes = state.script.scenes?.length || 0;
            const totalDuration = state.script.scenes?.reduce((sum, s) => sum + (s.duration || 8), 0) || 0;

            return `
                <div class="content-card" style="text-align: center; padding: 3rem 2rem; margin-top: 1rem;">
                    <div style="font-size: 4rem; margin-bottom: 1.5rem;"></div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                        Video Export Complete!
                    </div>
                    <div style="color: rgba(255,255,255,0.6); margin-bottom: 1.5rem;">
                        Your video is ready to download and share
                    </div>

                    <!-- Video Preview -->
                    ${hasVideo ? `
                        <div style="max-width: 700px; margin: 0 auto 2rem; border-radius: 1rem; overflow: hidden; border: 2px solid rgba(139, 92, 246, 0.3); box-shadow: 0 20px 60px rgba(0,0,0,0.4);">
                            <video id="export-preview-video" src="${outputUrl}" controls style="width: 100%; display: block; background: black;"></video>
                        </div>

                        <!-- Video Info -->
                        <div style="display: flex; justify-content: center; gap: 2rem; margin-bottom: 2rem; color: rgba(255,255,255,0.6); font-size: 0.85rem;">
                            <span> ${totalScenes} scenes</span>
                            <span> ${formatDuration(totalDuration)}</span>
                            <span> ${state.export.exportType === 'server-render' ? 'MP4 format' : 'WebM format'}</span>
                        </div>
                    ` : `
                        <div style="padding: 2rem; color: rgba(255,255,255,0.5);">
                            No video available
                        </div>
                    `}

                    <!-- Action Buttons -->
                    <div style="display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap; margin-bottom: 2rem;">
                        ${hasVideo ? `
                            <button onclick="downloadExportedVideo()"
                                    style="padding: 1rem 2.5rem; border-radius: 0.75rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 700; cursor: pointer; font-size: 1.1rem; display: flex; align-items: center; gap: 0.75rem; box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);">
                                <span style="font-size: 1.25rem;"></span>
                                <span>Download Video</span>
                            </button>
                        ` : ''}
                        <button onclick="exportAgain()"
                                style="padding: 1rem 1.5rem; border-radius: 0.75rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span>
                            <span>Export Again</span>
                        </button>
                    </div>

                    ${hasVideo ? `
                        <!-- Share Info -->
                        <div style="padding: 1.5rem; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.75rem; max-width: 500px; margin: 0 auto;">
                            <div style="font-size: 0.9rem; color: #10b981; margin-bottom: 0.5rem; font-weight: 600;">
                                 Ready to upload!
                            </div>
                            <div style="font-size: 0.8rem; color: rgba(255,255,255,0.6);">
                                Download your video and upload it directly to YouTube, TikTok, Instagram, or any other platform.
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Download the exported video
        async function downloadExportedVideo() {
            const outputUrl = state.export.outputUrl;
            const isServerRender = state.export.exportType === 'server-render';

            // Generate filename based on export type
            const baseFileName = (state.script.title || 'video').replace(/[^a-z0-9]/gi, '_');
            const extension = isServerRender ? 'mp4' : 'webm';
            const fileName = state.export.fileName || `${baseFileName}_${Date.now()}.${extension}`;

            if (!outputUrl) {
                showToast('No video to download', 'error');
                return;
            }

            // Check if it's a cloud storage URL (Firebase or Google Cloud Storage)
            const isCloudUrl = outputUrl.includes('firebasestorage.googleapis.com') ||
                              outputUrl.includes('storage.googleapis.com') ||
                              outputUrl.includes('storage.cloud.google.com');

            try {
                if (isCloudUrl) {
                    // For Cloud Storage URLs, fetch and download as blob
                    showToast('Preparing download...', 'info');

                    const response = await fetch(outputUrl, { mode: 'cors' });
                    if (!response.ok) throw new Error(`Failed to fetch video: ${response.status}`);

                    const blob = await response.blob();
                    const blobUrl = URL.createObjectURL(blob);

                    const link = document.createElement('a');
                    link.href = blobUrl;
                    link.download = fileName;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    // Clean up blob URL after a delay
                    setTimeout(() => URL.revokeObjectURL(blobUrl), 5000);
                    showToast('Download started!', 'success');
                } else {
                    // Direct download for blob URLs or simple URLs
                    const link = document.createElement('a');
                    link.href = outputUrl;
                    link.download = fileName;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showToast('Download started!', 'success');
                }
            } catch (error) {
                console.error('Download error:', error);
                // Fallback: open in new tab
                window.open(outputUrl, '_blank');
                showToast('Opening video in new tab...', 'info');
            }
        }

        // Download all storyboard images
        function downloadAllImages() {
            const imageScenes = state.storyboard.scenes.filter(s => s.imageUrl);
            if (imageScenes.length === 0) {
                showToast('No images to download', 'warning');
                return;
            }

            showToast('Downloading ' + imageScenes.length + ' images...', 'info');

            imageScenes.forEach((scene, index) => {
                const link = document.createElement('a');
                link.href = scene.imageUrl;
                link.download = 'scene_' + (index + 1) + '.png';
                link.target = '_blank';
                document.body.appendChild(link);
                setTimeout(() => {
                    link.click();
                    document.body.removeChild(link);
                }, index * 500); // Stagger downloads
            });
        }

        function renderExportFailed(exportState) {
            const error = exportState.error || 'An unknown error occurred';

            return `
                <div class="content-card" style="text-align: center; padding: 3rem 2rem; margin-top: 1rem;">
                    <div style="font-size: 4rem; margin-bottom: 1.5rem;"></div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                        Export Failed
                    </div>
                    <div style="color: rgba(255,255,255,0.6); margin-bottom: 1rem;">
                        Something went wrong during export
                    </div>

                    <div style="max-width: 400px; margin: 0 auto 2rem; padding: 1rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.5rem;">
                        <div style="font-size: 0.85rem; color: #ef4444;">
                            ${error}
                        </div>
                    </div>

                    <button onclick="retryExport()"
                            style="padding: 0.75rem 2rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; gap: 0.5rem;">
                        <span></span>
                        <span>Try Again</span>
                    </button>
                </div>
            `;
        }

        // Export Functions

        /**
         * Save timeline state for export
         * Captures all timeline edits including scene order, durations, and transitions
         */
        function saveTimelineState() {
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];

            // Get scene order (from timeline or default)
            const sceneOrder = state.assembly.sceneOrder?.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            // Build scene data with timeline edits
            const scenes = sceneOrder.map((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = storyboardScenes.find(s => s.sceneId === sceneId);
                const transition = state.assembly.transitions?.[sceneId] || { type: 'fade', duration: 0.5 };

                return {
                    id: sceneId,
                    index,
                    duration: scriptScene?.duration || 8,
                    voiceoverDuration: animScene?.voiceoverDuration || null,
                    voiceoverOffset: scriptScene?.voiceoverOffset || 0,
                    transition: transition.type || 'fade',
                    transitionDuration: transition.duration || 0.5,
                    hasVideo: !!(animScene?.videoUrl),
                    hasImage: !!(storyboardScene?.imageUrl),
                    hasVoiceover: !!(animScene?.voiceoverUrl)
                };
            });

            // Calculate total duration
            const totalDuration = scenes.reduce((sum, s) => sum + s.duration, 0);

            return {
                version: 1,
                scenes,
                sceneOrder,
                totalDuration,
                music: {
                    enabled: state.assembly.music?.enabled || false,
                    trackId: state.assembly.music?.trackId || null,
                    volume: state.assembly.audioMix?.musicVolume || 30
                },
                captions: {
                    enabled: state.assembly.captions?.enabled !== false,
                    style: state.assembly.captions?.style || 'karaoke',
                    position: state.assembly.captions?.position || 'bottom'
                },
                audioMix: {
                    voiceVolume: state.assembly.audioMix?.voiceVolume || 100,
                    musicVolume: state.assembly.audioMix?.musicVolume || 30
                },
                editHistory: {
                    hasEdits: editHistory.position > 0,
                    editCount: editHistory.position
                }
            };
        }

        // ==========================================
        // EXPORT MODAL FUNCTIONS
        // ==========================================

        function openExportModal() {
            state.export.showModal = true;
            render();
        }

        function closeExportModal() {
            // Only allow closing if not actively exporting
            if (state.export.status === 'exporting' || state.export.status === 'processing') {
                showToast('Please wait for export to complete or cancel it first', 'warning');
                return;
            }
            state.export.showModal = false;
            render();
        }

        function exportAgain() {
            state.export.status = 'idle';
            state.export.progress = 0;
            state.export.outputUrl = null;
            state.export.error = null;
            render();
        }

        function retryExport() {
            state.export.status = 'idle';
            state.export.progress = 0;
            state.export.error = null;
            render();
        }

        function cancelExport() {
            // Reset export state
            state.export.status = 'idle';
            state.export.progress = 0;
            state.export.jobId = null;
            state.export.currentStage = null;
            showToast('Export cancelled', 'info');
            render();
        }

        function renderExportModal() {
            var exportState = state.export || {};
            var isExporting = exportState.status === 'exporting' || exportState.status === 'processing';
            var isCompleted = exportState.status === 'completed';
            var isFailed = exportState.status === 'failed' || exportState.status === 'error';

            // Build modal content based on state
            var modalContent = '';

            if (isExporting) {
                modalContent = renderExportProgressContent(exportState);
            } else if (isCompleted && exportState.outputUrl) {
                modalContent = renderExportCompleteContent(exportState);
            } else if (isFailed) {
                modalContent = renderExportFailedContent(exportState);
            } else {
                modalContent = renderExportConfigContent();
            }

            // Modal wrapper
            var html = '';
            html += '<div id="export-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 2000; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(4px);">';
            html += '<div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);">';

            // Modal header (only show close button if not exporting)
            html += '<div style="display: flex; align-items: center; justify-content: space-between; padding: 1.25rem 1.5rem; border-bottom: 1px solid rgba(255,255,255,0.1);">';
            html += '<div style="display: flex; align-items: center; gap: 0.75rem;">';
            html += '<span style="font-size: 1.5rem;"></span>';
            html += '<span style="font-size: 1.1rem; font-weight: 600; color: white;">Export Video</span>';
            html += '</div>';

            if (!isExporting) {
                html += '<button onclick="closeExportModal()" style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 1.1rem; display: flex; align-items: center; justify-content: center;"></button>';
            }

            html += '</div>';

            // Modal content
            html += '<div style="padding: 1.5rem;">';
            html += modalContent;
            html += '</div>';

            html += '</div>';
            html += '</div>';

            return html;
        }

        function renderExportConfigContent() {
            var scriptScenes = state.script.scenes || [];
            var animationScenes = state.animation.scenes || [];
            var storyboardScenes = state.storyboard.scenes || [];
            var animatedCount = animationScenes.filter(function(s) { return s.videoUrl; }).length;
            var imageCount = storyboardScenes.filter(function(s) { return s.imageUrl; }).length;
            var totalDuration = scriptScenes.reduce(function(sum, s) { return sum + (s.duration || 8); }, 0);
            var platform = PLATFORM_PRESETS[state.platform.selected] || {};

            var selectedQuality = state.export.selectedQuality || '1080p';
            var canExport = animatedCount > 0 || imageCount > 0;

            var html = '';

            // Video Summary
            html += '<div style="margin-bottom: 1.5rem;">';
            html += '<div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem;"> Video Summary</div>';
            html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">';

            html += '<div style="padding: 0.6rem; background: rgba(255,255,255,0.05); border-radius: 0.4rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Platform</div>';
            html += '<div style="font-size: 0.85rem; color: white;">' + (platform.icon || '') + ' ' + (platform.name || 'YouTube') + '</div>';
            html += '</div>';

            html += '<div style="padding: 0.6rem; background: rgba(255,255,255,0.05); border-radius: 0.4rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Duration</div>';
            html += '<div style="font-size: 0.85rem; color: white;">' + formatDuration(totalDuration) + '</div>';
            html += '</div>';

            var imageColor = imageCount === scriptScenes.length ? '#10b981' : (imageCount > 0 ? '#06b6d4' : '#f59e0b');
            html += '<div style="padding: 0.6rem; background: rgba(255,255,255,0.05); border-radius: 0.4rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Images</div>';
            html += '<div style="font-size: 0.85rem; color: ' + imageColor + ';">' + imageCount + '/' + scriptScenes.length + '</div>';
            html += '</div>';

            var animColor = animatedCount === scriptScenes.length ? '#10b981' : (animatedCount > 0 ? '#06b6d4' : 'rgba(255,255,255,0.4)');
            html += '<div style="padding: 0.6rem; background: rgba(255,255,255,0.05); border-radius: 0.4rem;">';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Animated</div>';
            html += '<div style="font-size: 0.85rem; color: ' + animColor + ';">' + animatedCount + '/' + scriptScenes.length + '</div>';
            html += '</div>';

            html += '</div>';
            html += '</div>';

            // Info message about Ken Burns
            if (canExport && animatedCount < scriptScenes.length) {
                html += '<div style="margin-bottom: 1.25rem; padding: 0.75rem; background: rgba(6,182,212,0.1); border: 1px solid rgba(6,182,212,0.3); border-radius: 0.5rem;">';
                html += '<div style="font-size: 0.8rem; color: #06b6d4;">';
                if (animatedCount === 0) {
                    html += 'Using Ken Burns effect on images (animation optional)';
                } else {
                    html += (scriptScenes.length - animatedCount) + ' scene(s) will use Ken Burns effect';
                }
                html += '</div>';
                html += '</div>';
            }

            // Phase 3C: Export Intelligence - Platform Selection
            html += '<div style="margin-bottom: 1.25rem;">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">';
            html += '<div style="font-size: 0.85rem; font-weight: 600; color: white;"> Target Platform</div>';
            html += '<span style="font-size: 0.6rem; padding: 0.2rem 0.5rem; background: linear-gradient(135deg, #f59e0b, #ef4444); border-radius: 0.25rem; color: white; font-weight: 600;">SMART</span>';
            html += '</div>';

            // Platform quick select grid
            var exportPlatforms = [
                { id: 'youtube-standard', icon: '', name: 'YouTube', aspect: '16:9' },
                { id: 'youtube-shorts', icon: '', name: 'YT Shorts', aspect: '9:16' },
                { id: 'tiktok-standard', icon: '', name: 'TikTok', aspect: '9:16' },
                { id: 'instagram-reels', icon: '', name: 'Reels', aspect: '9:16' },
                { id: 'linkedin-video', icon: '', name: 'LinkedIn', aspect: '16:9' },
                { id: 'twitter-video', icon: '', name: 'Twitter/X', aspect: '16:9' }
            ];

            var selectedExportPlatform = state.export.selectedPlatform || state.platform.selected || 'youtube';
            // Map wizard platform to export platform
            var platformMapping = {
                'youtube': 'youtube-standard',
                'youtube-shorts': 'youtube-shorts',
                'tiktok': 'tiktok-standard',
                'instagram': 'instagram-reels',
                'linkedin': 'linkedin-video',
                'twitter': 'twitter-video'
            };
            if (platformMapping[selectedExportPlatform]) {
                selectedExportPlatform = platformMapping[selectedExportPlatform];
            }

            html += '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.4rem;">';
            for (var i = 0; i < exportPlatforms.length; i++) {
                var ep = exportPlatforms[i];
                var isActive = selectedExportPlatform === ep.id;
                var epBorder = isActive ? 'rgba(139,92,246,0.6)' : 'rgba(255,255,255,0.15)';
                var epBg = isActive ? 'rgba(139,92,246,0.2)' : 'rgba(255,255,255,0.03)';

                html += '<button onclick="setExportPlatform(\'' + ep.id + '\')" style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid ' + epBorder + '; background: ' + epBg + '; color: white; cursor: pointer; text-align: center;">';
                html += '<div style="font-size: 1rem;">' + ep.icon + '</div>';
                html += '<div style="font-size: 0.7rem; font-weight: 500;">' + ep.name + '</div>';
                html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">' + ep.aspect + '</div>';
                html += '</button>';
            }
            html += '</div>';

            // Platform Intelligence Tips
            var platformTips = {
                'youtube-standard': { hook: '30s', optimal: '8-15 min', tip: 'Use chapters and end screens' },
                'youtube-shorts': { hook: '3s', optimal: '30-58s', tip: 'Loop-friendly content performs best' },
                'tiktok-standard': { hook: '2s', optimal: '21-34s', tip: 'Trending sounds boost reach 40%' },
                'instagram-reels': { hook: '2s', optimal: '15-30s', tip: 'Saves and shares boost algorithm' },
                'linkedin-video': { hook: '5s', optimal: '30-120s', tip: 'Native captions are essential' },
                'twitter-video': { hook: '3s', optimal: '15-60s', tip: 'Assume muted autoplay' }
            };
            var currentTip = platformTips[selectedExportPlatform] || platformTips['youtube-standard'];

            html += '<div style="margin-top: 0.5rem; padding: 0.6rem; background: rgba(139,92,246,0.1); border: 1px solid rgba(139,92,246,0.2); border-radius: 0.4rem;">';
            html += '<div style="display: flex; gap: 1rem; font-size: 0.7rem;">';
            html += '<div><span style="color: rgba(255,255,255,0.5);">Hook:</span> <span style="color: #a78bfa;">' + currentTip.hook + '</span></div>';
            html += '<div><span style="color: rgba(255,255,255,0.5);">Optimal:</span> <span style="color: #10b981;">' + currentTip.optimal + '</span></div>';
            html += '</div>';
            html += '<div style="font-size: 0.7rem; color: rgba(255,255,255,0.7); margin-top: 0.35rem;"> ' + currentTip.tip + '</div>';
            html += '</div>';
            html += '</div>';

            // Duration check warning
            var durationWarning = '';
            if (selectedExportPlatform === 'youtube-shorts' && totalDuration > 60) {
                durationWarning = 'Video exceeds 60s Shorts limit. Will be split or trimmed.';
            } else if (selectedExportPlatform === 'tiktok-standard' && totalDuration > 60) {
                durationWarning = 'Consider TikTok Extended for videos over 60s.';
            } else if (selectedExportPlatform === 'instagram-reels' && totalDuration > 90) {
                durationWarning = 'Exceeds 90s Reels limit. Content will be trimmed.';
            }

            if (durationWarning) {
                html += '<div style="margin-bottom: 1rem; padding: 0.6rem; background: rgba(245,158,11,0.1); border: 1px solid rgba(245,158,11,0.3); border-radius: 0.4rem;">';
                html += '<div style="font-size: 0.75rem; color: #f59e0b;"> ' + durationWarning + '</div>';
                html += '</div>';
            }

            // Multi-Platform Export Toggle
            html += '<div style="margin-bottom: 1.25rem;">';
            html += '<button onclick="toggleMultiPlatformExport()" style="width: 100%; padding: 0.6rem; border-radius: 0.4rem; border: 1px dashed rgba(255,255,255,0.2); background: transparent; color: rgba(255,255,255,0.7); cursor: pointer; font-size: 0.75rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">';
            html += '<span></span>';
            html += '<span>Export to Multiple Platforms</span>';
            html += '<span style="font-size: 0.6rem; padding: 0.15rem 0.4rem; background: rgba(6,182,212,0.2); border-radius: 0.2rem; color: #06b6d4;">PRO</span>';
            html += '</button>';
            html += '</div>';

            // Quality Selection
            html += '<div style="margin-bottom: 1.25rem;">';
            html += '<div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem;"> Export Quality</div>';
            html += '<div style="display: flex; gap: 0.5rem;">';

            var qualities = Object.entries(EXPORT_QUALITIES);
            for (var i = 0; i < qualities.length; i++) {
                var id = qualities[i][0];
                var q = qualities[i][1];
                var isSelected = selectedQuality === id;
                var borderColor = isSelected ? 'rgba(139,92,246,0.6)' : 'rgba(255,255,255,0.15)';
                var bgColor = isSelected ? 'rgba(139,92,246,0.2)' : 'rgba(255,255,255,0.03)';

                html += '<button onclick="setExportQuality(\'' + id + '\')" style="flex: 1; padding: 0.75rem 0.5rem; border-radius: 0.5rem; border: 1px solid ' + borderColor + '; background: ' + bgColor + '; color: white; cursor: pointer; text-align: center;">';
                html += '<div style="font-size: 1rem;">' + q.icon + '</div>';
                html += '<div style="font-size: 0.8rem; font-weight: 600; margin-top: 0.25rem;">' + id + '</div>';
                html += '</button>';
            }

            html += '</div>';
            html += '</div>';

            // Export Button
            if (!canExport) {
                html += '<div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-radius: 0.5rem;">';
                html += '<div style="font-size: 0.8rem; color: #ef4444;">Generate images in Storyboard step first</div>';
                html += '</div>';
            }

            var exportBtnBg = canExport ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)';
            var exportBtnColor = canExport ? 'white' : 'rgba(255,255,255,0.4)';
            var exportBtnCursor = canExport ? 'pointer' : 'not-allowed';

            html += '<button onclick="startExport()" ' + (canExport ? '' : 'disabled') + ' style="width: 100%; padding: 1rem; border-radius: 0.75rem; border: none; background: ' + exportBtnBg + '; color: ' + exportBtnColor + '; font-size: 1rem; font-weight: 700; cursor: ' + exportBtnCursor + '; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">';
            html += '<span></span>';
            html += '<span>Start Export</span>';
            html += '</button>';

            return html;
        }

        function renderExportProgressContent(exportState) {
            var progress = exportState.progress || 0;
            var currentStage = exportState.currentStage || 'Starting export...';
            var scenesCompleted = exportState.scenesCompleted || 0;
            var scenesTotal = exportState.scenesTotal || 0;
            var sceneStatuses = exportState.sceneStatuses || [];

            var html = '';
            html += '<div style="text-align: center;">';

            // Animated icon
            html += '<div style="font-size: 3rem; margin-bottom: 1rem;">';
            html += '<div class="animate-pulse" style="display: inline-block;"></div>';
            html += '</div>';

            html += '<div style="font-size: 1.25rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">Rendering Your Video</div>';
            html += '<div id="export-stage-text" style="color: rgba(255,255,255,0.7); margin-bottom: 1.25rem; font-size: 0.9rem;">' + currentStage + '</div>';

            // Scene progress indicators
            if (scenesTotal > 0) {
                html += '<div style="display: flex; justify-content: center; gap: 0.4rem; margin-bottom: 1rem; flex-wrap: wrap;">';
                for (var i = 0; i < scenesTotal; i++) {
                    var sceneStatus = sceneStatuses[i];
                    var status = sceneStatus ? sceneStatus.status : 'queued';
                    var isComplete = status === 'complete';
                    var isFailed = status === 'failed';
                    var isRendering = status === 'rendering';

                    var bgColor = 'rgba(255,255,255,0.1)';
                    var icon = (i + 1);
                    var extraStyle = '';

                    if (isComplete) {
                        bgColor = 'rgba(34,197,94,0.4)';
                        icon = '';
                        extraStyle = 'border: 2px solid rgba(34,197,94,0.6);';
                    } else if (isFailed) {
                        bgColor = 'rgba(239,68,68,0.4)';
                        icon = '';
                        extraStyle = 'border: 2px solid rgba(239,68,68,0.6);';
                    } else if (isRendering) {
                        bgColor = 'rgba(139,92,246,0.4)';
                        extraStyle = 'animation: pulse 2s infinite; border: 2px solid rgba(139,92,246,0.6);';
                    }

                    html += '<div style="width: 2rem; height: 2rem; border-radius: 50%; background: ' + bgColor + '; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-weight: 600; color: white; ' + extraStyle + '">' + icon + '</div>';
                }
                html += '</div>';
                html += '<div style="color: rgba(255,255,255,0.5); font-size: 0.8rem; margin-bottom: 1rem;">' + scenesCompleted + ' of ' + scenesTotal + ' scenes complete</div>';
            }

            // Progress bar
            html += '<div style="margin-bottom: 1.25rem;">';
            html += '<div style="height: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; overflow: hidden;">';
            html += '<div id="export-progress-bar" style="height: 100%; width: ' + progress + '%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); border-radius: 5px; transition: width 0.5s ease;"></div>';
            html += '</div>';
            html += '<div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.8rem;">';
            html += '<span style="color: rgba(255,255,255,0.5);">Progress</span>';
            html += '<span id="export-progress-text" style="color: #8b5cf6; font-weight: 700;">' + progress + '%</span>';
            html += '</div>';
            html += '</div>';

            // Processing indicator
            html += '<div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-bottom: 1.25rem;">';
            html += '<div class="animate-spin" style="width: 1rem; height: 1rem; border: 2px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%;"></div>';
            html += '<span style="color: rgba(255,255,255,0.6); font-size: 0.8rem;">Processing on server...</span>';
            html += '</div>';

            // Cancel button
            html += '<button onclick="cancelExport()" style="padding: 0.5rem 1.25rem; border-radius: 0.5rem; border: 1px solid rgba(239,68,68,0.4); background: rgba(239,68,68,0.1); color: #ef4444; cursor: pointer; font-size: 0.8rem;">Cancel Export</button>';

            html += '<div style="margin-top: 1rem; color: rgba(255,255,255,0.4); font-size: 0.7rem;">Please don\'t close this page while exporting</div>';

            html += '</div>';
            return html;
        }

        function renderExportCompleteContent(exportState) {
            var outputUrl = exportState.outputUrl;
            var totalScenes = (state.script.scenes || []).length;
            var totalDuration = (state.script.scenes || []).reduce(function(sum, s) { return sum + (s.duration || 8); }, 0);

            var html = '';
            html += '<div style="text-align: center;">';

            html += '<div style="font-size: 3rem; margin-bottom: 1rem;"></div>';
            html += '<div style="font-size: 1.25rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">Video Export Complete!</div>';
            html += '<div style="color: rgba(255,255,255,0.6); margin-bottom: 1.25rem;">Your video is ready to download and share</div>';

            // Video preview
            if (outputUrl) {
                html += '<div style="margin-bottom: 1.25rem; border-radius: 0.75rem; overflow: hidden; border: 2px solid rgba(139,92,246,0.3);">';
                html += '<video id="export-preview-video" src="' + outputUrl + '" controls style="width: 100%; display: block; background: black;"></video>';
                html += '</div>';

                html += '<div style="display: flex; justify-content: center; gap: 1.5rem; margin-bottom: 1.25rem; color: rgba(255,255,255,0.6); font-size: 0.8rem;">';
                html += '<span> ' + totalScenes + ' scenes</span>';
                html += '<span> ' + formatDuration(totalDuration) + '</span>';
                html += '<span> MP4 format</span>';
                html += '</div>';
            }

            // Action buttons
            html += '<div style="display: flex; justify-content: center; gap: 0.75rem; flex-wrap: wrap; margin-bottom: 1.25rem;">';

            if (outputUrl) {
                html += '<button onclick="downloadExportedVideo()" style="padding: 0.75rem 1.5rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 700; cursor: pointer; font-size: 0.95rem; display: flex; align-items: center; gap: 0.5rem;">';
                html += '<span></span>';
                html += '<span>Download Video</span>';
                html += '</button>';
            }

            html += '<button onclick="exportAgain()" style="padding: 0.75rem 1rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span></span>';
            html += '<span>Export Again</span>';
            html += '</button>';

            html += '<button onclick="closeExportModal()" style="padding: 0.75rem 1rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-weight: 600;">Close</button>';

            html += '</div>';

            // Share info
            if (outputUrl) {
                html += '<div style="padding: 1rem; background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3); border-radius: 0.5rem;">';
                html += '<div style="font-size: 0.85rem; color: #10b981; margin-bottom: 0.25rem; font-weight: 600;"> Ready to upload!</div>';
                html += '<div style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Download your video and upload it directly to YouTube, TikTok, Instagram, or any other platform.</div>';
                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        function renderExportFailedContent(exportState) {
            var error = exportState.error || 'An unknown error occurred';

            var html = '';
            html += '<div style="text-align: center;">';

            html += '<div style="font-size: 3rem; margin-bottom: 1rem;"></div>';
            html += '<div style="font-size: 1.25rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">Export Failed</div>';
            html += '<div style="color: rgba(255,255,255,0.6); margin-bottom: 1rem;">Something went wrong during export</div>';

            html += '<div style="margin-bottom: 1.5rem; padding: 0.75rem; background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-radius: 0.5rem;">';
            html += '<div style="font-size: 0.8rem; color: #ef4444;">' + error + '</div>';
            html += '</div>';

            html += '<div style="display: flex; justify-content: center; gap: 0.75rem;">';
            html += '<button onclick="retryExport()" style="padding: 0.75rem 1.5rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 0.5rem;">';
            html += '<span></span>';
            html += '<span>Try Again</span>';
            html += '</button>';

            html += '<button onclick="closeExportModal()" style="padding: 0.75rem 1rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-weight: 600;">Close</button>';
            html += '</div>';

            html += '</div>';
            return html;
        }

        function setExportQuality(quality) {
            if (!state.export) state.export = {};
            state.export.selectedQuality = quality;
            render();
        }

        function setRenderQuality(quality) {
            if (!state.export) state.export = {};
            state.export.selectedRenderQuality = quality;
            render();
        }

        // Phase 3C: Export Intelligence Functions
        function setExportPlatform(platformId) {
            if (!state.export) state.export = {};
            state.export.selectedPlatform = platformId;

            // Show platform-specific tips
            const platformNames = {
                'youtube-standard': 'YouTube Standard',
                'youtube-shorts': 'YouTube Shorts',
                'tiktok-standard': 'TikTok',
                'instagram-reels': 'Instagram Reels',
                'linkedin-video': 'LinkedIn',
                'twitter-video': 'Twitter/X'
            };

            showToast(`Export target: ${platformNames[platformId] || platformId}`, 'success');
            render();
        }

        function toggleMultiPlatformExport() {
            showToast('Multi-platform export coming soon! Export to multiple platforms at once.', 'info');
            // Future: Open multi-platform selection modal
        }

        function toggleSeriesMode() {
            if (!state.export.seriesInfo) {
                state.export.seriesInfo = {
                    template: 'youtube-series',
                    episodeNumber: 1,
                    seasonNumber: 1,
                    seriesName: state.project.name || 'My Series'
                };
                showToast('Series mode enabled', 'success');
            } else {
                state.export.seriesInfo = null;
                showToast('Series mode disabled', 'info');
            }
            render();
        }

        function setSeriesTemplate(template) {
            if (!state.export.seriesInfo) {
                state.export.seriesInfo = { template, episodeNumber: 1, seasonNumber: 1 };
            } else {
                state.export.seriesInfo.template = template;
            }
            render();
        }

        function setEpisodeNumber(num) {
            if (!state.export.seriesInfo) return;
            state.export.seriesInfo.episodeNumber = parseInt(num) || 1;
            render();
        }

        async function getExportRecommendations() {
            try {
                const getRecommendations = functions.httpsCallable('creationWizardGetExportRecommendations');
                const scriptScenes = state.script.scenes || [];
                const totalDuration = scriptScenes.reduce((sum, s) => sum + (s.duration || 8), 0);

                const result = await getRecommendations({
                    platform: state.export.selectedPlatform || state.platform.selected,
                    duration: totalDuration,
                    contentType: state.content.contentFormat || 'standard',
                    genre: state.content.genre,
                    hasDialogue: true,
                    seriesInfo: state.export.seriesInfo
                });

                if (result.data.success) {
                    state.export.recommendations = result.data.recommendations;
                    render();
                }
            } catch (error) {
                console.error('Failed to get export recommendations:', error);
            }
        }

        async function startExport() {
            // Check for exportable content: either AI videos OR storyboard images
            const animatedCount = (state.animation.scenes || []).filter(s => s.videoUrl).length;
            const imageCount = (state.storyboard.scenes || []).filter(s => s.imageUrl).length;
            const hasVoiceovers = (state.animation.scenes || []).some(s => s.voiceoverUrl);

            if (animatedCount === 0 && imageCount === 0) {
                showToast('Please add images or videos to your scenes first', 'error');
                return;
            }

            // Ensure project is saved before exporting
            if (!state.project.id) {
                showToast('Saving project before export...', 'info');
                await saveProject();
                if (!state.project.id) {
                    showToast('Please save your project first', 'error');
                    return;
                }
            }

            state.export.status = 'exporting';
            state.export.progress = 0;
            state.export.currentStage = 'Starting server-side export...';
            state.export.exportType = 'server-render';
            state.export.jobId = null;
            state.export.outputUrl = null;
            state.export.error = null;
            render();

            try {
                // Call Cloud Function to start server-side video export
                console.log('[Export] Starting server-side video rendering');

                const quality = state.export.selectedQuality || '1080p';
                const renderQuality = state.export.selectedRenderQuality || 'balanced';
                const format = 'mp4'; // Server-side always produces MP4

                const startExportFn = firebase.functions().httpsCallable('creationWizardStartExport');
                const result = await startExportFn({
                    projectId: state.project.id,
                    quality: quality,
                    renderQuality: renderQuality,  // fast, balanced, or best
                    format: format
                });

                if (!result.data.success) {
                    throw new Error(result.data.error || 'Failed to start export');
                }

                // Store job ID and start polling
                state.export.jobId = result.data.jobId;
                state.export.progress = 5;
                state.export.currentStage = 'Export job created, waiting for processing...';
                updateExportProgressBar(state.export.progress, state.export.currentStage);

                console.log('[Export] Job created:', result.data.jobId);
                console.log('[Export] Total duration:', result.data.totalDuration, 'seconds');
                console.log('[Export] Scenes:', result.data.sceneCount);

                // Start polling for status
                setTimeout(pollExportStatus, 2000);

            } catch (error) {
                console.error('Export error:', error);
                state.export.status = 'failed';
                state.export.error = error.message || 'Export failed';
                showToast('Export failed: ' + error.message, 'error');
                render();
            }
        }

        // Build scenes array for export engine
        function buildExportScenes() {
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const sceneOrder = state.assembly.sceneOrder?.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            return sceneOrder.map((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = storyboardScenes.find(s => s.sceneId === sceneId);

                return {
                    id: sceneId,
                    index,
                    narration: scriptScene?.narration || '',
                    visualDuration: scriptScene?.visualDuration || scriptScene?.duration || 8,
                    duration: scriptScene?.duration || 8,
                    // Prefer video if available, otherwise image
                    videoUrl: animScene?.videoUrl || null,
                    imageUrl: storyboardScene?.imageUrl || null,
                    voiceoverUrl: animScene?.voiceoverUrl || null,
                    // Ken Burns parameters for images
                    kenBurns: {
                        startScale: 1.0 + Math.random() * 0.2,
                        endScale: 1.1 + Math.random() * 0.2,
                        startX: 0.4 + Math.random() * 0.2,
                        startY: 0.4 + Math.random() * 0.2,
                        endX: 0.4 + Math.random() * 0.2,
                        endY: 0.4 + Math.random() * 0.2
                    },
                    transition: state.assembly.transitions?.[sceneId]?.type || 'fade'
                };
            });
        }

        async function pollExportStatus() {
            if (!state.export.jobId) return;

            try {
                const checkStatus = firebase.functions().httpsCallable('creationWizardCheckExportStatus');
                const result = await checkStatus({ jobId: state.export.jobId });

                const statusChanged = state.export.status !== result.data.status;
                const completed = result.data.status === 'completed';
                const failed = result.data.status === 'failed' || result.data.status === 'error';

                // Track if scene progress changed (for UI updates)
                const prevScenesCompleted = state.export.scenesCompleted || 0;
                const newScenesCompleted = result.data.scenesCompleted || 0;
                const sceneProgressChanged = newScenesCompleted !== prevScenesCompleted;

                state.export.status = result.data.status;
                state.export.progress = result.data.progress || 0;
                state.export.currentStage = result.data.currentStage || '';
                state.export.outputUrl = result.data.outputUrl || null;
                state.export.error = result.data.error || null;
                state.export.exportType = result.data.exportType || null;
                state.export.exportNote = result.data.exportNote || null;
                state.export.imageUrls = result.data.imageUrls || null;
                state.export.previewThumbnail = result.data.previewThumbnail || null;

                // Scene progress tracking for parallel processing UI
                state.export.scenesCompleted = result.data.scenesCompleted || 0;
                state.export.scenesTotal = result.data.scenesTotal || 0;
                state.export.sceneStatuses = result.data.sceneStatuses || [];

                // Re-render when status changes OR when scene progress changes
                if (statusChanged || completed || failed || sceneProgressChanged) {
                    render();
                } else {
                    // Just update progress bar without full re-render (prevents flashing)
                    updateExportProgressBar(state.export.progress, state.export.currentStage);
                }

                if (completed) {
                    showToast('Export complete!', 'success');
                    saveProject();
                } else if (failed) {
                    showToast('Export failed: ' + (state.export.error || 'Unknown error'), 'error');
                } else if (result.data.status === 'processing' || result.data.status === 'pending' || result.data.status === 'exporting') {
                    // Continue polling
                    setTimeout(pollExportStatus, 2000);
                }
            } catch (error) {
                console.error('Poll status error:', error);
                // Retry polling
                setTimeout(pollExportStatus, 5000);
            }
        }

        // Update just the progress bar elements without full re-render
        function updateExportProgressBar(progress, currentStage) {
            const progressBar = document.getElementById('export-progress-bar');
            const progressText = document.getElementById('export-progress-text');
            const stageText = document.getElementById('export-stage-text');

            if (progressBar) progressBar.style.width = progress + '%';
            if (progressText) progressText.textContent = progress + '%';
            if (stageText) stageText.textContent = currentStage || 'Processing...';
        }

        async function cancelExport() {
            // If we have a jobId, try to cancel on server
            if (state.export.jobId) {
                try {
                    const cancelExportFn = firebase.functions().httpsCallable('creationWizardCancelExport');
                    await cancelExportFn({ jobId: state.export.jobId });
                    showToast('Export cancelled', 'info');
                } catch (error) {
                    console.error('Cancel error:', error);
                    // Still reset UI even if server cancel fails
                }
            } else {
                showToast('Export stopped', 'info');
            }

            // ALWAYS reset UI state so user can exit
            state.export.status = 'idle';
            state.export.jobId = null;
            state.export.progress = 0;
            state.export.currentStage = '';
            state.export.error = null;
            render();
        }

        function copyExportUrl() {
            if (state.export.outputUrl) {
                navigator.clipboard.writeText(state.export.outputUrl)
                    .then(() => showToast('Link copied to clipboard!', 'success'))
                    .catch(() => showToast('Failed to copy link', 'error'));
            }
        }

        function exportAgain() {
            state.export.status = 'idle';
            state.export.jobId = null;
            state.export.outputUrl = null;
            state.export.progress = 0;
            render();
        }

        function retryExport() {
            state.export.status = 'idle';
            state.export.error = null;
            render();
        }

        function shareToSocial(platform) {
            const url = state.export.outputUrl;
            if (!url) return;

            let shareUrl;
            switch (platform) {
                case 'twitter':
                    shareUrl = `https://twitter.com/intent/tweet?url=${encodeURIComponent(url)}&text=${encodeURIComponent('Check out my new video!')}`;
                    break;
                default:
                    showToast(`Download the video to upload to ${platform}`, 'info');
                    return;
            }

            if (shareUrl) {
                window.open(shareUrl, '_blank', 'width=600,height=400');
            }
        }

        // ==========================================
        // 7.12 HELPER RENDERS
        // ==========================================

        function renderComingSoonStep(stepNum, title, description) {
            return `
                <div class="fade-in">
                    <div class="content-card" style="text-align: center; padding: 4rem 2rem;">
                        <div style="font-size: 4rem; margin-bottom: 1.5rem;"></div>
                        <div style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                            Step ${stepNum}: ${title}
                        </div>
                        <div style="color: rgba(255,255,255,0.6); margin-bottom: 2rem;">
                            ${description}
                        </div>
                        <div style="color: rgba(139, 92, 246, 0.8); font-size: 0.9rem;">
                            Coming soon in Phase ${stepNum > 2 ? Math.ceil((stepNum - 2) / 2) + 1 : 1}...
                        </div>
                    </div>
                    ${renderNavButtons(stepNum - 1, stepNum < 6 ? stepNum + 1 : null)}
                </div>
            `;
        }

        // ==========================================
        // 7.8 NAVIGATION BUTTONS
        // ==========================================
        function renderNavButtons(backStep, nextStep) {
            let html = '<div class="nav-buttons">';

            if (backStep) {
                html += `
                    <button class="nav-button nav-button-back" onclick="goToStep(${backStep})">
                        <span></span>
                        <span>Back</span>
                    </button>
                `;
            } else {
                html += '<div></div>';
            }

            if (nextStep) {
                html += `
                    <button class="nav-button nav-button-next" onclick="goToStep(${nextStep})">
                        <span>Continue</span>
                        <span></span>
                    </button>
                `;
            } else if (state.currentStep < 6) {
                html += `
                    <button class="nav-button nav-button-next" disabled>
                        <span>Continue</span>
                        <span></span>
                    </button>
                `;
            }

            html += '</div>';
            return html;
        }

        // ==========================================
        // 7.9 EVENT LISTENERS
        // ==========================================
        function attachEventListeners() {
            // Duration slider continuous update
            const durationSlider = document.getElementById('duration-slider');
            if (durationSlider) {
                durationSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    state.platform.targetDuration = value;
                    // Update just the display without full re-render
                    const valueDisplay = document.querySelector('.duration-value');
                    if (valueDisplay) {
                        valueDisplay.textContent = formatDuration(value);
                    }
                });
            }

            // Topic input
            const topicInput = document.getElementById('topic-input');
            if (topicInput) {
                topicInput.addEventListener('input', function() {
                    state.content.topic = this.value;
                });
            }
        }

        // ==========================================
        // 7.10 INITIALIZATION
        // ==========================================
        async function init() {
            try {
                // Initialize Animation Studio Pro keyboard shortcuts
                initAnimationKeyboardShortcuts();

                const user = await initAuth();

                // Log auth result but DON'T redirect - let page render regardless
                console.log('Auth complete. User:', user ? user.email : 'not authenticated');

                // Update loading text after auth
                const loadingText = document.getElementById('loading-text');
                if (loadingText) {
                    loadingText.textContent = 'Loading Video Creation Wizard...';
                }

                // Check if loading an existing project
                const projectId = checkUrlForProject();
                if (projectId && user) {
                    await loadProject(projectId);
                } else {
                    state.isLoading = false;
                    render();
                }
            } catch (error) {
                console.error('Init error:', error);
                state.isLoading = false;
                render();
            }
        }

        // Start the app
        init();
    </script>
</body>
</html>
