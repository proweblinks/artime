---
phase: 02-narrative-intelligence
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - modules/AppVideoWizard/app/Services/NarrativeMomentService.php
  - modules/AppVideoWizard/app/Services/ShotIntelligenceService.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Consecutive moments never have duplicate action verbs"
    - "Interpolated moments get unique progression markers"
    - "validateActionUniqueness() returns issues for duplicate actions"
  artifacts:
    - path: "modules/AppVideoWizard/app/Services/NarrativeMomentService.php"
      provides: "Action deduplication during decomposition"
      contains: "deduplicateActions"
    - path: "modules/AppVideoWizard/app/Services/ShotIntelligenceService.php"
      provides: "Post-analysis action uniqueness validation"
      contains: "validateActionUniqueness"
  key_links:
    - from: "NarrativeMomentService.php"
      to: "deduplicateActions()"
      via: "called after decomposition"
      pattern: "deduplicateActions\\(\\$moments\\)"
    - from: "ShotIntelligenceService.php"
      to: "validateActionUniqueness()"
      via: "post-analysis validation"
      pattern: "validateActionUniqueness"
---

<objective>
Add action uniqueness validation to prevent duplicate/similar actions across consecutive shots.

Purpose: Hollywood standard requires every shot to capture a DIFFERENT moment. This prevents boring sequences where multiple shots show the same action (e.g., "looks around" repeated). The research identified this as a critical pitfall to avoid.

Output: Automatic deduplication during moment decomposition + validation method for post-analysis checks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-narrative-intelligence/02-RESEARCH.md
@.planning/phases/02-narrative-intelligence/02-01-SUMMARY.md

# Key source files
@modules/AppVideoWizard/app/Services/NarrativeMomentService.php
@modules/AppVideoWizard/app/Services/ShotIntelligenceService.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add action deduplication to NarrativeMomentService</name>
  <files>modules/AppVideoWizard/app/Services/NarrativeMomentService.php</files>
  <action>
Add action deduplication logic to NarrativeMomentService. Place new methods after `formatCharacterList()` (around line 668):

```php
/**
 * Deduplicate actions across consecutive moments.
 * Hollywood standard: Each shot must have a UNIQUE action.
 *
 * @param array $moments Array of moment objects
 * @return array Moments with deduplicated actions
 */
public function deduplicateActions(array $moments): array
{
    if (count($moments) <= 1) {
        return $moments;
    }

    $usedVerbs = [];
    $progressionMarkers = [
        'begins to', 'starts to', 'continues to', 'proceeds to',
        'then', 'now', 'suddenly', 'finally', 'eventually'
    ];

    foreach ($moments as $index => &$moment) {
        $action = $moment['action'] ?? '';
        $verb = $this->extractPrimaryVerb($action);

        // Check if verb was used in previous moments
        if (in_array(strtolower($verb), $usedVerbs)) {
            // Add progression marker to make unique
            $marker = $progressionMarkers[$index % count($progressionMarkers)];
            $moment['action'] = $marker . ' ' . $action;
            $moment['deduplicated'] = true;

            Log::debug('NarrativeMomentService: Deduplicated action', [
                'original' => $action,
                'modified' => $moment['action'],
                'index' => $index,
            ]);
        }

        // Track this verb (allow same verb with 2+ gap)
        $usedVerbs[] = strtolower($verb);
        if (count($usedVerbs) > 2) {
            array_shift($usedVerbs); // Keep only last 2 verbs
        }
    }

    return $moments;
}

/**
 * Extract the primary action verb from an action string.
 *
 * @param string $action Action description
 * @return string Primary verb or full action if no verb found
 */
protected function extractPrimaryVerb(string $action): string
{
    // Common action verbs to detect
    $verbPattern = '/\b(arrives?|enters?|walks?|runs?|spots?|sees?|looks?|watches?|notices?|chases?|finds?|loses?|meets?|speaks?|confronts?|faces?|flees?|escapes?|approaches?|attacks?|defends?|realizes?|discovers?|stands?|sits?|moves?|steps?|turns?|reaches?|grabs?|holds?|drops?|throws?|pushes?|pulls?|opens?|closes?|starts?|stops?|begins?|ends?|continues?)\b/i';

    if (preg_match($verbPattern, $action, $matches)) {
        return $matches[1];
    }

    // Fallback: first word
    $words = explode(' ', trim($action));
    return $words[0] ?? $action;
}

/**
 * Check if two actions are similar enough to be considered duplicates.
 *
 * @param string $action1 First action
 * @param string $action2 Second action
 * @return bool True if actions are too similar
 */
public function areActionsSimilar(string $action1, string $action2): bool
{
    $verb1 = strtolower($this->extractPrimaryVerb($action1));
    $verb2 = strtolower($this->extractPrimaryVerb($action2));

    // Same verb = similar
    if ($verb1 === $verb2) {
        return true;
    }

    // Check for verb variations (look/looks/looking)
    $stem1 = rtrim($verb1, 'seding');
    $stem2 = rtrim($verb2, 'seding');
    if ($stem1 === $stem2 && strlen($stem1) > 3) {
        return true;
    }

    // Synonym groups that should be considered similar
    $synonymGroups = [
        ['look', 'watch', 'observe', 'gaze', 'stare', 'glance'],
        ['run', 'sprint', 'dash', 'race', 'rush'],
        ['walk', 'step', 'pace', 'stride'],
        ['speak', 'say', 'tell', 'talk'],
        ['stand', 'rise', 'get up'],
    ];

    foreach ($synonymGroups as $group) {
        $in1 = in_array($stem1, $group) || in_array($verb1, $group);
        $in2 = in_array($stem2, $group) || in_array($verb2, $group);
        if ($in1 && $in2) {
            return true;
        }
    }

    return false;
}
```

Now update `decomposeNarrationIntoMoments()` (line 176) to call deduplication. Find the return statement at line 190:

```php
return $this->interpolateMoments($moments, $targetShotCount);
```

Replace with:

```php
$interpolated = $this->interpolateMoments($moments, $targetShotCount);
return $this->deduplicateActions($interpolated);
```

WHY: Deduplication happens AFTER interpolation because interpolation may duplicate moments when expanding count.
  </action>
  <verify>
    - deduplicateActions() method exists and is public
    - extractPrimaryVerb() method exists and is protected
    - areActionsSimilar() method exists and is public
    - decomposeNarrationIntoMoments() calls deduplicateActions() before returning
    - Verb pattern includes common action verbs from ACTION_EMOTION_MAP
    - No PHP syntax errors: `php -l modules/AppVideoWizard/app/Services/NarrativeMomentService.php`
  </verify>
  <done>NarrativeMomentService automatically deduplicates actions across consecutive moments</done>
</task>

<task type="auto">
  <name>Task 2: Add action uniqueness validation to ShotIntelligenceService</name>
  <files>modules/AppVideoWizard/app/Services/ShotIntelligenceService.php</files>
  <action>
Add a public method to validate action uniqueness in shot sequences. Place after validateActionProgression() (around line 1633):

```php
/**
 * Validate that narrative moments have unique actions.
 * Returns issues if consecutive moments have similar actions.
 *
 * @param array $moments Array of narrative moment objects
 * @return array Validation result with 'valid' boolean and 'issues' array
 */
public function validateActionUniqueness(array $moments): array
{
    $issues = [];

    if (count($moments) <= 1) {
        return [
            'valid' => true,
            'issues' => [],
            'uniquenessScore' => 100,
        ];
    }

    $previousAction = null;
    $duplicateCount = 0;

    foreach ($moments as $index => $moment) {
        $currentAction = $moment['action'] ?? '';

        if ($index > 0 && !empty($currentAction) && !empty($previousAction)) {
            // Check using NarrativeMomentService if available
            $isSimilar = false;
            if ($this->narrativeMomentService) {
                $isSimilar = $this->narrativeMomentService->areActionsSimilar($currentAction, $previousAction);
            } else {
                // Fallback: simple word comparison
                $words1 = array_filter(explode(' ', strtolower($currentAction)));
                $words2 = array_filter(explode(' ', strtolower($previousAction)));
                $overlap = count(array_intersect($words1, $words2));
                $isSimilar = $overlap >= 2 || ($words1[0] ?? '') === ($words2[0] ?? '');
            }

            if ($isSimilar) {
                $duplicateCount++;
                $issues[] = [
                    'momentIndex' => $index,
                    'type' => 'duplicate_action',
                    'severity' => 'high',
                    'message' => sprintf(
                        'Moment %d action "%s" is similar to moment %d action "%s"',
                        $index + 1,
                        substr($currentAction, 0, 50),
                        $index,
                        substr($previousAction, 0, 50)
                    ),
                    'suggestion' => 'Each moment should have a unique action verb that progresses the narrative',
                ];
            }
        }

        $previousAction = $currentAction;
    }

    // Calculate uniqueness score (100% = all unique, 0% = all duplicates)
    $totalPairs = max(1, count($moments) - 1);
    $uniquenessScore = round((1 - ($duplicateCount / $totalPairs)) * 100);

    return [
        'valid' => empty($issues),
        'issues' => $issues,
        'uniquenessScore' => $uniquenessScore,
        'duplicateCount' => $duplicateCount,
        'totalMoments' => count($moments),
    ];
}
```

Now add action uniqueness validation to analyzeScene() by adding a call after narrative moment decomposition. Find the section in analyzeScene() where we log successful decomposition (added in 02-01), and add after the Log::info:

```php
// Validate action uniqueness
$uniquenessValidation = $this->validateActionUniqueness($narrativeMoments);
if (!$uniquenessValidation['valid']) {
    Log::warning('ShotIntelligenceService: Action uniqueness issues detected', [
        'scene_id' => $scene['id'] ?? 'unknown',
        'issues' => count($uniquenessValidation['issues']),
        'score' => $uniquenessValidation['uniquenessScore'],
    ]);
}
$context['actionUniquenessValidation'] = $uniquenessValidation;
```

Also add the validation result to the analysis output. Find where we add narrativeMoments to analysis (added in 02-01) and add:

```php
if (!empty($uniquenessValidation)) {
    $analysis['actionUniqueness'] = $uniquenessValidation;
}
```

WHY: Provides visibility into action uniqueness quality. Even after deduplication, this catches edge cases and provides metrics.
  </action>
  <verify>
    - validateActionUniqueness() method exists and is public
    - Method returns 'valid', 'issues', and 'uniquenessScore' keys
    - analyzeScene() calls validateActionUniqueness() when moments available
    - Analysis result includes actionUniqueness when validation performed
    - No PHP syntax errors: `php -l modules/AppVideoWizard/app/Services/ShotIntelligenceService.php`
  </verify>
  <done>ShotIntelligenceService validates and reports action uniqueness for narrative moments</done>
</task>

</tasks>

<verification>
1. PHP syntax check:
   - `php -l modules/AppVideoWizard/app/Services/NarrativeMomentService.php`
   - `php -l modules/AppVideoWizard/app/Services/ShotIntelligenceService.php`
2. Grep for new methods:
   - `grep -n "deduplicateActions" modules/AppVideoWizard/app/Services/NarrativeMomentService.php`
   - `grep -n "areActionsSimilar" modules/AppVideoWizard/app/Services/NarrativeMomentService.php`
   - `grep -n "validateActionUniqueness" modules/AppVideoWizard/app/Services/ShotIntelligenceService.php`
3. decomposeNarrationIntoMoments() calls deduplicateActions()
4. analyzeScene() includes actionUniqueness in result
</verification>

<success_criteria>
- Consecutive moments with same action verb get progression markers
- areActionsSimilar() detects synonyms and verb variations
- validateActionUniqueness() returns uniqueness score (0-100%)
- Analysis result includes actionUniqueness validation results
- Deduplication happens after interpolation to catch expanded duplicates
- PHP syntax valid for both files
</success_criteria>

<output>
After completion, create `.planning/phases/02-narrative-intelligence/02-03-SUMMARY.md`
</output>
