---
phase: 23-scene-level-shot-continuity
plan: 04
type: execute
wave: 1
depends_on: ["23-01", "23-02", "23-03"]
files_modified:
  - modules/AppVideoWizard/app/Services/ShotIntelligenceService.php
  - modules/AppVideoWizard/app/Livewire/VideoWizard.php
autonomous: true
user_setup: []
gap_closure: true

must_haves:
  truths:
    - "GlobalRules flags flow from VideoWizard to ShotIntelligenceService continuity analysis"
    - "DynamicShotEngine shots are post-processed through Hollywood continuity checks"
    - "Continuity enforcement can be toggled via storyBible cinematography settings"
    - "decomposeSceneWithDynamicEngine returns shots with continuity metadata"
  artifacts:
    - path: "modules/AppVideoWizard/app/Services/ShotIntelligenceService.php"
      provides: "Public applyContinuityAnalysis method for external calls"
      exports: ["applyContinuityAnalysis"]
    - path: "modules/AppVideoWizard/app/Livewire/VideoWizard.php"
      provides: "Post-processing of DynamicShotEngine shots through continuity analysis"
      contains: "applyContinuityAnalysis"
  key_links:
    - from: "VideoWizard::decomposeSceneWithDynamicEngine()"
      to: "ShotIntelligenceService::applyContinuityAnalysis()"
      via: "method call after shots are built"
      pattern: "applyContinuityAnalysis.*shots.*context"
    - from: "ShotIntelligenceService::applyContinuityAnalysis()"
      to: "ShotContinuityService::analyzeHollywoodContinuity()"
      via: "internal delegation"
      pattern: "analyzeHollywoodContinuity"
---

<objective>
Wire DynamicShotEngine shots through ShotIntelligenceService continuity analysis

Purpose: Plans 23-01, 23-02, and 23-03 implemented all the Hollywood continuity logic in ShotIntelligenceService and ShotContinuityService. However, this code is never executed because decomposeSceneWithDynamicEngine uses DynamicShotEngine directly without calling ShotIntelligenceService. This gap closure wires the active code path to the existing continuity implementation.

Output: Modified ShotIntelligenceService with public wrapper method, and VideoWizard that post-processes DynamicShotEngine shots through continuity analysis.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-scene-level-shot-continuity/23-VERIFICATION.md
@.planning/phases/23-scene-level-shot-continuity/23-01-SUMMARY.md
@.planning/phases/23-scene-level-shot-continuity/23-02-SUMMARY.md
@.planning/phases/23-scene-level-shot-continuity/23-03-SUMMARY.md
@modules/AppVideoWizard/app/Services/ShotIntelligenceService.php
@modules/AppVideoWizard/app/Livewire/VideoWizard.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add public applyContinuityAnalysis() wrapper method</name>
  <files>modules/AppVideoWizard/app/Services/ShotIntelligenceService.php</files>
  <action>
Add a new PUBLIC method `applyContinuityAnalysis(array $shots, array $context): array` that wraps the existing protected continuity logic for external callers (like VideoWizard).

The method should:
1. Check if continuity service is available (fallback gracefully if not)
2. Enrich shots with spatial data using existing enrichShotsWithSpatialData()
3. Call analyzeHollywoodContinuity() with enforcement flags from context
4. Return an array with:
   - 'shots' => enriched shot array
   - 'continuity' => continuity analysis result (scores, issues, enforcement info)

Place this method in the PUBLIC methods section (around line 136, after setNarrativeMomentService).

Implementation:
```php
/**
 * PHASE 23: Apply Hollywood continuity analysis to pre-built shots.
 * Public wrapper for external callers (VideoWizard's DynamicShotEngine path).
 *
 * @param array $shots Array of shot data (from DynamicShotEngine)
 * @param array $context Context including globalRules enforcement flags
 * @return array ['shots' => enriched shots, 'continuity' => analysis result]
 */
public function applyContinuityAnalysis(array $shots, array $context = []): array
{
    // Initialize continuity service if not set
    if (!$this->continuityService) {
        $this->continuityService = app(ShotContinuityService::class);
    }

    // Check if continuity is enabled
    if (!$this->continuityService || !$this->continuityService->isContinuityEnabled()) {
        return [
            'shots' => $shots,
            'continuity' => [
                'enabled' => false,
                'score' => null,
                'issues' => [],
                'suggestions' => [],
            ],
        ];
    }

    // PHASE 23: Enrich shots with spatial data (lookDirection, screenDirection)
    $enrichedShots = $this->enrichShotsWithSpatialData($shots);

    // Extract enforcement flags from context (Phase 23-02)
    $globalRules = $context['globalRules'] ?? [];
    $enforce180Rule = $globalRules['enforce180Rule'] ?? true;
    $enforceEyeline = $globalRules['enforceEyeline'] ?? true;
    $enforceMatchCuts = $globalRules['enforceMatchCuts'] ?? true;

    // Get scene context for Hollywood analysis
    $sceneType = $context['sceneType'] ?? VwSetting::getValue('shot_continuity_default_scene_type', 'dialogue');
    $progressionType = $context['progressionType'] ?? 'building';

    // Run Hollywood continuity analysis (Phase 23-03 respects enforcement flags)
    $continuityResult = $this->continuityService->analyzeHollywoodContinuity($enrichedShots, [
        'sceneType' => $sceneType,
        'progressionType' => $progressionType,
        'enforce180Rule' => $enforce180Rule,
        'enforceEyeline' => $enforceEyeline,
        'enforceMatchCuts' => $enforceMatchCuts,
    ]);

    Log::debug('ShotIntelligenceService: Applied continuity analysis to external shots', [
        'shot_count' => count($enrichedShots),
        'overall_score' => $continuityResult['overall'] ?? null,
        'issues_count' => count($continuityResult['issues'] ?? []),
        'enforcement' => [
            'enforce180Rule' => $enforce180Rule,
            'enforceEyeline' => $enforceEyeline,
            'enforceMatchCuts' => $enforceMatchCuts,
        ],
    ]);

    return [
        'shots' => $enrichedShots,
        'continuity' => $continuityResult,
    ];
}
```
  </action>
  <verify>
Method exists and is public: `grep -n "public function applyContinuityAnalysis" modules/AppVideoWizard/app/Services/ShotIntelligenceService.php`

Method calls enrichShotsWithSpatialData: `grep -A20 "function applyContinuityAnalysis" modules/AppVideoWizard/app/Services/ShotIntelligenceService.php | grep "enrichShotsWithSpatialData"`

Method calls analyzeHollywoodContinuity: `grep -A30 "function applyContinuityAnalysis" modules/AppVideoWizard/app/Services/ShotIntelligenceService.php | grep "analyzeHollywoodContinuity"`
  </verify>
  <done>ShotIntelligenceService has public applyContinuityAnalysis() method that wraps enrichment and Hollywood analysis</done>
</task>

<task type="auto">
  <name>Task 2: Wire decomposeSceneWithDynamicEngine to continuity analysis</name>
  <files>modules/AppVideoWizard/app/Livewire/VideoWizard.php</files>
  <action>
In the `decomposeSceneWithDynamicEngine()` method, add a call to ShotIntelligenceService::applyContinuityAnalysis() AFTER the shots are fully built but BEFORE the method returns.

Find the section around line 18700-18710 where the method prepares to return shots. Insert the continuity analysis call:

```php
// Validate shot purposes for logical progression
$shots = $this->validateShotPurposes($shots);

// ═══════════════════════════════════════════════════════════════════════════════
// PHASE 23: Apply Hollywood continuity analysis to DynamicShotEngine shots
// This connects the Phase 23 continuity implementation to the active code path
// ═══════════════════════════════════════════════════════════════════════════════
try {
    $shotIntelligenceService = app(ShotIntelligenceService::class);
    $continuityResult = $shotIntelligenceService->applyContinuityAnalysis($shots, $context);

    // Use enriched shots with spatial data
    $shots = $continuityResult['shots'];

    // Store continuity analysis for UI display or debugging
    $continuityAnalysis = $continuityResult['continuity'];

    Log::info('VideoWizard: Hollywood continuity analysis applied', [
        'scene_id' => $sceneId,
        'shot_count' => count($shots),
        'continuity_score' => $continuityAnalysis['overall'] ?? null,
        'issues_count' => count($continuityAnalysis['issues'] ?? []),
        'rules_enforced' => $continuityAnalysis['rulesEnforced'] ?? [],
    ]);
} catch (\Exception $e) {
    Log::warning('VideoWizard: Failed to apply continuity analysis', [
        'scene_id' => $sceneId,
        'error' => $e->getMessage(),
    ]);
    // Continue without continuity - shots still work, just without Hollywood checks
}

Log::info('VideoWizard: Story beats applied to shots', [
    // ... existing log ...
]);

return $shots;
```

The insertion point is AFTER line 18701 (`$shots = $this->validateShotPurposes($shots);`) and BEFORE line 18703 (the Log::info for story beats).

IMPORTANT: The $context variable is already available in this method from line 18516 (`$context = $this->buildDecompositionContext(...)`), and it already includes globalRules from Plan 23-02.
  </action>
  <verify>
Check ShotIntelligenceService is called: `grep -n "applyContinuityAnalysis" modules/AppVideoWizard/app/Livewire/VideoWizard.php`

Check it's in decomposeSceneWithDynamicEngine: `grep -B5 "applyContinuityAnalysis" modules/AppVideoWizard/app/Livewire/VideoWizard.php | grep -E "decomposeSceneWithDynamicEngine|validateShotPurposes|PHASE 23"`

PHP syntax valid: `php -l modules/AppVideoWizard/app/Livewire/VideoWizard.php`
  </verify>
  <done>decomposeSceneWithDynamicEngine() calls ShotIntelligenceService::applyContinuityAnalysis() to apply Hollywood continuity analysis</done>
</task>

<task type="auto">
  <name>Task 3: Verify end-to-end wiring</name>
  <files>modules/AppVideoWizard/app/Livewire/VideoWizard.php, modules/AppVideoWizard/app/Services/ShotIntelligenceService.php</files>
  <action>
Verify the complete Phase 23 wiring by tracing the data flow:

1. Confirm VideoWizard imports are complete:
   - ShotIntelligenceService should already be imported at line 28

2. Verify the flow path:
   ```
   VideoWizard::decomposeSceneWithDynamicEngine()
     ↓ builds $context with globalRules (Plan 23-02)
     ↓ DynamicShotEngine builds $shots
     ↓ calls ShotIntelligenceService::applyContinuityAnalysis($shots, $context)
       ↓ enrichShotsWithSpatialData() adds lookDirection/screenDirection (Plan 23-01)
       ↓ analyzeHollywoodContinuity() runs with enforcement flags (Plan 23-03)
     ↓ returns enriched shots with continuity metadata
   ```

3. PHP syntax validation:
   ```bash
   php -l modules/AppVideoWizard/app/Services/ShotIntelligenceService.php
   php -l modules/AppVideoWizard/app/Livewire/VideoWizard.php
   ```

4. Verify integration points with grep:
   - globalRules flows from buildDecompositionContext
   - applyContinuityAnalysis is called in decomposeSceneWithDynamicEngine
   - enrichShotsWithSpatialData is called in applyContinuityAnalysis
   - analyzeHollywoodContinuity is called in applyContinuityAnalysis
  </action>
  <verify>
Complete flow exists: `grep -l "applyContinuityAnalysis" modules/AppVideoWizard/app/Livewire/VideoWizard.php modules/AppVideoWizard/app/Services/ShotIntelligenceService.php`

globalRules in context: `grep -n "globalRules" modules/AppVideoWizard/app/Livewire/VideoWizard.php | head -5`

PHP syntax valid for both files:
- `php -l modules/AppVideoWizard/app/Services/ShotIntelligenceService.php`
- `php -l modules/AppVideoWizard/app/Livewire/VideoWizard.php`
  </verify>
  <done>End-to-end wiring verified: VideoWizard -> ShotIntelligenceService -> ShotContinuityService for Hollywood continuity</done>
</task>

</tasks>

<verification>
After all tasks complete, verify the gap is closed:

1. **Public method exists:** ShotIntelligenceService has `public function applyContinuityAnalysis()`
2. **Active path wired:** decomposeSceneWithDynamicEngine calls applyContinuityAnalysis after building shots
3. **Context flows:** globalRules from buildDecompositionContext reaches applyContinuityAnalysis
4. **Enrichment works:** Shots get lookDirection and screenDirection fields
5. **Hollywood analysis runs:** analyzeHollywoodContinuity is called with enforcement flags
6. **Enforcement respected:** Rules can be toggled via storyBible cinematography settings

Run the full flow trace:
```
VideoWizard::decomposeSceneWithDynamicEngine()
  -> $context = buildDecompositionContext() [includes globalRules]
  -> DynamicShotEngine::generateHollywoodShotSequence() [builds shots]
  -> ShotIntelligenceService::applyContinuityAnalysis($shots, $context)
    -> enrichShotsWithSpatialData() [adds lookDirection, screenDirection]
    -> ShotContinuityService::analyzeHollywoodContinuity() [with enforcement flags]
  -> return enriched shots with continuity metadata
```
</verification>

<success_criteria>
- All three verification gaps from 23-VERIFICATION.md are closed:
  1. "GlobalRules flags are passed to shot generation context" - Now flows to ShotIntelligenceService
  2. "enforce180Rule, enforceEyeline, enforceMatchCuts flags flow to ShotIntelligenceService" - Now used in applyContinuityAnalysis
  3. "Continuity enforcement can be toggled via storyBible cinematography settings" - Full path connected
- DynamicShotEngine shots receive Hollywood continuity analysis
- Shots are enriched with spatial metadata for 180-degree and eyeline checks
- PHP syntax valid for all modified files
</success_criteria>

<output>
After completion, create `.planning/phases/23-scene-level-shot-continuity/23-04-SUMMARY.md`
</output>
