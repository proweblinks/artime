---
phase: 05-emotional-arc-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - modules/AppVideoWizard/app/Services/NarrativeMomentService.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Climax is detected from content analysis, not fixed 70% rule"
    - "Peak detection identifies multiple intensity peaks"
    - "Narrative keywords trigger climax identification"
    - "Climax position stored in shot data"
  artifacts:
    - path: "modules/AppVideoWizard/app/Services/NarrativeMomentService.php"
      provides: "Intelligent climax detection"
      contains: "detectClimaxFromContent"
  key_links:
    - from: "NarrativeMomentService.php"
      to: "emotional arc"
      via: "content-based climax detection"
      pattern: "climaxDetection"
---

<objective>
Replace rule-based climax detection (fixed 70%) with intelligent content analysis.

**PROBLEM:** Current climax detection is naive:
- Uses fixed 70% position regardless of content
- No analysis of narrative keywords
- No peak detection from actual intensity values
- Single climax assumption (no multi-peak support)

Purpose: Detect climax moments from narrative content, not arbitrary position.

Output: Climax detected from action verbs, emotional keywords, and intensity patterns.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@modules/AppVideoWizard/app/Services/NarrativeMomentService.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add climax keyword detection</name>
  <files>modules/AppVideoWizard/app/Services/NarrativeMomentService.php</files>
  <action>
Add constants and method for climax keyword detection:

```php
/**
 * PHASE 5: Keywords that indicate climax/peak moments in narrative.
 */
protected const CLIMAX_KEYWORDS = [
    // Action peaks
    'reveals', 'discovers', 'confronts', 'attacks', 'escapes',
    'transforms', 'explodes', 'crashes', 'collapses', 'breaks',

    // Emotional peaks
    'screams', 'cries', 'confesses', 'declares', 'realizes',
    'understands', 'accepts', 'rejects', 'forgives', 'betrays',

    // Narrative turns
    'finally', 'suddenly', 'at last', 'the truth', 'everything changes',
    'no turning back', 'moment of truth', 'now or never',

    // Conflict peaks
    'showdown', 'battle', 'fight', 'duel', 'confrontation',
    'standoff', 'face to face', 'ultimate', 'final',
];

/**
 * PHASE 5: Keywords that indicate resolution/falling action.
 */
protected const RESOLUTION_KEYWORDS = [
    'peace', 'calm', 'quiet', 'settles', 'rests', 'heals',
    'forgiven', 'reconciled', 'together', 'home', 'safe',
    'aftermath', 'later', 'eventually', 'in the end',
];

/**
 * PHASE 5: Analyze text for climax indicators.
 *
 * @param string $text Narrative text to analyze
 * @return array Climax analysis with score and triggers
 */
protected function analyzeClimaxIndicators(string $text): array
{
    $textLower = strtolower($text);
    $climaxScore = 0;
    $triggers = [];

    // Check for climax keywords
    foreach (self::CLIMAX_KEYWORDS as $keyword) {
        if (stripos($textLower, $keyword) !== false) {
            $climaxScore += 0.15;
            $triggers[] = $keyword;
        }
    }

    // Check for resolution keywords (reduces climax likelihood)
    foreach (self::RESOLUTION_KEYWORDS as $keyword) {
        if (stripos($textLower, $keyword) !== false) {
            $climaxScore -= 0.1;
        }
    }

    // Punctuation analysis
    $exclamationCount = substr_count($text, '!');
    $climaxScore += min($exclamationCount * 0.1, 0.3);

    // All caps words indicate emphasis
    preg_match_all('/\b[A-Z]{2,}\b/', $text, $capsMatches);
    $climaxScore += min(count($capsMatches[0]) * 0.1, 0.2);

    // Cap the score
    $climaxScore = max(0, min(1, $climaxScore));

    return [
        'score' => $climaxScore,
        'triggers' => array_slice($triggers, 0, 5),
        'isLikelyClimax' => $climaxScore >= 0.3,
    ];
}
```

WHY: Content-based climax detection is more accurate than position-based.
  </action>
  <verify>
    - CLIMAX_KEYWORDS constant exists
    - RESOLUTION_KEYWORDS constant exists
    - `analyzeClimaxIndicators()` method exists
    - Returns score, triggers, and isLikelyClimax
    - No PHP syntax errors
  </verify>
  <done>Climax keyword detection added</done>
</task>

<task type="auto">
  <name>Task 2: Add peak detection algorithm</name>
  <files>modules/AppVideoWizard/app/Services/NarrativeMomentService.php</files>
  <action>
Add method to detect intensity peaks in the arc:

```php
/**
 * PHASE 5: Detect peaks in an intensity array.
 * A peak is a local maximum higher than neighbors by threshold.
 *
 * @param array $intensities Array of intensity values (0-1)
 * @param float $threshold Minimum difference to qualify as peak
 * @return array Peak indices and their intensities
 */
protected function detectIntensityPeaks(array $intensities, float $threshold = 0.15): array
{
    $peaks = [];
    $count = count($intensities);

    if ($count < 3) {
        // Not enough data for peak detection
        return $count > 0 ? [['index' => 0, 'intensity' => $intensities[0] ?? 0.5]] : [];
    }

    for ($i = 1; $i < $count - 1; $i++) {
        $current = $intensities[$i];
        $prev = $intensities[$i - 1];
        $next = $intensities[$i + 1];

        // Check if local maximum
        if ($current > $prev && $current > $next) {
            // Check if significant enough
            $diff = min($current - $prev, $current - $next);
            if ($diff >= $threshold) {
                $peaks[] = [
                    'index' => $i,
                    'intensity' => $current,
                    'prominence' => $diff,
                ];
            }
        }
    }

    // If no peaks found, use the maximum value position
    if (empty($peaks)) {
        $maxIndex = array_search(max($intensities), $intensities);
        $peaks[] = [
            'index' => $maxIndex,
            'intensity' => $intensities[$maxIndex],
            'prominence' => 0,
        ];
    }

    // Sort by intensity descending
    usort($peaks, fn($a, $b) => $b['intensity'] <=> $a['intensity']);

    return $peaks;
}

/**
 * PHASE 5: Identify the primary climax from peaks and content.
 *
 * @param array $moments Narrative moments with text and intensity
 * @return int Index of the primary climax moment
 */
protected function identifyPrimaryClimax(array $moments): int
{
    $count = count($moments);
    if ($count === 0) return 0;

    // Extract intensities
    $intensities = array_map(fn($m) => $m['intensity'] ?? 0.5, $moments);

    // Detect peaks
    $peaks = $this->detectIntensityPeaks($intensities);

    // Score each peak based on content analysis
    $scoredPeaks = [];
    foreach ($peaks as $peak) {
        $momentIndex = $peak['index'];
        $moment = $moments[$momentIndex] ?? [];
        $text = $moment['action'] ?? $moment['description'] ?? '';

        $contentAnalysis = $this->analyzeClimaxIndicators($text);

        // Combined score: intensity + content + position bonus
        $positionProgress = $momentIndex / max(1, $count - 1);
        $positionBonus = ($positionProgress >= 0.5 && $positionProgress <= 0.85) ? 0.1 : 0;

        $combinedScore = ($peak['intensity'] * 0.4) +
                         ($contentAnalysis['score'] * 0.4) +
                         ($peak['prominence'] * 0.1) +
                         $positionBonus;

        $scoredPeaks[] = [
            'index' => $momentIndex,
            'combinedScore' => $combinedScore,
            'intensity' => $peak['intensity'],
            'contentScore' => $contentAnalysis['score'],
        ];
    }

    // Return the highest scored peak
    usort($scoredPeaks, fn($a, $b) => $b['combinedScore'] <=> $a['combinedScore']);

    return $scoredPeaks[0]['index'] ?? intval($count * 0.7);
}
```

WHY: Peak detection finds actual intensity maxima, not assumed positions.
  </action>
  <verify>
    - `detectIntensityPeaks()` method exists
    - Returns peak indices with intensity and prominence
    - `identifyPrimaryClimax()` method exists
    - Combines intensity, content, and position scoring
    - Handles edge cases (empty array, single element)
    - No PHP syntax errors
  </verify>
  <done>Peak detection algorithm added</done>
</task>

<task type="auto">
  <name>Task 3: Create unified climax detection method</name>
  <files>modules/AppVideoWizard/app/Services/NarrativeMomentService.php</files>
  <action>
Add a main method that combines all climax detection logic:

```php
/**
 * PHASE 5: Detect climax from content analysis.
 * Replaces the fixed 70% rule with intelligent detection.
 *
 * @param array $moments Array of narrative moments
 * @return array Climax data with index, confidence, and metadata
 */
public function detectClimaxFromContent(array $moments): array
{
    $count = count($moments);
    if ($count === 0) {
        return [
            'index' => 0,
            'confidence' => 0,
            'method' => 'empty',
            'peaks' => [],
        ];
    }

    // Get primary climax index
    $climaxIndex = $this->identifyPrimaryClimax($moments);

    // Analyze content at climax point
    $climaxMoment = $moments[$climaxIndex] ?? [];
    $climaxText = $climaxMoment['action'] ?? $climaxMoment['description'] ?? '';
    $contentAnalysis = $this->analyzeClimaxIndicators($climaxText);

    // Detect all peaks for multi-climax narratives
    $intensities = array_map(fn($m) => $m['intensity'] ?? 0.5, $moments);
    $allPeaks = $this->detectIntensityPeaks($intensities, 0.1);

    // Calculate confidence
    $climaxIntensity = $moments[$climaxIndex]['intensity'] ?? 0.5;
    $confidence = min(1, ($climaxIntensity * 0.5) + ($contentAnalysis['score'] * 0.5));

    // Determine detection method
    $method = $contentAnalysis['isLikelyClimax'] ? 'content' :
              ($allPeaks[0]['prominence'] ?? 0) > 0.2 ? 'intensity_peak' : 'position_fallback';

    Log::debug('NarrativeMomentService: Climax detected', [
        'index' => $climaxIndex,
        'total_moments' => $count,
        'position' => round($climaxIndex / max(1, $count - 1) * 100) . '%',
        'method' => $method,
        'confidence' => round($confidence, 2),
        'triggers' => $contentAnalysis['triggers'],
    ]);

    return [
        'index' => $climaxIndex,
        'confidence' => $confidence,
        'method' => $method,
        'position' => $climaxIndex / max(1, $count - 1),
        'intensity' => $climaxIntensity,
        'triggers' => $contentAnalysis['triggers'],
        'peaks' => array_slice($allPeaks, 0, 3), // Top 3 peaks
        'isMultiClimax' => count($allPeaks) > 1,
    ];
}
```

WHY: Unified method provides all climax data for downstream consumers.
  </action>
  <verify>
    - `detectClimaxFromContent()` method exists (public)
    - Returns index, confidence, method, peaks
    - Logs climax detection for debugging
    - Handles empty input gracefully
    - No PHP syntax errors
  </verify>
  <done>Unified climax detection method created</done>
</task>

<task type="auto">
  <name>Task 4: Update applyEmotionalArc to use intelligent detection</name>
  <files>modules/AppVideoWizard/app/Services/NarrativeMomentService.php</files>
  <action>
Update the existing `applyEmotionalArc()` method to use intelligent climax detection:

Find the existing `applyEmotionalArc()` method and update the climax index calculation:

Replace the fixed 70% climax index:
```php
// OLD: $climaxIndex = max(1, intval($count * 0.7));
```

With intelligent detection:
```php
// PHASE 5: Use intelligent climax detection instead of fixed 70%
$climaxData = $this->detectClimaxFromContent($moments);
$climaxIndex = $climaxData['index'];

// Store climax metadata for downstream use
$climaxMetadata = [
    'method' => $climaxData['method'],
    'confidence' => $climaxData['confidence'],
    'isMultiClimax' => $climaxData['isMultiClimax'],
];
```

Also update the intensity assignment to respect detected peaks:
```php
// Apply intensity curve based on detected climax
foreach ($moments as $i => &$moment) {
    $position = $i / max(1, $count - 1);

    if ($i === $climaxIndex) {
        // Peak intensity at climax
        $moment['intensity'] = max($moment['intensity'] ?? 0.5, 0.85);
        $moment['isClimax'] = true;
        $moment['climaxMetadata'] = $climaxMetadata;
    } elseif ($position < ($climaxIndex / max(1, $count - 1))) {
        // Rising action - build toward climax
        $targetIntensity = 0.3 + ($position * 0.5);
        $moment['intensity'] = max($moment['intensity'] ?? 0.5, $targetIntensity);
    } else {
        // Falling action - decrease from climax
        $distanceFromClimax = $position - ($climaxIndex / max(1, $count - 1));
        $targetIntensity = 0.85 - ($distanceFromClimax * 0.6);
        $moment['intensity'] = max(0.3, min($moment['intensity'] ?? 0.5, $targetIntensity));
    }
}
```

WHY: This integrates intelligent detection into the existing arc application flow.
  </action>
  <verify>
    - `applyEmotionalArc()` now calls `detectClimaxFromContent()`
    - Climax index is from intelligent detection, not fixed 70%
    - Climax moment has `isClimax` flag and metadata
    - Rising/falling action respects detected climax position
    - No PHP syntax errors: `php -l modules/AppVideoWizard/app/Services/NarrativeMomentService.php`
  </verify>
  <done>applyEmotionalArc updated with intelligent detection</done>
</task>

</tasks>

<verification>
1. PHP syntax check: `php -l modules/AppVideoWizard/app/Services/NarrativeMomentService.php`
2. Grep for new methods:
   - `grep -n "detectClimaxFromContent" modules/AppVideoWizard/app/Services/NarrativeMomentService.php`
   - `grep -n "analyzeClimaxIndicators" modules/AppVideoWizard/app/Services/NarrativeMomentService.php`
   - `grep -n "detectIntensityPeaks" modules/AppVideoWizard/app/Services/NarrativeMomentService.php`
</verification>

<success_criteria>
- Climax detection uses content keywords, not fixed 70%
- Peak detection finds local maxima in intensity array
- Multiple peaks supported for complex narratives
- Climax metadata includes method, confidence, triggers
- applyEmotionalArc uses intelligent detection
- PHP syntax valid
</success_criteria>

<output>
After completion, create `.planning/phases/05-emotional-arc-system/05-01-SUMMARY.md`
</output>
