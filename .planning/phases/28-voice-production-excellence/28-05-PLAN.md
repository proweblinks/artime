---
phase: 28-voice-production-excellence
plan: 05
type: execute
wave: 3
depends_on: [28-01, 28-04]
files_modified:
  - modules/AppVideoWizard/app/Services/Voice/MultiSpeakerDialogueBuilder.php
  - modules/AppVideoWizard/app/Services/VoiceoverService.php
  - modules/AppVideoWizard/app/Providers/AppVideoWizardServiceProvider.php
autonomous: true

must_haves:
  truths:
    - "Multi-speaker dialogue generates unified audio"
    - "Each speaker segment uses correct voice from registry"
    - "Timing offsets track speaker transitions"
  artifacts:
    - path: "modules/AppVideoWizard/app/Services/Voice/MultiSpeakerDialogueBuilder.php"
      provides: "Multi-speaker dialogue assembly service"
      exports: ["buildDialogue", "assembleFromSegments"]
      min_lines: 100
    - path: "modules/AppVideoWizard/app/Services/VoiceoverService.php"
      provides: "generateMultiSpeakerDialogue method"
      contains: "generateMultiSpeakerDialogue"
  key_links:
    - from: "VoiceoverService.generateMultiSpeakerDialogue"
      to: "MultiSpeakerDialogueBuilder"
      via: "Builds dialogue structure"
      pattern: "MultiSpeakerDialogueBuilder"
    - from: "MultiSpeakerDialogueBuilder"
      to: "VoiceRegistryService"
      via: "Voice lookup per speaker"
      pattern: "VoiceRegistryService"
---

<objective>
Create MultiSpeakerDialogueBuilder for unified multi-speaker audio generation.

Purpose: VOC-10 requires handling conversations with 2+ characters in single generation.
Currently processMultiSpeakerShot generates sequential audio. This plan adds a builder
service that structures dialogue turns and generates unified audio with proper timing.

Output: MultiSpeakerDialogueBuilder service that assembles dialogue turns,
generateMultiSpeakerDialogue method in VoiceoverService.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-voice-production-excellence/28-RESEARCH.md

# Key files
@modules/AppVideoWizard/app/Services/VoiceoverService.php
@modules/AppVideoWizard/app/Services/VoiceRegistryService.php
@modules/AppVideoWizard/app/Services/SpeechSegment.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MultiSpeakerDialogueBuilder service</name>
  <files>modules/AppVideoWizard/app/Services/Voice/MultiSpeakerDialogueBuilder.php</files>
  <action>
Create the service file:

```php
<?php

namespace Modules\AppVideoWizard\Services\Voice;

use Illuminate\Support\Facades\Log;
use Modules\AppVideoWizard\Services\VoiceRegistryService;
use Modules\AppVideoWizard\Services\SpeechSegment;

/**
 * MultiSpeakerDialogueBuilder - Assembles multi-speaker dialogue for unified generation (VOC-10).
 *
 * Structures dialogue turns from multiple speakers with proper voice assignments
 * and timing offsets for seamless audio production.
 *
 * Supports two modes:
 * 1. Sequential generation: Each speaker turn generated separately, concatenated
 * 2. Native dialogue API: Structured for ElevenLabs Text-to-Dialogue (future)
 *
 * Usage:
 * ```php
 * $builder = app(MultiSpeakerDialogueBuilder::class);
 * $dialogue = $builder->buildDialogue($segments, $characterBible);
 * // Returns structured turns with voice assignments
 * ```
 */
class MultiSpeakerDialogueBuilder
{
    /**
     * Build dialogue structure from speech segments.
     *
     * @param array<SpeechSegment>|array $segments Speech segments (objects or arrays)
     * @param array $characterBible Character Bible for voice lookup
     * @param string $narratorVoice Default narrator voice
     * @return array{turns: array, speakers: array, statistics: array}
     */
    public function buildDialogue(array $segments, array $characterBible = [], string $narratorVoice = 'fable'): array
    {
        $registry = app(VoiceRegistryService::class);
        $registry->initializeFromCharacterBible($characterBible, $narratorVoice);

        $turns = [];
        $speakerSet = [];

        foreach ($segments as $index => $segment) {
            // Convert array to SpeechSegment if needed
            if (is_array($segment)) {
                $segment = SpeechSegment::fromArray($segment);
            }

            // Skip empty segments
            if (empty(trim($segment->text ?? ''))) {
                continue;
            }

            $speaker = $segment->speaker ?? 'NARRATOR';
            $speakerUpper = strtoupper(trim($speaker));

            // Get voice from registry
            $voiceId = $registry->getVoiceForCharacter($speaker, function($name) use ($characterBible, $narratorVoice) {
                return $this->fallbackVoiceLookup($name, $characterBible, $narratorVoice);
            });

            $turns[] = [
                'index' => $index,
                'speaker' => $speaker,
                'speakerNormalized' => $speakerUpper,
                'text' => $segment->text,
                'voiceId' => $voiceId,
                'emotion' => $segment->emotion ?? null,
                'type' => $segment->type ?? SpeechSegment::TYPE_DIALOGUE,
                'needsLipSync' => $segment->needsLipSync ?? false,
            ];

            $speakerSet[$speakerUpper] = [
                'name' => $speaker,
                'voiceId' => $voiceId,
            ];
        }

        Log::debug('MultiSpeakerDialogueBuilder: Built dialogue structure (VOC-10)', [
            'turnCount' => count($turns),
            'speakerCount' => count($speakerSet),
            'speakers' => array_keys($speakerSet),
        ]);

        return [
            'turns' => $turns,
            'speakers' => $speakerSet,
            'statistics' => [
                'turnCount' => count($turns),
                'speakerCount' => count($speakerSet),
                'totalWords' => array_sum(array_map(fn($t) => str_word_count($t['text']), $turns)),
            ],
        ];
    }

    /**
     * Assemble dialogue turns from raw segment data.
     *
     * Convenience method that handles both array and object segments.
     *
     * @param array $rawSegments Raw segment arrays
     * @param array $characterBible Character Bible data
     * @return array Dialogue structure
     */
    public function assembleFromSegments(array $rawSegments, array $characterBible = []): array
    {
        $segments = array_map(function($seg) {
            return is_array($seg) ? SpeechSegment::fromArray($seg) : $seg;
        }, $rawSegments);

        return $this->buildDialogue($segments, $characterBible);
    }

    /**
     * Format dialogue for ElevenLabs Text-to-Dialogue API.
     *
     * Returns structure compatible with ElevenLabs native multi-speaker API.
     * Note: This is for future integration when we add ElevenLabs dialogue support.
     *
     * @param array $dialogue Dialogue from buildDialogue()
     * @return array ElevenLabs dialogue format
     */
    public function formatForElevenLabs(array $dialogue): array
    {
        $formatted = [];

        foreach ($dialogue['turns'] as $turn) {
            $text = $turn['text'];

            // Add emotion tag if present (ElevenLabs format)
            if (!empty($turn['emotion'])) {
                $emotion = strtolower($turn['emotion']);
                $text = "[{$emotion}] {$text}";
            }

            $formatted[] = [
                'voice_id' => $turn['voiceId'],
                'text' => $text,
            ];
        }

        return [
            'dialogue_turns' => $formatted,
            'model_id' => 'eleven_multilingual_v2',
        ];
    }

    /**
     * Calculate estimated duration for dialogue.
     *
     * @param array $dialogue Dialogue structure
     * @param float $wordsPerMinute Average speaking rate
     * @return float Estimated duration in seconds
     */
    public function estimateDuration(array $dialogue, float $wordsPerMinute = 150): float
    {
        $totalWords = $dialogue['statistics']['totalWords'] ?? 0;
        return ($totalWords / $wordsPerMinute) * 60;
    }

    /**
     * Fallback voice lookup when character not in registry.
     *
     * @param string $name Character name
     * @param array $characterBible Character Bible data
     * @param string $narratorVoice Default narrator voice
     * @return string Voice ID
     */
    protected function fallbackVoiceLookup(string $name, array $characterBible, string $narratorVoice): string
    {
        $nameUpper = strtoupper(trim($name));

        if ($nameUpper === 'NARRATOR') {
            return $narratorVoice;
        }

        // Look in Character Bible
        foreach ($characterBible['characters'] ?? [] as $char) {
            if (strtoupper(trim($char['name'] ?? '')) === $nameUpper) {
                if (!empty($char['voice']['id'])) {
                    return $char['voice']['id'];
                }
                // Assign by gender
                $gender = strtolower($char['gender'] ?? $char['voice']['gender'] ?? '');
                if (str_contains($gender, 'female')) return 'nova';
                if (str_contains($gender, 'male')) return 'onyx';
            }
        }

        // Hash-based consistent assignment
        $hash = crc32($nameUpper);
        $voices = ['echo', 'onyx', 'nova', 'shimmer', 'alloy'];
        return $voices[$hash % count($voices)];
    }
}
```
  </action>
  <verify>
Run: `php artisan tinker --execute="app(\Modules\AppVideoWizard\Services\Voice\MultiSpeakerDialogueBuilder::class)"`
Should instantiate without errors.
  </verify>
  <done>MultiSpeakerDialogueBuilder service created.</done>
</task>

<task type="auto">
  <name>Task 2: Add generateMultiSpeakerDialogue to VoiceoverService</name>
  <files>modules/AppVideoWizard/app/Services/VoiceoverService.php</files>
  <action>
Add a new public method to VoiceoverService for unified multi-speaker generation:

```php
/**
 * Generate unified audio for multi-speaker dialogue (VOC-10).
 *
 * Takes an array of speech segments and generates audio for each speaker turn,
 * tracking timing for proper sequencing. Uses MultiSpeakerDialogueBuilder for
 * structure and VoicePromptBuilderService for emotional enhancement.
 *
 * @param WizardProject $project The project
 * @param array $segments Array of SpeechSegment objects or arrays
 * @param array $options Options: characterBible, narratorVoice, speed, teamId, sceneId
 * @return array Result with individual turns and combined audio
 */
public function generateMultiSpeakerDialogue(WizardProject $project, array $segments, array $options = []): array
{
    $characterBible = $options['characterBible'] ?? [];
    $narratorVoice = $options['narratorVoice'] ?? 'fable';
    $speed = $options['speed'] ?? 1.0;
    $teamId = $options['teamId'] ?? $project->team_id ?? session('current_team_id', 0);
    $sceneId = $options['sceneId'] ?? 'dialogue-' . time();

    // Build dialogue structure
    $builder = app(\Modules\AppVideoWizard\Services\Voice\MultiSpeakerDialogueBuilder::class);
    $dialogue = $builder->buildDialogue($segments, $characterBible, $narratorVoice);

    if (empty($dialogue['turns'])) {
        return [
            'success' => false,
            'error' => 'No dialogue turns to generate',
            'turns' => [],
            'totalDuration' => 0,
        ];
    }

    Log::info('VoiceoverService: Generating multi-speaker dialogue (VOC-10)', [
        'project_id' => $project->id,
        'turnCount' => count($dialogue['turns']),
        'speakerCount' => count($dialogue['speakers']),
    ]);

    $results = [];
    $currentTime = 0;
    $successCount = 0;
    $provider = $this->getProvider();
    $basePath = "wizard-projects/{$project->id}/audio";
    $timestamp = time();

    foreach ($dialogue['turns'] as $turn) {
        $text = $turn['text'];

        // Apply emotional direction if emotion present (VOC-11 integration)
        $instructions = '';
        if (!empty($turn['emotion'])) {
            $enhanced = $this->enhanceTextWithVoiceDirection($text, $turn['emotion'], $provider);
            $text = $enhanced['text'];
            $instructions = $enhanced['instructions'];
        }

        try {
            // Generate TTS for this turn
            $speechOptions = ['voice' => $turn['voiceId']];
            if (!empty($instructions)) {
                $speechOptions['instructions'] = $instructions;
            }

            $audioResult = AI::process($text, 'speech', $speechOptions, $teamId);

            if (!empty($audioResult['error'])) {
                Log::warning('Multi-speaker turn generation failed (VOC-10)', [
                    'speaker' => $turn['speaker'],
                    'error' => $audioResult['error'],
                ]);
                continue;
            }

            $audioContent = $audioResult['data'][0] ?? null;
            if (!$audioContent) {
                continue;
            }

            // Calculate duration
            $wordCount = str_word_count($turn['text']);
            $duration = ($wordCount / 150) * 60 / $speed;

            // Store audio file
            $filename = Str::slug($sceneId) . "-turn-{$turn['index']}-{$timestamp}.mp3";
            $path = "{$basePath}/{$filename}";
            Storage::disk('public')->put($path, $audioContent);

            $results[] = [
                'index' => $turn['index'],
                'speaker' => $turn['speaker'],
                'voiceId' => $turn['voiceId'],
                'text' => $turn['text'],
                'emotion' => $turn['emotion'],
                'audioUrl' => url('/files/' . $path),
                'audioContent' => $audioContent,
                'duration' => $duration,
                'startTime' => $currentTime,
                'needsLipSync' => $turn['needsLipSync'],
            ];

            $currentTime += $duration;
            $successCount++;

        } catch (\Exception $e) {
            Log::error('Multi-speaker turn generation exception (VOC-10)', [
                'speaker' => $turn['speaker'],
                'error' => $e->getMessage(),
            ]);
        }
    }

    // Create combined audio file
    $combinedUrl = null;
    if (!empty($results)) {
        $combinedContent = implode('', array_column($results, 'audioContent'));
        $combinedFilename = Str::slug($sceneId) . "-dialogue-combined-{$timestamp}.mp3";
        $combinedPath = "{$basePath}/{$combinedFilename}";
        Storage::disk('public')->put($combinedPath, $combinedContent);
        $combinedUrl = url('/files/' . $combinedPath);

        // Create asset record
        $asset = WizardAsset::create([
            'project_id' => $project->id,
            'user_id' => $project->user_id,
            'type' => WizardAsset::TYPE_VOICEOVER,
            'name' => 'Multi-Speaker Dialogue - ' . $sceneId,
            'path' => $combinedPath,
            'url' => $combinedUrl,
            'mime_type' => 'audio/mpeg',
            'scene_id' => $sceneId,
            'metadata' => [
                'type' => 'multi_speaker_dialogue',
                'turns' => array_map(fn($r) => [
                    'speaker' => $r['speaker'],
                    'voiceId' => $r['voiceId'],
                    'duration' => $r['duration'],
                    'startTime' => $r['startTime'],
                ], $results),
                'speakerCount' => count($dialogue['speakers']),
                'totalDuration' => $currentTime,
            ],
        ]);
    }

    // Remove audioContent from results to reduce memory
    $cleanResults = array_map(function($r) {
        unset($r['audioContent']);
        return $r;
    }, $results);

    Log::info('VoiceoverService: Multi-speaker dialogue complete (VOC-10)', [
        'project_id' => $project->id,
        'turnsGenerated' => $successCount,
        'totalTurns' => count($dialogue['turns']),
        'totalDuration' => $currentTime,
    ]);

    return [
        'success' => $successCount > 0,
        'audioUrl' => $combinedUrl,
        'assetId' => $asset->id ?? null,
        'turns' => $cleanResults,
        'speakers' => $dialogue['speakers'],
        'totalDuration' => $currentTime,
        'statistics' => [
            'turnsGenerated' => $successCount,
            'totalTurns' => count($dialogue['turns']),
            'speakerCount' => count($dialogue['speakers']),
        ],
    ];
}
```

Add use statement if not present:
```php
use Modules\AppVideoWizard\Services\Voice\MultiSpeakerDialogueBuilder;
```
  </action>
  <verify>
Run: `php artisan tinker --execute="method_exists(\Modules\AppVideoWizard\Services\VoiceoverService::class, 'generateMultiSpeakerDialogue')"`
Should return true.
  </verify>
  <done>VoiceoverService has generateMultiSpeakerDialogue method.</done>
</task>

<task type="auto">
  <name>Task 3: Register MultiSpeakerDialogueBuilder in provider</name>
  <files>modules/AppVideoWizard/app/Providers/AppVideoWizardServiceProvider.php</files>
  <action>
Add MultiSpeakerDialogueBuilder to the service provider's register method:

```php
$this->app->singleton(\Modules\AppVideoWizard\Services\Voice\MultiSpeakerDialogueBuilder::class);
```

Or with full binding if that's the pattern used:
```php
$this->app->singleton(
    \Modules\AppVideoWizard\Services\Voice\MultiSpeakerDialogueBuilder::class,
    function ($app) {
        return new \Modules\AppVideoWizard\Services\Voice\MultiSpeakerDialogueBuilder();
    }
);
```

Match existing service registration patterns in the file.
  </action>
  <verify>
Run: `php artisan tinker --execute="app(\Modules\AppVideoWizard\Services\Voice\MultiSpeakerDialogueBuilder::class) instanceof \Modules\AppVideoWizard\Services\Voice\MultiSpeakerDialogueBuilder"`
Should return true.
  </verify>
  <done>MultiSpeakerDialogueBuilder registered in service provider.</done>
</task>

</tasks>

<verification>
After all tasks complete:
```php
// Test in tinker
$voiceoverService = app(\Modules\AppVideoWizard\Services\VoiceoverService::class);
$project = \Modules\AppVideoWizard\Models\WizardProject::first();

$segments = [
    ['text' => 'Hello, how are you?', 'speaker' => 'Alice', 'type' => 'dialogue'],
    ['text' => 'I am doing well, thanks!', 'speaker' => 'Bob', 'type' => 'dialogue'],
];

$result = $voiceoverService->generateMultiSpeakerDialogue($project, $segments, [
    'characterBible' => ['characters' => [
        ['name' => 'Alice', 'voice' => ['id' => 'nova']],
        ['name' => 'Bob', 'voice' => ['id' => 'onyx']],
    ]],
]);

// Should return success: true, with 2 turns
```
</verification>

<success_criteria>
- [ ] MultiSpeakerDialogueBuilder.php exists in Services/Voice/
- [ ] buildDialogue returns structured turns with voice assignments
- [ ] generateMultiSpeakerDialogue generates audio for each turn
- [ ] Combined audio file created with all turns
- [ ] Timing offsets correctly calculated
- [ ] Emotional direction applied when emotion present
</success_criteria>

<output>
After completion, create `.planning/phases/28-voice-production-excellence/28-05-SUMMARY.md`
</output>
